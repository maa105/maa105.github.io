{"version":3,"sources":["environment/App/App.module.css","lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withSelectionBlocker.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/components/BaseTextArea.js","lib/hooks/useDebounceValue.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hooks/usePrev.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["module","exports","mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","blockMarkerUpdates","selection","lastKey","markers","markerWithStartTouchedIndex","markerWithEndTouchedIndex","selectionStart","selectionEnd","block","markerWithStartTouched","markerWithEndTouched","isLocked","start","end","getMarkerSelections","prevMarkerIndex","nextMarkerIndex","selectedMarkersRange","startIndex","endIndex","startSelectedMarkerIndex","endSelectedMarkerIndex","midSelectedMarkerIndex","getReturn","marker","startTotallySelected","endTotallySelected","totalySelected","withMarkerSelectionBlocker","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","restProps","innerRef","useEffect","textarea","onPointerDownListener","pointerDown","onPointerUpListener","addEventListener","document","removeEventListener","e","target","isSingleSelection","prevSelection","startCursorMoved","endCursorMoved","midSelectedMarker","endSelectedMarker","startSelectedMarker","DEFAULT_END","spaces","getMarkerRawValue","textareaValue","substring","createMarker","uuid","anchor","type","markerData","data","Math","round","random","Date","now","parseMarkers","options","anchors","parts","j","key","startChar","endChars","partStart","push","anchorChar","version","wrapMarkerParser","markerOffset","oldFirstMarker","map","prevValue","insertedText","markerParser","newValue","lengthChange","inEditMarkerIndex","newMarkers","slice","nextMarkers","inEditMarker","startParse","endParse","toParse","parsedValue","parsedMarkers","nextNewMarkers","getIneditMarkerIndex","withMarkerParser","markerParserOptions","forEach","endChar","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","onInEditMarkerChange","imperativeRef","props","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","updateMarker","findIndex","m","updateFunction","newMarker","textValue","markerUpdates","hasNewText","join","oldValue","oldMarkers","undefined","childImperativeRef","onKeyDown","lastKeyDown","blockResult","preventDefault","hadRangeSelection","isSingleDelete","isSingleBackspace","deletedCount","newSelection","error","oldInEditMarkerIndex","newCursorPosition","newInEditMarkerIndex","oldInEditMarker","newInEditMarker","onInEditMarkerChangeEventArgs","properties","getCoordinatesAtPositions","positions","debug","el","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","pointerEnter","clearTimeout","timer","visibile","showTip","hideTip","pointerLeave","setTimeout","focus","delta","markerUuid","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onPointerEnter","onPointerLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","constraints","to","renderTarget","renderElement","focusParent","onHide","whereToFocus","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","Boolean","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultLineHeight","defaultBackgroundColor","classNameGetters","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","onKeyUpListener","withHideTipOnEscape","listener","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","newTipsData","newTipsDataStack","filter","lastTipData","oldDataStack","newDataStack","currType","BaseTextArea","React","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","withFocusTipOnDown","tipData","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","inMe","dataset","tipForTextarea","tipAnchorForTextarea","tipForMarker","tipAnchorForMarker","usePrev","preValue","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","getSingleTip","tipOptions","search","SearchResultsComponent","ResultsComponent","SearchResultsItemComponent","ResultItemComponent","resultItemComponentOnSelect","NoResultItemComponent","searchFunction","loader","preProcessMarkerData","preProcessMarkerDataForSearch","getCacheKey","getSearchCacheKey","searchData","SearchLoaderComponent","LoaderComponent","SearchErrorComponent","ErrorComponent","debounceDuration","details","DetailComponent","Component","loadSingleFunction","DetailNotFoundComponent","NotFoundComponent","preProcessMarkerDataForSingleLoad","getDetailsCacheKey","DetailLoaderComponent","DetailErrorComponent","CommonLoaderComponent","CommonErrorComponent","getCache","cache","loading","setResult","loadData","cacheKey","cachedData","getItem","abortCtrl","AbortController","signal","then","result","setItem","catch","aborted","abort","getDetailComponent","ItemComponent","NoItemsComponent","ContainerComponent","ResultListComponent","onSelect","results","focusedIndex","setFocusedIndex","index","num","mod","select","selectedItem","focused","toFocus","next","item","tabIndex","getSearchResultPickerComponent","setResults","cachedResults","getTip","tipsOptionsByType","ComponentsByType","defaultGetCache","withSmartTextArea","baseAnchors","hideTipOnEscape","getId","err","wrapGetCache","searchOptions","detailsOptions","withId","people","name","imageUrl","things","SmartTextArea","person","src","alt","Promise","resolve","reject","trim","toLocaleLowerCase","includes","toLowerCase","Error","personSearch","countDown","setCountDown","updateMarkerRef","setInterval","clearInterval","done","find","personDetails","thing","thingSearch","thingDetails","message","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.f04d8d02.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"inEditMarker\":\"App_inEditMarker__2hzif\"};","const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (typeof ref === 'string') {\n        // console.log(ref, element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","export const blockMarkerUpdates = ({selection, lastKey}) => {\n  const {\n    markers,\n    markerWithStartTouchedIndex,\n    markerWithEndTouchedIndex,\n    selectionStart,\n    selectionEnd,\n  } = selection;\n\n  if (selectionStart !== selectionEnd) {\n    return {\n      block: false,\n    };\n  }\n\n  const markerWithStartTouched = markers[markerWithStartTouchedIndex];\n  const markerWithEndTouched = markers[markerWithEndTouchedIndex];\n\n  if (lastKey === 'Backspace') {\n    if (markerWithEndTouched && markerWithEndTouched.isLocked) {\n      return {\n        block: true,\n        selectionStart: markerWithEndTouched.start,\n        selectionEnd: markerWithEndTouched.end,\n      };\n    }\n  } else if (lastKey === 'Delete') {\n    if (markerWithStartTouched && markerWithStartTouched.isLocked) {\n      return {\n        block: true,\n        selectionStart: markerWithStartTouched.start,\n        selectionEnd: markerWithStartTouched.end,\n      };\n    }\n  }\n  return {\n    block: false,\n  };\n};\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const start = selectionStart;\n  const end = selectionEnd;\n\n  const selectedMarkersRange = {startIndex: -1, endIndex: -1};\n  let startSelectedMarkerIndex = -1;\n  let endSelectedMarkerIndex = -1;\n  let midSelectedMarkerIndex = -1;\n  let markerWithStartTouchedIndex = -1;\n  let markerWithEndTouchedIndex = -1;\n  let prevMarkerIndex;\n  let nextMarkerIndex;\n  let i = 0;\n\n  const getReturn = () => ({\n    markers,\n    selectedMarkersRange,\n    startSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    midSelectedMarkerIndex,\n    markerWithStartTouchedIndex,\n    markerWithEndTouchedIndex,\n    prevMarkerIndex,\n    nextMarkerIndex:\n      (nextMarkerIndex ?? -1) >= markers.length ? -1 : nextMarkerIndex ?? -1,\n  });\n\n  for (; i < markers.length && markers[i].end < start; i++);\n\n  prevMarkerIndex = i - 1;\n\n  let marker = markers[i];\n  if (!marker) {\n    return getReturn();\n  }\n\n  if (marker.end === start) {\n    markerWithEndTouchedIndex = prevMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n  }\n\n  if (marker.start >= end) {\n    nextMarkerIndex = i;\n    if (marker.start === end) {\n      markerWithStartTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected = start <= marker.start && marker.start < end;\n  let endTotallySelected = start < marker.end && marker.end <= end;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedMarkerIndex = i;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedMarkerIndex = i;\n      nextMarkerIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedMarkersRange.startIndex = i;\n\n  i++;\n  for (; i < markers.length; i++) {\n    marker = markers[i];\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedMarkersRange.endIndex = i;\n  return getReturn();\n};\n\nconst withMarkerSelectionBlocker = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {onSelectionChange: onSelectionChangeFromParent, markers, ...restProps},\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        let start = selectionStart;\n        let end = selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.start === selectionStart\n            ? 0\n            : selectionStart - prevSelection.start;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.end === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.end;\n\n        let {\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          // eslint-disable-next-line prefer-const\n          prevMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          nextMarkerIndex,\n        } = getMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n        });\n\n        if (midSelectedMarkerIndex >= 0) {\n          const midSelectedMarker = markers[midSelectedMarkerIndex];\n          if (midSelectedMarker.isLocked) {\n            if (isSingleSelection) {\n              if (startCursorMoved < 0) {\n                start = end = midSelectedMarker.start;\n                markerWithStartTouchedIndex = midSelectedMarkerIndex;\n              } else {\n                start = end = midSelectedMarker.end;\n                markerWithEndTouchedIndex = midSelectedMarkerIndex;\n              }\n              midSelectedMarkerIndex = -1;\n            } else {\n              start = midSelectedMarker.start;\n              end = midSelectedMarker.end;\n              selectedMarkersRange.startIndex = midSelectedMarkerIndex;\n              selectedMarkersRange.endIndex = midSelectedMarkerIndex;\n              midSelectedMarkerIndex = -1;\n            }\n          }\n        } else {\n          if (endSelectedMarkerIndex >= 0) {\n            const endSelectedMarker = markers[endSelectedMarkerIndex];\n            if (endSelectedMarker.isLocked) {\n              if (startCursorMoved < 0) {\n                start = endSelectedMarker.start;\n                selectedMarkersRange.startIndex = endSelectedMarkerIndex;\n                if (selectedMarkersRange.endIndex === -1) {\n                  selectedMarkersRange.endIndex = endSelectedMarkerIndex;\n                }\n                endSelectedMarkerIndex = -1;\n              } else {\n                start = endSelectedMarker.end;\n                markerWithEndTouchedIndex = endSelectedMarkerIndex;\n                endSelectedMarkerIndex = -1;\n              }\n            }\n          }\n          if (startSelectedMarkerIndex >= 0) {\n            const startSelectedMarker = markers[startSelectedMarkerIndex];\n            if (startSelectedMarker.isLocked) {\n              if (endCursorMoved > 0) {\n                end = startSelectedMarker.end;\n                selectedMarkersRange.endIndex = startSelectedMarkerIndex;\n                if (selectedMarkersRange.startIndex === -1) {\n                  selectedMarkersRange.startIndex = startSelectedMarkerIndex;\n                }\n                startSelectedMarkerIndex = -1;\n              } else {\n                end = startSelectedMarker.start;\n                markerWithStartTouchedIndex = startSelectedMarkerIndex;\n                startSelectedMarkerIndex = -1;\n              }\n            }\n          }\n        }\n\n        if (selectionEnd !== end) {\n          textarea.selectionEnd = end;\n        }\n        if (selectionStart !== start) {\n          textarea.selectionStart = start;\n        }\n        if (!mutableRef.current.pointerDown) {\n          mutableRef.current.selection = {start, end};\n        }\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            markers,\n\n            selectionStart: start,\n            selectionEnd: end,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            selectedMarkersRange,\n            startSelectedMarkerIndex,\n            markerWithStartTouchedIndex,\n            nextMarkerIndex,\n          });\n      };\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const onPointerDownListener = () => {\n          mutableRef.current.pointerDown = true;\n        };\n        const onPointerUpListener = () => {\n          mutableRef.current.pointerDown = false;\n        };\n        textarea.addEventListener('pointerdown', onPointerDownListener);\n        document.addEventListener('pointerup', onPointerUpListener);\n        return () => {\n          textarea.removeEventListener('pointerdown', onPointerDownListener);\n          document.removeEventListener('pointerup', onPointerUpListener);\n        };\n      }, []);\n\n      return (\n        <TextArea\n          ref={mergeRefs('withSelectionBlocker', ref, innerRef)}\n          {...restProps}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelectionBlocker;\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {getMarkerSelections} from './withSelectionBlocker';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n};\n\nconst getMarkerRawValue = (textareaValue, marker) =>\n  textareaValue.substring(marker.start, marker.end);\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  anchor,\n  type,\n  start,\n  end,\n  markerData = {},\n  data,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  anchor,\n  type,\n  start,\n  end,\n  markerData,\n  data,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if ((i === 0 || spaces[value[i - 1]]) && anchors[value[i]]) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const markerData = {};\n\n    const parts = anchor.parts;\n    for (let j = 0; j < parts.length; j++) {\n      const {key, startChar, endChars} = parts[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      markerData[key] = value.substring(partStart, i);\n      if (i >= value.length || endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n      if (endChars[value[i]] === CURRENT_END) {\n        i++;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      markerData,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser =\n  (parseMarkers, options) => (value, markerOffset, oldFirstMarker) => {\n    const markers = parseMarkers(value, options).map((marker, i) => {\n      const updatedMarker = createMarker({\n        isLocked: false,\n        ...(i === 0 && marker.start === 0 ? oldFirstMarker : {}),\n        ...marker,\n        uuid:\n          i === 0 && marker.start === 0 && oldFirstMarker\n            ? oldFirstMarker.uuid\n            : null,\n        start: marker.start + markerOffset,\n        end: marker.end + markerOffset,\n        value,\n      });\n      return updatedMarker;\n    });\n    return [value, markers];\n  };\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  let lengthChange = newValue.length - prevValue.length;\n  let inEditMarkerIndex = -1;\n\n  let newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    inEditMarkerIndex = midSelectedMarkerIndex;\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end: selectionEnd,\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n      lengthChange = insertedText.length;\n      newValue =\n        prevValue.substring(0, selectionStart) +\n        insertedText +\n        prevValue.substring(selectionEnd);\n    }\n    newMarkers.push(\n      ...markers.slice(midSelectedMarkerIndex + 1).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }))\n    );\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      inEditMarkerIndex = markerWithEndTouchedIndex;\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex + 1));\n    } else if (endSelectedMarkerIndex >= 0) {\n      inEditMarkerIndex = endSelectedMarkerIndex;\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n      if (!endSelectedMarker.isLocked) {\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart,\n        });\n      } else {\n        selectionStart = selectionEnd = endSelectedMarker.end;\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex + 1));\n        lengthChange = insertedText.length;\n        newValue =\n          prevValue.substring(0, selectionStart) +\n          insertedText +\n          prevValue.substring(selectionEnd);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker && !inEditMarker.isLocked) {\n    const startParse = inEditMarker.start;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(\n      toParse,\n      startParse,\n      inEditMarker // will just update him and should be returned as first element\n    );\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    newMarkers = [\n      ...newMarkers.slice(0, inEditMarkerIndex),\n      ...parsedMarkers,\n      ...newMarkers.slice(inEditMarkerIndex + 1),\n    ];\n  } else {\n    const startParse =\n      prevMarkerIndex >= 0 ? newMarkers[prevMarkerIndex].end : 0;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(toParse, startParse);\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    const nextNewMarkers = [];\n    if (prevMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(0, prevMarkerIndex + 1));\n    }\n    nextNewMarkers.push(...parsedMarkers);\n    if (nextMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(nextMarkerIndex));\n    }\n    newMarkers = nextNewMarkers;\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst getIneditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\n\nconst withMarkerParser = ({\n  markerParser = parseMarkers,\n  markerParserOptions = {\n    version: 0,\n    anchors: [\n      {\n        anchorChar: '@',\n        type: 'person',\n        parts: [\n          {\n            key: 'username',\n          },\n        ],\n      },\n      {\n        anchorChar: '#',\n        type: 'rfi',\n        parts: [\n          {\n            key: 'rifId',\n          },\n        ],\n      },\n    ],\n  },\n} = {}) => {\n  if (markerParser === parseMarkers) {\n    const anchors = {};\n    markerParserOptions.anchors.forEach(anchor => {\n      const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n        key,\n        startChar,\n        endChars: {\n          ...(endChar ? {[endChar]: CURRENT_END} : spaces),\n          ...(parts[i + 1]?.startChar\n            ? {\n                [parts[i + 1].startChar]: NEXT_START,\n              }\n            : null),\n        },\n      }));\n      anchors[anchor.anchorChar] = {\n        ...anchor,\n        parts,\n      };\n    });\n    markerParserOptions = {...markerParserOptions, anchors};\n  }\n\n  markerParser = wrapMarkerParser(markerParser, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onSelectionChange: onSelectionChangeFromParent,\n          onMarkersChange,\n          onInEditMarkerChange,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers: (initMarkers ?? []).map(marker =>\n            createMarker({\n              ...marker,\n              isLocked: true,\n            })\n          ),\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const updateMarker = (marker, update) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const updateFunction = update => {\n                if (!update && update !== null) {\n                  return marker;\n                }\n\n                let newValue;\n                let newMarkers;\n                let newMarker = null;\n\n                if (update) {\n                  const {textValue, ...markerUpdates} = update;\n                  const hasNewText = textValue != null;\n                  const lengthChange = hasNewText\n                    ? textValue.length - (marker.end - marker.start)\n                    : 0;\n\n                  newMarkers = [...markers.slice(0, i)];\n                  newMarker = {\n                    ...marker,\n                    end: hasNewText\n                      ? marker.start + textValue.length\n                      : marker.end,\n                    ...markerUpdates,\n                  };\n                  newMarkers.push(newMarker);\n                  if (lengthChange) {\n                    newMarkers.push(\n                      ...markers.slice(i + 1).map(marker => ({\n                        ...marker,\n                        start: marker.start + lengthChange,\n                        end: marker.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newMarkers.push(...markers.slice(i + 1));\n                  }\n\n                  newValue = value;\n                  if (hasNewText) {\n                    newValue = [\n                      value.substring(0, marker.start),\n                      textValue,\n                      value.substring(marker.end),\n                    ].join('');\n\n                    setValue(newValue);\n                  }\n                  setMarkers(newMarkers);\n                } else {\n                  const {start: selectionStart, end: selectionEnd} = marker;\n                  const lengthChange = selectionEnd - selectionStart;\n\n                  newValue =\n                    value.substring(0, marker.start) +\n                    value.substring(marker.end);\n\n                  newMarkers = [\n                    ...markers.slice(0, i),\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      start: marker.start - lengthChange,\n                      end: marker.end - lengthChange,\n                    })),\n                  ];\n\n                  setValue(newValue);\n                  setMarkers(newMarkers);\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                    inEditMarker: mutableRef.current.inEditMarker,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update(marker));\n              }\n              return updateFunction(update);\n            };\n            return {\n              updateMarker: (marker, update) =>\n                updateMarker(marker, marker => {\n                  if (typeof update === 'function') {\n                    update = update(marker);\n                  }\n                  if (update) {\n                    let isLocked;\n                    if (marker.isLocked) {\n                      isLocked = true;\n                      if (update.isLocked === false) {\n                        console.warn(\n                          'cannot unloack a locked marker. Will keep it locked!'\n                        );\n                      }\n                    } else {\n                      isLocked = update.isLocked ?? false;\n                    }\n                    return {\n                      isLocked,\n                      textValue: update.textValue,\n                      data:\n                        update.data === undefined ? marker.data : update.data,\n                      markerData: update.markerData ?? marker.markerData,\n                    };\n                  }\n                  return update;\n                }),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          let selection = mutableRef.current.selection;\n\n          const blockResult = blockMarkerUpdates({\n            selection,\n            lastKey: mutableRef.current.lastKeyDown,\n          });\n\n          if (blockResult.block) {\n            textarea.value = prevValue;\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            e.preventDefault();\n            return false;\n          }\n\n          let {selectionStart, selectionEnd} = selection;\n\n          let insertedText = '';\n\n          const hadRangeSelection = selectionStart !== selectionEnd;\n          const isSingleDelete =\n            !hadRangeSelection && mutableRef.current.lastKeyDown === 'Delete';\n          const isSingleBackspace =\n            !hadRangeSelection &&\n            mutableRef.current.lastKeyDown === 'Backspace';\n          if (isSingleDelete || isSingleBackspace) {\n            const deletedCount = prevValue.length - newValue.length;\n            if (isSingleDelete) {\n              selectionEnd = selectionStart + deletedCount;\n            } else {\n              selectionStart -= deletedCount;\n            }\n            const newSelection = getMarkerSelections({\n              markers,\n              selectionStart,\n              selectionEnd,\n            });\n            selection = {\n              selectionStart,\n              selectionEnd,\n              inEditMarkerIndex: getIneditMarkerIndex(newSelection),\n              ...newSelection,\n            };\n          } else {\n            insertedText = newValue.substring(\n              selectionStart,\n              textarea.selectionEnd\n            );\n          }\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {newValue: parsedValue, newMarkers: parsedMarkers} = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          if (parsedValue !== newValue) {\n            console.error(\n              `OOPS! input tracking is broken. Expected \"${newValue}\" got \"${parsedValue}\"`\n            );\n          }\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const oldInEditMarkerIndex = selection.inEditMarkerIndex;\n\n          const newCursorPosition = textarea.selectionEnd; // might need to be refined!!!\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          const newInEditMarkerIndex = getIneditMarkerIndex(selection);\n          selection.inEditMarkerIndex = newInEditMarkerIndex;\n\n          mutableRef.current.selection = selection;\n\n          const oldInEditMarker = markers[oldInEditMarkerIndex];\n          const newInEditMarker = parsedMarkers[newInEditMarkerIndex];\n          if (\n            onInEditMarkerChange &&\n            (newInEditMarker?.uuid !== oldInEditMarker?.uuid ||\n              (newInEditMarker &&\n                getMarkerRawValue(parsedValue, newInEditMarker) !==\n                  getMarkerRawValue(prevValue, oldInEditMarker)))\n          ) {\n            onInEditMarkerChange({\n              target: textarea,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n              inEditMarker: newInEditMarker,\n              oldInEditMarker: mutableRef.current.inEditMarker,\n            });\n          }\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n              inEditMarker: newInEditMarker,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n              inEditMarker: mutableRef.current.inEditMarker,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onKeyDown = e => {\n            mutableRef.current.lastKeyDown = e.key;\n          };\n          textarea.addEventListener('keydown', onKeyDown);\n          return () => {\n            textarea.removeEventListener('keydown', onKeyDown);\n          };\n        }, []);\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        const onSelectionChange = e => {\n          const newInEditMarkerIndex = getIneditMarkerIndex(e);\n          const newInEditMarker = markers[newInEditMarkerIndex];\n          if (newInEditMarker?.uuid !== mutableRef.current.inEditMarker?.uuid) {\n            const onInEditMarkerChangeEventArgs = {\n              target: e.target,\n              value,\n              oldValue: value,\n              markers,\n              oldMarkers: markers,\n              oldInEditMarker: mutableRef.current.inEditMarker,\n              inEditMarker: newInEditMarker,\n            };\n            mutableRef.current.inEditMarker = newInEditMarker;\n            onInEditMarkerChange &&\n              onInEditMarkerChange(onInEditMarkerChangeEventArgs);\n          }\n          mutableRef.current.selection = {\n            ...e,\n            inEditMarkerIndex: newInEditMarkerIndex,\n          };\n          onSelectionChangeFromParent &&\n            onSelectionChangeFromParent(mutableRef.current.selection);\n        };\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs('withMarkerParser', ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n            onSelectionChange={onSelectionChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const pointerEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('pointerOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: false,\n        type,\n      });\n    }\n  };\n  const pointerLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('pointerOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = ({start, delta} = {}) => {\n    delta = delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else {\n      markersHandlers.focus(marker.end + delta);\n    }\n  };\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onPointerEnter={() => pointerEnter(i)}\n        onPointerLeave={pointerLeave}\n        onPointerDown={focus}\n        onPointerUp={focus}\n        onClick={focus}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onPointerEnter: () => pointerEnter(i),\n              onPointerLeave: pointerLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({marker})}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultLineHeight = '135%',\n  defaultBackgroundColor = 'white',\n  classNameGetters = defaultClassNameGetters,\n} = {}) => {\n  classNameGetters = {...defaultClassNameGetters, ...classNameGetters};\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          lineHeight = defaultLineHeight,\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.inEditMarker;\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div id={id} className=\"textarea-container\" style={{backgroundColor}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              style={{\n                ...restProps.style,\n                lineHeight: restProps.style?.lineHeight ?? lineHeight,\n              }}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div className=\"textarea-with-resize-container\">\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visibile, labelLineIndex}) => {\n            const markerUuid = marker?.uuid || marker;\n            if (!visibile && !markerUuid) {\n              if (!type) {\n                setVisibleTipsSettings({\n                  data: {},\n                  dataStack: {},\n                });\n                return;\n              }\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  newTipsDataStack[markerUuid] = newTipsDataStack[\n                    markerUuid\n                    // eslint-disable-next-line no-loop-func\n                  ].filter(({type: currType}) => currType !== type);\n                  if (newTipsDataStack[markerUuid].length) {\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              if (!visibile) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (oldDataStack) {\n                  if (type) {\n                    const newDataStack = oldDataStack.filter(\n                      ({type: currType}) => type !== currType\n                    );\n\n                    if (newDataStack.length) {\n                      const lastTipData = newDataStack[newDataStack.length - 1];\n                      return {\n                        data: {\n                          ...tipsData,\n                          [markerUuid]: {\n                            type: lastTipData.type,\n                            labelLineIndex: lastTipData.labelLineIndex,\n                            focus: tipsData[markerUuid].focus,\n                          },\n                        },\n                        dataStack: {\n                          ...tipsDataStack,\n                          [markerUuid]: newDataStack,\n                        },\n                      };\n                    }\n                  }\n\n                  const newTipsData = {...tipsData};\n                  delete newTipsData[markerUuid];\n\n                  const newDataStack = {...tipsDataStack};\n                  delete newDataStack[markerUuid];\n\n                  return {\n                    data: newTipsData,\n                    dataStack: newDataStack,\n                  };\n                }\n\n                return visibleTipsSettings;\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {inEditMarker, oldInEditMarker} = e;\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visibile: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker) {\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visibile: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst BaseTextArea = React.forwardRef(\n  ({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <textarea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  }\n);\n\nexport default BaseTextArea;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visibile: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visibile: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={e => {\n            mutableRef.current.inEditMarker = e.inEditMarker;\n            onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n          }}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const listener = e => {\n        let elem = e.target;\n        let inMe = false;\n        while (elem) {\n          if (\n            elem.id === id ||\n            elem.dataset?.tipForTextarea === id ||\n            elem.dataset?.tipAnchorForTextarea === id\n          ) {\n            inMe = true;\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!inMe) {\n          mutable.updateTipVisibility({\n            visibile: false,\n          });\n          e.preventDefault();\n        } else {\n          mutable.updateTipVisibility({\n            visibile: false,\n            type: 'clickOnTip',\n          });\n          const markerUuid =\n            elem.dataset?.tipForMarker || elem.dataset?.tipAnchorForMarker;\n          if (markerUuid) {\n            mutable.updateTipVisibility({\n              marker: markerUuid,\n              visibile: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', listener);\n      return () => document.removeEventListener('click', listener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import {useRef} from 'react';\n\nconst usePrev = value => {\n  const ref = useRef(undefined);\n  const preValue = ref.current;\n  ref.current = value;\n  return preValue;\n};\n\nexport default usePrev;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport AbortController from 'abort-controller';\n\nimport withMarkerParser from './withMarkerParser';\nimport withMarkableTextArea from './withMarkableTextArea';\nimport withResize from './withResize';\nimport withSelectionChange from './withSelectionChange';\nimport withMarkerSelectionBlocker from './withSelectionBlocker';\nimport withTips from './withTips';\n\nimport BaseTextArea from '../components/BaseTextArea';\nimport useDebounceValue from '../hooks/useDebounceValue';\nimport withFocusTipOnDown from './withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from './withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport usePrev from '../hooks/usePrev';\nimport withBlockUndoRedoAndDragDropText from './withBlockUndoRedoAndDragDropText';\n\nconst getDetailComponent = ({\n  Component,\n  NotFoundComponent,\n  loader,\n  preProcessMarkerData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n}) => {\n  const cache = getCache();\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  return ({marker, updateMarker}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error}, setResult] = useState({});\n\n    const {data, markerData} = marker;\n    const loadData = preProcessMarkerData(markerData);\n    const cacheKey = getCacheKey(loadData);\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.updateMarker = updateMarker;\n    mutableRef.current.cacheKey = cacheKey;\n\n    useEffect(() => {\n      if (data || data === null) {\n        return null;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.updateMarker({\n          data: cachedData,\n        });\n        setResult({});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResult({loading: true});\n      loader(mutableRef.current.loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.updateMarker({\n              data: result,\n            });\n            setResult({});\n          }\n        })\n        .catch(error => {\n          if (error.aborted) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResult({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, data]);\n\n    if (loading) {\n      return <LoaderComponent loadData={loadData} />;\n    }\n\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          marker={marker}\n          updateMarker={updateMarker}\n        />\n      );\n    }\n\n    if (data) {\n      return (\n        <Component data={data} marker={marker} updateMarker={updateMarker} />\n      );\n    }\n\n    return null;\n  };\n};\n\nconst modulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nconst getSearchResultPickerComponent = ({\n  ItemComponent,\n  NoItemsComponent = () => 'No matching entries found',\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    updateMarker,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        selectedItem: data,\n        marker,\n      });\n      updateMarker({\n        data,\n        ...update,\n        isLocked: update.isLocked ?? true,\n      });\n      setTimeout(() => onHide());\n    };\n\n    const focused =\n      focusedIndex == null ? null : modulo(focusedIndex, results.length);\n    const toFocus = usePrev(focused) !== focused ? focused : null;\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n        }\n      }\n    };\n\n    if (!results.length) {\n      return <NoItemsComponent marker={marker} />;\n    }\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={\n                toFocus === i\n                  ? elem => {\n                      if (elem?.focus) {\n                        elem.focus();\n                      }\n                    }\n                  : null\n              }\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent item={item} />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nconst getSingleTip = ({\n  tipOptions: {\n    search: {\n      ResultsComponent: SearchResultsComponent,\n      ResultItemComponent: SearchResultsItemComponent,\n      resultItemComponentOnSelect,\n      NoResultItemComponent,\n      loader: searchFunction,\n      preProcessMarkerData: preProcessMarkerDataForSearch = markerData =>\n        markerData,\n      getCacheKey: getSearchCacheKey = searchData => JSON.stringify(searchData),\n      LoaderComponent: SearchLoaderComponent,\n      ErrorComponent: SearchErrorComponent,\n      debounceDuration = 350,\n    },\n    details: {\n      Component: DetailComponent,\n      loader: loadSingleFunction,\n      NotFoundComponent: DetailNotFoundComponent,\n      preProcessMarkerData: preProcessMarkerDataForSingleLoad = markerData =>\n        markerData,\n      getCacheKey: getDetailsCacheKey = searchData =>\n        JSON.stringify(searchData),\n      LoaderComponent: DetailLoaderComponent,\n      ErrorComponent: DetailErrorComponent,\n    },\n  },\n  LoaderComponent: CommonLoaderComponent,\n  ErrorComponent: CommonErrorComponent,\n  getCache,\n}) => {\n  DetailComponent = getDetailComponent({\n    Component: DetailComponent,\n    NotFoundComponent: DetailNotFoundComponent,\n    loader: loadSingleFunction,\n    getCacheKey: getDetailsCacheKey,\n    preProcessMarkerData: preProcessMarkerDataForSingleLoad,\n    LoaderComponent: DetailLoaderComponent || CommonLoaderComponent,\n    ErrorComponent: DetailErrorComponent || CommonErrorComponent,\n    getCache,\n  });\n\n  SearchResultsComponent = SearchResultsItemComponent\n    ? getSearchResultPickerComponent({\n        ItemComponent: SearchResultsItemComponent,\n        NoItemsComponent: NoResultItemComponent,\n        ContainerComponent: SearchResultsComponent,\n        onSelect: resultItemComponentOnSelect,\n      })\n    : SearchResultsComponent;\n\n  const cache = getCache();\n\n  const LoaderComponent = SearchLoaderComponent || CommonLoaderComponent;\n  const ErrorComponent = SearchErrorComponent || CommonErrorComponent;\n\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    const {markerData} = marker;\n    const searchData = preProcessMarkerDataForSearch(markerData) ?? null;\n\n    const [{loading, error, results}, setResults] = useState({});\n\n    mutableRef.current.isLocked = marker.isLocked;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.searchData = searchData;\n\n    const cacheKey = useDebounceValue(\n      searchData != null ? getSearchCacheKey(searchData) : null,\n      debounceDuration\n    );\n    useEffect(() => {\n      if (mutableRef.current.isLocked) {\n        setResults({});\n        return null;\n      }\n      mutableRef.current.cacheKey = cacheKey;\n      if (cacheKey === null) {\n        mutableRef.current.onHide();\n        return null;\n      }\n\n      const cachedResults = cache.getItem(cacheKey);\n      if (cachedResults) {\n        setResults({results: cachedResults});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResults({loading: true});\n      searchFunction(mutableRef.current.searchData, abortCtrl.signal)\n        .then(results => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          cache.setItem(cacheKey, results);\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({results});\n          }\n        })\n        .catch(error => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          if (error.aborted) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey]); // , marker.isLocked, onHide, searchData\n\n    if (marker.isLocked) {\n      return (\n        <DetailComponent\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          updateMarker={update => {\n            markersHandlers.updateMarker(marker, update);\n          }}\n        />\n      );\n    }\n\n    if (loading) {\n      return <LoaderComponent loadData={searchData} />;\n    }\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n    if (!results) {\n      return null;\n    }\n    return (\n      <SearchResultsComponent\n        results={results}\n        marker={marker}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        updateMarker={update => {\n          markersHandlers.updateMarker(marker, update);\n        }}\n      />\n    );\n  };\n};\n\nconst getTip = ({\n  tipsOptionsByType,\n  LoaderComponent,\n  ErrorComponent,\n  debounceDuration,\n  getCache,\n}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = getSingleTip({\n      tipOptions: tipsOptionsByType[type],\n      LoaderComponent,\n      ErrorComponent,\n      debounceDuration,\n      getCache,\n    });\n  }\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nconst defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nconst wrapGetCache = getCache => () => {\n  const cache = getCache();\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  debounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  lineHeight,\n}) => {\n  getCache = getCache ? wrapGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = {};\n  const anchors = [];\n  baseAnchors.forEach(anchor => {\n    tipsOptionsByType[anchor.type] = {\n      search: anchor.searchOptions,\n      details: anchor.detailsOptions,\n    };\n    anchors.push({\n      anchorChar: anchor.anchorChar,\n      type: anchor.type,\n      parts: anchor.parts,\n    });\n  });\n  return withId(getId)(\n    withTips({\n      hideOnEscape: hideTipOnEscape,\n      TipComponent: getTip({\n        tipsOptionsByType,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n      }),\n    })(\n      withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n        withFocusTipOnDown(\n          withMarkableTextArea({\n            classNameGetters,\n            defaultBackgroundColor: backgroundColor,\n            defaultLineHeight: lineHeight,\n          })(\n            withResize(\n              withMarkerParser({\n                markerParserOptions: {\n                  version,\n                  anchors,\n                },\n              })(\n                withMarkerSelectionBlocker(\n                  withSelectionChange(\n                    withBlockUndoRedoAndDragDropText(BaseTextArea)\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({updateMarker}) => {\n  const [countDown, setCountDown] = useState(4);\n  const updateMarkerRef = useRef();\n  updateMarkerRef.current = updateMarker;\n  useEffect(() => {\n    const t = setInterval(() => {\n      setCountDown(countDown => countDown - 1);\n    }, 1000);\n    return () => clearInterval(t);\n  }, []);\n  const done = countDown === 0;\n  useEffect(() => {\n    if (done) {\n      updateMarkerRef.current(null);\n    }\n  }, [done]);\n  return <b>Person not found! will delete in {countDown}</b>;\n};\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  anchors: [\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultItemComponent: PersonSearchResultItem,\n        NoResultItemComponent: () => 'No matching people found',\n        resultItemComponentOnSelect: ({selectedItem: person}) => ({\n          textValue: person.name,\n          markerData: {\n            id: person.id,\n          },\n        }),\n        loader: ({name}, signal) => personSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: PersonDetails,\n        NotFoundComponent: NotFoundPersonComponent,\n        loader: ({id}, signal) => personDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultsComponent: ({ResultListComponent, ...props}) => (\n          <p>\n            <h5>Found the following things:</h5>\n            <ResultListComponent {...props} />\n          </p>\n        ),\n        ResultItemComponent: ThingSearchResultItem,\n        resultItemComponentOnSelect: ({selectedItem: thing}) => ({\n          textValue: thing.name,\n          markerData: {\n            id: thing.id,\n          },\n        }),\n        loader: ({name}, signal) => thingSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: ThingDetails,\n        loader: ({id}, signal) => thingDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useState} from 'react';\nimport classes from './App.module.css';\nimport SmartTextArea, {people, things} from './SmartTextArea';\n\nconst availablePpl = people.map(person => person.name).join(', ');\nconst availableThings = things.map(thing => thing.name).join(', ');\nconst App = () => {\n  const [markers, setMarkers] = useState([]);\n  const [inEditMarker, setInEditMarker] = useState([]);\n  return (\n    <div className={classes.container}>\n      <ul>\n        <li>\n          use @ to trigger person marker start. Available people to search:\n          <ul>\n            <li>{availablePpl}</li>\n          </ul>\n          people marker color is the default gray color\n        </li>\n        <li>\n          use # to trigger things marker start. Available things to search:\n          <ul>\n            <li>{availableThings}</li>\n          </ul>\n          things marker color is a custom orange color\n        </li>\n      </ul>\n      <SmartTextArea\n        className=\"smart-text-area\"\n        initValue={\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\n        }\n        initMarkers={[\n          {start: 0, end: 13, type: 'person', markerData: {id: 'mo'}},\n          {start: 46, end: 54, type: 'person', markerData: {id: 'john'}},\n          {start: 78, end: 86, type: 'person', markerData: {id: 'jane'}},\n          {start: 112, end: 117, type: 'person', markerData: {id: 'asdfg'}},\n          {start: 149, end: 153, type: 'thing', markerData: {id: 'fork'}},\n          {start: 155, end: 160, type: 'thing', markerData: {id: 'knife'}},\n          {start: 165, end: 170, type: 'thing', markerData: {id: 'spoon'}},\n        ]}\n        onMarkersChange={e => {\n          setMarkers(e.markers);\n        }}\n        onInEditMarkerChange={e => {\n          setInEditMarker(e.inEditMarker);\n        }}\n      />\n      <p>\n        <h5>Markers:</h5>\n        <pre>\n          {markers.map(marker => (\n            <div\n              className={\n                marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\n              }>\n              {JSON.stringify(marker, null, 3)}\n            </div>\n          ))}\n        </pre>\n      </p>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}