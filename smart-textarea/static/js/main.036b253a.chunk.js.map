{"version":3,"sources":["lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/hocs/withMarkerSelection.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withBaseTextArea.js","lib/hocs/withSmartTextArea/helpers/fortifyGetCache..js","lib/hocs/withSmartTextArea/helpers/defaultGetCache.js","lib/helpers/mapAndKeyBy.js","lib/helpers/searchArray.js","lib/hocs/withSmartTextArea/helpers/ensureLoaderIsAsync.js","lib/hocs/withSmartTextArea/hocs/withId.js","lib/hocs/withSmartTextArea/hocs/withStyle.js","lib/hocs/withSmartTextArea/builders/hook/buildDetailsDataLoaderHook.js","lib/hocs/withSmartTextArea/builders/component/buildDetailsComponent.js","lib/hooks/useDebounceValue.js","lib/hocs/withSmartTextArea/builders/hook/buildSearchDataLoaderHook.js","lib/hocs/withSmartTextArea/builders/hook/buildAutoSelectHook.js","lib/hocs/withSmartTextArea/builders/component/buildSearchComponent.js","lib/helpers/negativeSupportingModulo.js","lib/hocs/withSmartTextArea/builders/component/buildSearchResultsPickerComponent.js","lib/hocs/withSmartTextArea/builders/component/buildMarkerTipComponent.js","lib/hocs/withSmartTextArea/builders/component/buildTipComponent.js","lib/hocs/withSmartTextArea/index.js","lib/hocs/withSmartTextArea/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","withInEditMarkerIndex","selection","inEditMarkerIndex","midSelectedMarkerIndex","endSelectedMarkerIndex","markerWithEndTouchedIndex","getInEditMarkerIndex","getSelections","prevIndex","nextIndex","partsOrMarkers","selectionStart","selectionEnd","selectedRange","startIndex","endIndex","startSelectedIndex","endSelectedIndex","midSelectedIndex","startTouchedIndex","endTouchedIndex","getReturn","end","part","start","startTotallySelected","endTotallySelected","totalySelected","getMarkerSelections","markers","selectedMarkersRange","startSelectedMarkerIndex","markerWithStartTouchedIndex","prevMarkerIndex","nextMarkerIndex","getMarkerPartsSelections","marker","parts","selectedPartRange","startSelectedPartIndex","endSelectedPartIndex","midSelectedPartIndex","partWithStartTouchedIndex","partWithEndTouchedIndex","prevPartIndex","nextPartIndex","anchorIndex","anchorSelected","markerUuid","uuid","fixPartSelections","isSingleSelection","startCursorMoved","endCursorMoved","lastResolvedPartIndex","midSelectedPart","isLocked","lastResolvedPart","endSelectedPart","Math","max","min","fixMarkerSelections","midSelectedMarker","endSelectedMarker","newSelections","startSelectedMarker","withMarkerSelection","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","onInEditMarkerChange","restProps","innerRef","e","textarea","target","prevSelection","newSelectionStart","newSelectionEnd","newSelection","oldInEditMarkerIndex","blockPartUpdates","block","blockMarkerUpdates","partBlock","DEFAULT_END","newLines","spaces","createMarker","version","anchor","type","partsConfig","partsText","partsIds","partsData","round","random","Date","now","parseMarkers","options","considerFirst","anchors","j","partStart","partStartChar","key","startChar","endChars","partTextStart","partTextEnd","substring","isPartEnd","partEndChar","partEnd","push","endChar","anchorChar","wrapMarkerParser","markerOffset","map","prevValue","insertedText","markerParser","newMarkers","slice","updateMarkerParts","markerWithEndTouched","lengthChange","nextMarkers","newValue","inEditMarker","startParse","endParse","lastPossibleEndParse","newlyParsedInEditMarker","newParsedMarkers","oldInEditMarkerParts","oldInEditMarkerpartsIds","oldInEditMarkerPartsData","newInEditMarkerParts","oldPart","newPart","shouldLockPart","Boolean","newInEditMarker","splice","prevEnd","parsedMarkers","preProcessMarkerParserOptions","markerParserOptions","types","forEach","anchorConfig","getPartDelimitedText","partConfig","text","getPartTextLengthChange","initMarker","isMarkerLocked","undefined","withMarkerParser","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","disabled","imperativeRef","props","filter","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","deleteMarker","setCursor","findIndex","m","oldValue","oldMarkers","unmarkMarker","updateMarkerPart","partKey","partIndex","updateFunction","cursor","data","id","isLastPossiblePart","isLastPart","nextPartConfig","appendText","hasNewText","newParts","newMarker","join","childImperativeRef","useEffect","prevSelectionEnd","minSelectionEnd","blockResult","blockTimer","clearTimeout","setTimeout","err","preventDefault","parsedValue","newCursorPosition","properties","getCoordinatesAtPositions","positions","debug","el","document","querySelector","parentNode","removeChild","div","createElement","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","tipsZIndex","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","mouseEnter","timer","visible","showTip","hideTip","mouseLeave","focus","whereToFocus","delta","focusEnd","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onMouseEnter","onMouseLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","zIndex","constraints","to","renderTarget","renderElement","focusParent","onHide","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultBackgroundColor","baseClassNameGetters","classNameGetters","params","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","addEventListener","onKeyUpListener","removeEventListener","SKIP_HIDE","DEFAULT_HIDE","TOGGLE_VISIBLITY","withHideTipOnEscape","listener","wrapHideAction","baseHideAction","visiblityStack","requestedHideType","hideOrNewVisiblityStack","Array","isArray","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","hideAction","find","oldDataStack","newCurrMarkerDataStack","lastTipData","newTipsData","newDataStack","newTipsDataStack","oldInEditMarker","withFocusTipOnDown","tipData","stopPropagation","prevInEditMarker","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","clickListener","onTextArea","onTip","onMarker","dataset","tipForTextarea","tipAnchorForTextarea","anchorMarkerUuid","tipAnchorForMarker","tipForMarker","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","withBaseTextArea","React","fortifyGetCache","getCache","cache","getItem","cacheKey","error","setItem","defaultGetCache","mapAndKeyBy","array","mapFunction","keyFunction","item","keyed","searchArray","searchText","searchTextLowerCased","toLowerCase","includes","val","doesItemMatchSearch","ensureLoaderIsAsync","loader","ret","Promise","resolve","then","withId","getId","withStyle","defaultLineHeight","defaultWidth","buildDetailsDataLoaderHook","getLoadData","getCacheKey","loadData","shouldReloadData","isAbortError","currPartKey","loading","retry","setResultData","retryFunction","resultData","cachedData","abortCtrl","AbortController","signal","result","catch","abort","buildDetailsComponent","markerType","Component","NotFoundComponent","LoaderComponent","ErrorComponent","useDetailDataLoader","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","buildSearchDataLoaderHook","getSearchData","searchData","filterResults","debounceDuration","debouncedCacheKey","noSearch","results","resultsCacheKey","setResultsData","isResultForCurrentSearch","resultsData","cachedResults","buildAutoSelectHook","autoSelect","Error","hide","buildSearchComponent","detailsComponents","ZeroSearchResultsComponent","NoSearchComponent","ResultsComponent","useSearchDataLoader","useAutoSelect","negativeSupportingModulo","num","mod","buildSearchResultsPickerComponent","ItemComponent","ContainerComponent","ResultListComponent","onSelect","focusedIndex","setFocusedIndex","index","select","selectedItem","focused","focusedRef","getAttribute","removeAttribute","onKeyDown","next","tabIndex","buildMarkerTipComponent","tipOptions","details","searchComponents","search","ResultItemComponent","onItemSelect","baseAutoSelect","lastPartConfig","DetailsComponent","firstUnresolvedPartIndex","firstUnresolvedPartConfig","SearchComponent","buildTipComponent","tipsOptionsByType","ComponentsByType","withSmartTextArea","baseAnchors","hideTipOnEscape","aborted","message","anchorGetCache","anchorLoaderComponent","anchorErrorComponent","anchorDebounceDuration","searchLoader","detailsLoader","searchConfig","detailsConfig","searchOptions","detailsOptions","filterData","bind","searchFunction","findInSearchData","loadDetails","loadDetail","DisplayComponent","DetailComponent","PersonDetails","person","src","imageUrl","alt","PersonSearchResultItem","name","people","personSearch","reject","trim","toLocaleLowerCase","personDetails","ThingDetails","thing","ThingSearchResultItem","things","thingSearch","thingDetails","NotFoundPersonComponent","capitalize","str","substr","toUpperCase","SmartTextArea","defaultClassName","NoResultItemComponent","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.036b253a.chunk.js","sourcesContent":["const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","import React, {forwardRef, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst getInEditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\nconst withInEditMarkerIndex = selection => {\n  const inEditMarkerIndex = getInEditMarkerIndex(selection);\n  selection.inEditMarkerIndex = inEditMarkerIndex;\n  return selection;\n};\n\nexport const getSelections = ({\n  partsOrMarkers,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const selectedRange = {startIndex: -1, endIndex: -1};\n  let startSelectedIndex = -1;\n  let endSelectedIndex = -1;\n  let midSelectedIndex = -1;\n  let startTouchedIndex = -1;\n  let endTouchedIndex = -1;\n  let prevIndex;\n  let nextIndex;\n  let i = 0;\n\n  const getReturn = () => ({\n    selectedRange,\n    startSelectedIndex,\n    endSelectedIndex,\n    midSelectedIndex,\n    startTouchedIndex,\n    endTouchedIndex,\n    prevIndex,\n    nextIndex:\n      (nextIndex ?? -1) >= partsOrMarkers.length ? -1 : nextIndex ?? -1,\n  });\n\n  for (\n    ;\n    i < partsOrMarkers.length && partsOrMarkers[i].end < selectionStart;\n    i++\n  );\n\n  prevIndex = i - 1;\n\n  let part = partsOrMarkers[i];\n  if (!part) {\n    return getReturn();\n  }\n\n  if (part.end === selectionStart) {\n    endTouchedIndex = prevIndex = i;\n    i++;\n    part = partsOrMarkers[i];\n    if (!part) {\n      return getReturn();\n    }\n  }\n\n  if (part.start >= selectionEnd) {\n    nextIndex = i;\n    if (part.start === selectionEnd) {\n      startTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected =\n    selectionStart <= part.start && part.start < selectionEnd;\n  let endTotallySelected =\n    selectionStart < part.end && part.end <= selectionEnd;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedIndex = i;\n    nextIndex = i + 1;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedIndex = i;\n      nextIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedIndex = i;\n    i++;\n    part = partsOrMarkers[i];\n    if (!part) {\n      return getReturn();\n    }\n\n    startTotallySelected =\n      selectionStart <= part.start && part.start < selectionEnd;\n    endTotallySelected = selectionStart < part.end && part.end <= selectionEnd;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextIndex = i + 1;\n        startSelectedIndex = i;\n      } else {\n        nextIndex = i;\n        if (part.start === selectionEnd) {\n          startTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedRange.startIndex = i;\n\n  i++;\n  for (; i < partsOrMarkers.length; i++) {\n    part = partsOrMarkers[i];\n\n    startTotallySelected =\n      selectionStart <= part.start && part.start < selectionEnd;\n    endTotallySelected = selectionStart < part.end && part.end <= selectionEnd;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextIndex = i + 1;\n        startSelectedIndex = i;\n      } else {\n        nextIndex = i;\n        if (part.start === selectionEnd) {\n          startTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedRange.endIndex = i;\n  return getReturn();\n};\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const {\n    selectedRange: selectedMarkersRange,\n    startSelectedIndex: startSelectedMarkerIndex,\n    endSelectedIndex: endSelectedMarkerIndex,\n    midSelectedIndex: midSelectedMarkerIndex,\n    startTouchedIndex: markerWithStartTouchedIndex,\n    endTouchedIndex: markerWithEndTouchedIndex,\n    prevIndex: prevMarkerIndex,\n    nextIndex: nextMarkerIndex,\n  } = getSelections({\n    partsOrMarkers: markers,\n    selectionStart,\n    selectionEnd,\n  });\n  return withInEditMarkerIndex({\n    markers,\n    selectedMarkersRange,\n    startSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    midSelectedMarkerIndex,\n    markerWithStartTouchedIndex,\n    markerWithEndTouchedIndex,\n    prevMarkerIndex,\n    nextMarkerIndex,\n  });\n};\n\nexport const getMarkerPartsSelections = ({\n  marker,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const parts = marker.parts;\n\n  const {\n    selectedRange: selectedPartRange,\n    startSelectedIndex: startSelectedPartIndex,\n    endSelectedIndex: endSelectedPartIndex,\n    midSelectedIndex: midSelectedPartIndex,\n    startTouchedIndex: partWithStartTouchedIndex,\n    endTouchedIndex: partWithEndTouchedIndex,\n    prevIndex: prevPartIndex,\n    nextIndex: nextPartIndex,\n  } = getSelections({\n    partsOrMarkers: parts,\n    selectionStart,\n    selectionEnd,\n  });\n\n  const anchorIndex = parts[0].start - 1;\n  const anchorSelected =\n    selectionStart <= anchorIndex && selectionEnd > anchorIndex;\n\n  return {\n    markerUuid: marker.uuid,\n    parts: marker.parts,\n    selectedPartRange,\n    startSelectedPartIndex,\n    endSelectedPartIndex,\n    midSelectedPartIndex,\n    partWithStartTouchedIndex,\n    partWithEndTouchedIndex,\n    prevPartIndex,\n    nextPartIndex,\n    anchorSelected,\n  };\n};\n\nconst fixPartSelections = ({\n  marker,\n  selectionStart,\n  selectionEnd,\n  isSingleSelection,\n  startCursorMoved,\n  endCursorMoved,\n}) => {\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n  const parts = marker.parts;\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      if (isSingleSelection) {\n        if (startCursorMoved < 0) {\n          return {\n            selectionStart: midSelectedPart.start,\n            selectionEnd: midSelectedPart.start,\n          };\n        }\n        return {\n          selectionStart: midSelectedPart.end,\n          selectionEnd: midSelectedPart.end,\n        };\n      }\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart: midSelectedPart.start,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart:\n          startCursorMoved > 0 ? endSelectedPart.end : endSelectedPart.start,\n        selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n      };\n    }\n  }\n\n  if (startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart: Math.min(selectionStart, parts[0].start),\n        selectionEnd:\n          endCursorMoved < 0 ? parts[0].start : lastResolvedPart.end,\n      };\n    }\n  }\n\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    return {\n      selectionStart,\n      selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n    };\n  }\n\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst fixMarkerSelections = ({\n  markers,\n  selectionStart,\n  selectionEnd,\n  isSingleSelection,\n  startCursorMoved,\n  endCursorMoved,\n}) => {\n  const {\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = getMarkerSelections({\n    markers,\n    selectionStart,\n    selectionEnd,\n  });\n\n  if (midSelectedMarkerIndex >= 0) {\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (midSelectedMarker.isLocked) {\n      if (isSingleSelection) {\n        const selection =\n          startCursorMoved < 0\n            ? midSelectedMarker.start\n            : midSelectedMarker.end;\n        return {\n          selectionStart: selection,\n          selectionEnd: selection,\n        };\n      }\n      return {\n        selectionStart: midSelectedMarker.start,\n        selectionEnd: midSelectedMarker.end,\n      };\n    }\n    return fixPartSelections({\n      marker: midSelectedMarker,\n      selectionStart,\n      selectionEnd,\n      isSingleSelection,\n      startCursorMoved,\n      endCursorMoved,\n    });\n  }\n  if (endSelectedMarkerIndex >= 0) {\n    const endSelectedMarker = markers[endSelectedMarkerIndex];\n    if (endSelectedMarker.isLocked) {\n      if (startCursorMoved < 0) {\n        selectionStart = endSelectedMarker.start;\n      } else {\n        selectionStart = endSelectedMarker.end;\n      }\n    } else {\n      const newSelections = fixPartSelections({\n        marker: endSelectedMarker,\n        selectionStart,\n        selectionEnd,\n        isSingleSelection,\n        startCursorMoved,\n        endCursorMoved,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n    }\n  }\n  if (startSelectedMarkerIndex >= 0) {\n    const startSelectedMarker = markers[startSelectedMarkerIndex];\n    if (startSelectedMarker.isLocked) {\n      if (endCursorMoved > 0) {\n        selectionEnd = startSelectedMarker.end;\n      } else {\n        selectionEnd = startSelectedMarker.start;\n      }\n    } else {\n      const newSelections = fixPartSelections({\n        marker: startSelectedMarker,\n        selectionStart,\n        selectionEnd,\n        isSingleSelection,\n        startCursorMoved,\n        endCursorMoved,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n    }\n  }\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst withMarkerSelection = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {\n        onSelectionChange: onSelectionChangeFromParent,\n        value,\n        markers,\n        onInEditMarkerChange,\n        ...restProps\n      },\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.selectionStart === selectionStart\n            ? 0\n            : selectionStart - prevSelection.selectionStart;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.selectionEnd === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.selectionEnd;\n\n        const {\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd,\n        } = fixMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n          isSingleSelection,\n          startCursorMoved,\n          endCursorMoved,\n        });\n\n        if (selectionEnd !== newSelectionEnd) {\n          textarea.selectionEnd = newSelectionEnd;\n        }\n        if (selectionStart !== newSelectionStart) {\n          textarea.selectionStart = newSelectionStart;\n        }\n\n        const newSelection = withInEditMarkerIndex({\n          markers,\n\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd,\n\n          ...getMarkerSelections({\n            markers,\n            selectionStart: newSelectionStart,\n            selectionEnd: newSelectionEnd,\n          }),\n        });\n\n        mutableRef.current.selection = newSelection;\n\n        onInEditMarkerChange &&\n          onInEditMarkerChange({\n            target: textarea,\n            value,\n            markers,\n            inEditMarkerIndex: newSelection.inEditMarkerIndex,\n            oldInEditMarkerIndex: prevSelection?.inEditMarkerIndex,\n          });\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            ...newSelection,\n          });\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          {...restProps}\n          value={value}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelection;\n","import {getMarkerPartsSelections} from 'lib/hocs/withMarkerSelection';\n\nconst blockPartUpdates = ({marker, selectionStart, selectionEnd}) => {\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n    anchorSelected,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n  const parts = marker.parts;\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart: midSelectedPart.start,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart: endSelectedPart.start,\n        selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n      };\n    }\n  }\n\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    return {\n      block: true,\n      selectionStart,\n      selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n    };\n  }\n\n  if (!anchorSelected && startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n\n  return {block: false};\n};\n\nexport const blockMarkerUpdates = selection => {\n  const {\n    markers,\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = selection;\n\n  let {selectionStart, selectionEnd} = selection;\n\n  const midSelectedMarker = markers[midSelectedMarkerIndex];\n  const endSelectedMarker = markers[endSelectedMarkerIndex];\n  const startSelectedMarker = markers[startSelectedMarkerIndex];\n\n  if (midSelectedMarker) {\n    if (midSelectedMarker.isLocked) {\n      return {\n        block: true,\n        selectionStart: midSelectedMarker.start,\n        selectionEnd: midSelectedMarker.end,\n      };\n    }\n    return blockPartUpdates({\n      marker: midSelectedMarker,\n      selectionStart,\n      selectionEnd,\n    });\n  }\n  let block = false;\n  if (endSelectedMarker) {\n    if (endSelectedMarker.isLocked) {\n      block = true;\n      selectionStart = endSelectedMarker.start;\n      selectionEnd = endSelectedMarker.end;\n    } else {\n      const partBlock = blockPartUpdates({\n        marker: endSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      if (partBlock.block) {\n        block = true;\n        selectionStart = partBlock.selectionStart;\n        selectionEnd = partBlock.selectionEnd;\n      }\n    }\n  }\n  if (startSelectedMarker) {\n    if (startSelectedMarker.isLocked) {\n      block = true;\n      selectionStart = startSelectedMarker.start;\n      selectionEnd = startSelectedMarker.end;\n    } else {\n      const partBlock = blockPartUpdates({\n        marker: startSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      if (partBlock.block) {\n        block = true;\n        selectionStart = partBlock.selectionStart;\n        selectionEnd = partBlock.selectionEnd;\n      }\n    }\n  }\n  if (!block) {\n    return {\n      block: false,\n    };\n  }\n  return {\n    block: true,\n    selectionStart,\n    selectionEnd,\n  };\n};\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {\n  getMarkerPartsSelections,\n  getMarkerSelections,\n} from './withMarkerSelection';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst newLines = {\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n};\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n  ...newLines,\n};\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  partsConfig,\n  parts,\n  partsText,\n  partsIds = {},\n  partsData = {},\n  lastResolvedPartIndex = -1,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  partsConfig,\n  parts,\n  partsText,\n  partsIds,\n  partsData,\n  lastResolvedPartIndex,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const considerFirst = options.considerFirst ?? true;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if (\n        ((i === 0 && considerFirst) || spaces[value[i - 1]]) &&\n        anchors[value[i]]\n      ) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const partsText = {};\n    const parts = [];\n    const partsConfig = anchor.parts;\n\n    for (let j = 0; j < partsConfig.length; j++) {\n      const partStart = i;\n      let partStartChar = '';\n      const {key, startChar, endChars} = partsConfig[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          partStartChar = startChar;\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partTextStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      const partTextEnd = i;\n      partsText[key] = value.substring(partTextStart, partTextEnd);\n      const isPartEnd = endChars[value[i]] === CURRENT_END;\n      const partEndChar = isPartEnd ? value[i] : '';\n      if (isPartEnd) {\n        i++;\n      }\n      const partEnd = i;\n      parts.push({\n        key,\n        start: partStart,\n        end: partEnd,\n        startChar: partStartChar,\n        endChar: partEndChar,\n      });\n      if (i >= value.length && !isPartEnd) {\n        break;\n      }\n      if (endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      partsConfig,\n      parts,\n      partsText,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser =\n  (parseMarkers, options) => (value, markerOffset, considerFirst) =>\n    parseMarkers(value, {...options, considerFirst}).map(marker =>\n      createMarker({\n        isLocked: false,\n        partsIds: {},\n        partsData: {},\n        lastResolvedPartIndex: -1,\n        ...marker,\n        parts: marker.parts.map(part => ({\n          isLocked: false,\n          ...part,\n          start: part.start + markerOffset,\n          end: part.end + markerOffset,\n        })),\n        start: marker.start + markerOffset,\n        end: marker.end + markerOffset,\n      })\n    );\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let inEditMarkerIndex = -1;\n\n  const newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      inEditMarkerIndex = midSelectedMarkerIndex;\n\n      const newSelections = updateMarkerParts({\n        marker: midSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end:\n          midSelectedMarker.end +\n          insertedText.length -\n          (selectionEnd - selectionStart),\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n    }\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      const markerWithEndTouched = markers[markerWithEndTouchedIndex];\n\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex));\n\n      if (!markerWithEndTouched.isLocked) {\n        inEditMarkerIndex = markerWithEndTouchedIndex;\n\n        newMarkers.push({\n          ...markerWithEndTouched,\n          end: markerWithEndTouched.end + insertedText.length,\n        });\n      } else {\n        newMarkers.push(markerWithEndTouched);\n      }\n    } else if (endSelectedMarkerIndex >= 0) {\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n\n      newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n\n      if (!endSelectedMarker.isLocked) {\n        inEditMarkerIndex = endSelectedMarkerIndex;\n\n        const newSelections = updateMarkerParts({\n          marker: endSelectedMarker,\n          selectionStart,\n          selectionEnd,\n        });\n        selectionStart = newSelections.selectionStart;\n        selectionEnd = newSelections.selectionEnd;\n\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart + insertedText.length,\n        });\n      } else {\n        selectionStart = endSelectedMarker.end;\n        newMarkers.push(endSelectedMarker);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    const lengthChange = insertedText.length - (selectionEnd - selectionStart);\n\n    // here is where the selected markers whether fully selected or start selected are effectively deleted\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        parts: marker.parts?.map(part => ({\n          ...part,\n          start: part.start + lengthChange,\n          end: part.end + lengthChange,\n        })),\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker) {\n    const startParse = inEditMarker.start;\n    let endParse = inEditMarker.end;\n\n    const lastPossibleEndParse =\n      newMarkers[nextMarkerIndex]?.start ?? newValue.length;\n    for (\n      ;\n      endParse < lastPossibleEndParse && !spaces[newValue[endParse]];\n      endParse++\n    );\n\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [newlyParsedInEditMarker, ...newParsedMarkers] = markerParser(\n      toParse,\n      startParse\n    );\n\n    let lastResolvedPartIndex = -1;\n    const partsIds = {};\n    const partsData = {};\n    const parts = [];\n    const oldInEditMarkerParts = inEditMarker.parts;\n    const oldInEditMarkerpartsIds = inEditMarker.partsIds;\n    const oldInEditMarkerPartsData = inEditMarker.partsData;\n    const newInEditMarkerParts = newlyParsedInEditMarker.parts;\n    for (let i = 0; i < newInEditMarkerParts.length; i++) {\n      const oldPart = oldInEditMarkerParts[i];\n      const newPart = newInEditMarkerParts[i];\n      const key = newPart.key;\n\n      const shouldLockPart = Boolean(\n        oldPart?.isLocked &&\n          newPart.end !== newPart.start &&\n          prevValue.substring(oldPart.start, oldPart.end) ===\n            newValue.substring(newPart.start, newPart.end)\n      );\n      parts.push({\n        ...newPart,\n        isLocked: shouldLockPart,\n      });\n\n      if (shouldLockPart) {\n        lastResolvedPartIndex = i;\n        partsIds[key] = oldInEditMarkerpartsIds[key];\n        partsData[key] = oldInEditMarkerPartsData[key];\n      }\n    }\n\n    const newInEditMarker = {\n      ...newlyParsedInEditMarker,\n      lastResolvedPartIndex,\n      uuid: inEditMarker.uuid,\n      partsIds,\n      partsData,\n      parts,\n    };\n\n    newMarkers.splice(\n      // remove the old inEditMarker and insert in place of it the new one and the newParsedMarkers\n      inEditMarkerIndex,\n      1,\n      newInEditMarker,\n      ...newParsedMarkers\n    );\n  } else {\n    const startParse = selectionStart;\n    let endParse = selectionStart + insertedText.length;\n\n    const prevEnd = newMarkers[prevMarkerIndex]?.end ?? 0;\n    const considerFirst = Boolean(\n      prevEnd === startParse || spaces[newValue[startParse - 1]]\n    );\n\n    const lastPossibleEndParse =\n      newMarkers[nextMarkerIndex]?.start ?? newValue.length;\n    for (\n      ;\n      endParse < lastPossibleEndParse && !spaces[newValue[endParse]];\n      endParse++\n    );\n\n    const toParse = newValue.substring(startParse, endParse);\n\n    const parsedMarkers = markerParser(toParse, startParse, considerFirst);\n\n    newMarkers.splice(\n      prevMarkerIndex + 1, // still correct even when prevMarkerIndex = -1\n      0,\n      ...parsedMarkers\n    );\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst updateMarkerParts = ({marker, selectionStart, selectionEnd}) => {\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  const parts = marker.parts;\n\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = selectionEnd = lastResolvedPart.end;\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = lastResolvedPart.end;\n      selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = lastResolvedPart.end;\n      selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    selectionStart = lastResolvedPart.end;\n    selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst preProcessMarkerParserOptions = markerParserOptions => {\n  const anchors = {};\n  const types = {};\n  markerParserOptions.anchors.forEach(anchor => {\n    const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n      key,\n      startChar: startChar || '',\n      endChar: endChar || '',\n      endChars: {\n        ...(parts[i + 1]?.startChar\n          ? {\n              [parts[i + 1].startChar]: NEXT_START,\n            }\n          : null),\n        ...(endChar ? {[endChar]: CURRENT_END} : null),\n        ...newLines,\n      },\n    }));\n    const anchorConfig = {\n      ...anchor,\n      parts,\n    };\n    types[anchor.type] = anchorConfig;\n    anchors[anchor.anchorChar] = anchorConfig;\n  });\n  return {...markerParserOptions, anchors, types};\n};\n\nconst getPartDelimitedText = (isLocked, part, partConfig, text) =>\n  (isLocked ? partConfig.startChar : part.startChar) +\n  text +\n  (isLocked ? partConfig.endChar : part.endChar);\nconst getPartTextLengthChange = (isLocked, part, partConfig, text) =>\n  (isLocked ? partConfig.startChar : part.startChar).length +\n  text.length +\n  (isLocked ? partConfig.endChar : part.endChar).length -\n  (part.end - part.start);\n\nconst initMarker = (marker, markerParserOptions) => {\n  const anchorConfig =\n    markerParserOptions.types[marker.type] ||\n    markerParserOptions.anchors[marker.anchor];\n  const partsConfig = anchorConfig.parts;\n  let lastResolvedPartIndex;\n  for (let i = 0; i < partsConfig.length; i++) {\n    if (marker.partsIds[partsConfig[i].key]) {\n      lastResolvedPartIndex = i;\n    }\n  }\n  const isMarkerLocked = lastResolvedPartIndex === partsConfig.length - 1;\n  const parts = isMarkerLocked\n    ? undefined\n    : (marker.parts || []).map((part, i) => ({\n        ...part,\n        isLocked: i <= lastResolvedPartIndex,\n      }));\n  const partsText = isMarkerLocked ? undefined : marker.partsText;\n  return createMarker({\n    ...marker,\n    type: anchorConfig.type,\n    anchor: anchorConfig.anchor,\n    parts,\n    partsText,\n    partsConfig,\n    isLocked: isMarkerLocked,\n    lastResolvedPartIndex,\n  });\n};\n\nconst withMarkerParser = ({markerParserOptions} = {}) => {\n  markerParserOptions = preProcessMarkerParserOptions(markerParserOptions);\n  const markerParser = wrapMarkerParser(parseMarkers, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onMarkersChange,\n          disabled,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers:\n            initMarkers\n              ?.filter(\n                ({anchor, type}) =>\n                  markerParserOptions.types[type] ||\n                  markerParserOptions.anchors[anchor]\n              )\n              .map(marker => initMarker(marker, markerParserOptions)) ?? [],\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n        mutableRef.current.disabled = disabled;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const deleteMarker = (marker, setCursor) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return;\n              }\n              marker = markers[i];\n\n              const {start: selectionStart, end: selectionEnd} = marker;\n              const lengthChange = selectionEnd - selectionStart;\n\n              const newValue =\n                value.substring(0, marker.start) + value.substring(marker.end);\n\n              const newMarkers = [\n                ...markers.slice(0, i),\n                ...markers.slice(i + 1).map(marker => ({\n                  ...marker,\n                  start: marker.start - lengthChange,\n                  end: marker.end - lengthChange,\n                  parts: marker.parts?.map(part => ({\n                    ...part,\n                    start: part.start - lengthChange,\n                    end: part.end - lengthChange,\n                  })),\n                })),\n              ];\n\n              setValue(newValue);\n              setMarkers(newMarkers);\n\n              if (setCursor) {\n                const textarea = innerRef.current;\n                innerRef.current.value = newValue;\n                textarea.selectionStart = textarea.selectionEnd = marker.start;\n              }\n\n              onMarkersChange &&\n                onMarkersChange({\n                  target: innerRef.current,\n                  init: false,\n                  value: newValue,\n                  oldValue: value,\n                  markers: newMarkers,\n                  oldMarkers: markers,\n                });\n\n              onChangeFromParent &&\n                onChangeFromParent({\n                  target: innerRef.current,\n                  value: newValue,\n                  markers: newMarkers,\n                });\n            };\n            const unmarkMarker = (marker, setCursor) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return;\n              }\n              marker = markers[i];\n\n              const newMarkers = [\n                ...markers.slice(0, i),\n                ...markers.slice(i + 1),\n              ];\n\n              setMarkers(newMarkers);\n\n              if (setCursor) {\n                const textarea = innerRef.current;\n                textarea.selectionStart = textarea.selectionEnd = marker.end;\n              }\n\n              onMarkersChange &&\n                onMarkersChange({\n                  target: innerRef.current,\n                  init: false,\n                  value,\n                  oldValue: value,\n                  markers: newMarkers,\n                  oldMarkers: markers,\n                });\n\n              onChangeFromParent &&\n                onChangeFromParent({\n                  target: innerRef.current,\n                  value,\n                  markers: newMarkers,\n                });\n            };\n            const updateMarkerPart = ({marker, partKey}, update) => {\n              const markerUuid = marker.uuid || marker;\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === markerUuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const partIndex = marker.partsConfig.findIndex(\n                ({key}) => key === partKey\n              );\n              if (partIndex < 0) {\n                return false;\n              }\n              const partsConfig = marker.partsConfig;\n              const partConfig = partsConfig[partIndex];\n\n              const updateFunction = update => {\n                if (!update) {\n                  return marker;\n                }\n\n                const {text, cursor, data, id} = update;\n\n                let {partsIds, partsData, parts, partsText} = marker;\n\n                const part = parts?.[partIndex];\n\n                const isLocked = Boolean(id, partsIds[partKey]);\n                const lastResolvedPartIndex = isLocked\n                  ? Math.max(partIndex, marker.lastResolvedPartIndex)\n                  : marker.lastResolvedPartIndex;\n\n                const isLastPossiblePart = partIndex === partsConfig.length - 1;\n\n                const isMarkerLocked =\n                  marker.isLocked || (isLocked && isLastPossiblePart);\n\n                const isLastPart = parts && partIndex === parts.length - 1;\n                const nextPartConfig = isLastPossiblePart\n                  ? null\n                  : partsConfig[partIndex + 1];\n\n                const appendText = isMarkerLocked\n                  ? update.appendText || ''\n                  : '';\n\n                const hasNewText = text != null;\n                const lengthChange = hasNewText\n                  ? isMarkerLocked\n                    ? text.length +\n                      appendText.length -\n                      (marker.end - marker.start)\n                    : getPartTextLengthChange(isLocked, part, partConfig, text)\n                  : 0;\n\n                if (id) {\n                  partsIds = {...partsIds, [partKey]: id};\n                }\n                if (data || data === null) {\n                  partsData = {...partsData, [partKey]: data};\n                }\n                if (isMarkerLocked) {\n                  parts = undefined;\n                } else if (isLocked !== part.isLocked || hasNewText) {\n                  const newParts = parts.slice(0, partIndex);\n                  const newPart = {\n                    ...parts[partIndex],\n                    isLocked,\n                    end: parts[partIndex].end + lengthChange,\n                    ...(isLocked\n                      ? {\n                          startChar: partConfig.startChar,\n                          endChar: partConfig.endChar,\n                        }\n                      : null),\n                  };\n                  newParts.push(newPart);\n                  if (isLastPart) {\n                    if (!isLastPossiblePart) {\n                      newParts.push({\n                        start: newPart.end,\n                        end: newPart.end,\n                        key: nextPartConfig.key,\n                        endChar: '',\n                        startChar: '',\n                      });\n                    }\n                  } else if (lengthChange) {\n                    newParts.push(\n                      ...parts.slice(partIndex + 1).map(part => ({\n                        ...part,\n                        start: part.start + lengthChange,\n                        end: part.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newParts.push(...parts.slice(partIndex + 1));\n                  }\n                  parts = newParts;\n                }\n                if (isMarkerLocked) {\n                  partsText = undefined;\n                } else if (hasNewText) {\n                  partsText = {...partsText, [partKey]: text};\n                  if (isLastPart && !isLastPossiblePart) {\n                    partsText[nextPartConfig.key] = '';\n                  }\n                }\n\n                const newMarkers = [...markers.slice(0, i)];\n                const newMarker = {\n                  ...marker,\n                  end: marker.end + lengthChange,\n                  parts,\n                  partsIds,\n                  partsData,\n                  partsText,\n                  lastResolvedPartIndex,\n                  isLocked: isMarkerLocked,\n                };\n                newMarkers.push(newMarker);\n                if (lengthChange) {\n                  newMarkers.push(\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      parts: marker.parts?.map(part => ({\n                        ...part,\n                        start: part.start + lengthChange,\n                        end: part.end + lengthChange,\n                      })),\n                      start: marker.start + lengthChange,\n                      end: marker.end + lengthChange,\n                    }))\n                  );\n                } else {\n                  newMarkers.push(...markers.slice(i + 1));\n                }\n\n                let newValue = value;\n                if (hasNewText) {\n                  newValue = [\n                    value.substring(\n                      0,\n                      isMarkerLocked ? marker.start : part.start\n                    ),\n                    isMarkerLocked\n                      ? text + appendText\n                      : getPartDelimitedText(isLocked, part, partConfig, text),\n                    value.substring(isMarkerLocked ? marker.end : part.end),\n                  ].join('');\n\n                  setValue(newValue);\n                }\n                setMarkers(newMarkers);\n                if (cursor) {\n                  const textarea = innerRef.current;\n                  innerRef.current.value = newValue;\n                  const marker = newMarkers[i];\n                  const part = marker.parts?.[partIndex];\n                  if (cursor === 'start') {\n                    textarea.selectionStart = textarea.selectionEnd =\n                      isMarkerLocked ? marker.start : part.start;\n                  } else if (cursor === 'end') {\n                    textarea.selectionStart = textarea.selectionEnd =\n                      isMarkerLocked\n                        ? marker.end + appendText.length\n                        : part.end;\n                  }\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update({marker, partConfig, partIndex}));\n              }\n              return updateFunction(update);\n            };\n            return {\n              deleteMarker,\n              unmarkMarker,\n              updateMarkerPart: ({marker, partKey}, update) =>\n                updateMarkerPart(\n                  {marker, partKey},\n                  ({marker, partConfig, partIndex}) => {\n                    if (typeof update === 'function') {\n                      update = update({\n                        marker,\n                        partKey,\n                        partConfig,\n                        partIndex,\n                      });\n                    }\n                    if (mutableRef.current.disabled && update) {\n                      // if disabled you can only update the data\n                      return {\n                        data: update.data,\n                      };\n                    }\n                    if (update) {\n                      return {\n                        data:\n                          update.data === undefined\n                            ? marker.partsData[partKey]\n                            : update.data,\n                        id: update.id ?? marker.partsIds[partKey],\n                        ...update,\n                      };\n                    }\n                    return update;\n                  }\n                ),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          const selectionEnd = textarea.selectionEnd;\n          const prevSelectionEnd =\n            prevValue.length - (newValue.length - selectionEnd);\n          const minSelectionEnd = Math.min(prevSelectionEnd, selectionEnd);\n\n          let selectionStart;\n          for (\n            selectionStart = 0;\n            selectionStart < minSelectionEnd &&\n            prevValue[selectionStart] === newValue[selectionStart];\n            selectionStart++\n          );\n\n          let selection = getMarkerSelections({\n            markers,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          const blockResult = blockMarkerUpdates({\n            ...selection,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          if (mutableRef.current.blockTimer) {\n            clearTimeout(mutableRef.current.blockTimer);\n            mutableRef.current.blockTimer = null;\n          }\n          if (blockResult.block) {\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            mutableRef.current.blockTimer = setTimeout(() => {\n              mutableRef.current.blockTimer = null;\n              try {\n                textarea.selectionStart = blockResult.selectionStart;\n                textarea.selectionEnd = blockResult.selectionEnd;\n                // eslint-disable-next-line no-empty\n              } catch (err) {}\n            });\n            e.preventDefault();\n            return false;\n          }\n\n          const insertedText = newValue.substring(selectionStart, selectionEnd);\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {\n            newValue: parsedValue,\n            newMarkers: parsedMarkers,\n            selectionEnd: newSelectionEnd,\n          } = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const newCursorPosition =\n            parsedValue !== newValue ? newSelectionEnd : selectionEnd; // might need to be refined!!!\n          textarea.value = parsedValue;\n          textarea.selectionEnd = newCursorPosition;\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs(ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            disabled={disabled}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  markers,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visible: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const mouseEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('mouseOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visible: false,\n        type,\n      });\n    }\n  };\n  const mouseLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('mouseOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = (whereToFocus = {}) => {\n    const {start, end} = whereToFocus;\n    const delta = whereToFocus.delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else if (end) {\n      markersHandlers.focus(marker.end + delta);\n    } else {\n      markersHandlers.focus();\n    }\n  };\n  const focusEnd = () => focus({end: true});\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onMouseEnter={() => mouseEnter(i)}\n        onMouseLeave={mouseLeave}\n        onPointerDown={focusEnd}\n        onPointerUp={focusEnd}\n        onClick={focusEnd}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        style={{zIndex: tipsZIndex}}\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markers={markers}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onMouseEnter: () => mouseEnter(i),\n              onMouseLeave: mouseLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        markers={markers}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({\n          marker,\n          isInEdit: marker.uuid === inEditMarker?.uuid,\n        })}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n        tipsZIndex={tipsZIndex}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultBackgroundColor = 'white',\n  tipsZIndex = 99999999,\n  classNameGetters: baseClassNameGetters,\n} = {}) => {\n  const classNameGetters = {\n    front: baseClassNameGetters?.front\n      ? params =>\n          baseClassNameGetters.front(\n            params,\n            defaultClassNameGetters.front(params)\n          ) ?? defaultClassNameGetters.front(params)\n      : defaultClassNameGetters.front,\n    back: baseClassNameGetters?.back\n      ? params =>\n          baseClassNameGetters.back(\n            params,\n            defaultClassNameGetters.back(params)\n          ) ?? defaultClassNameGetters.back(params)\n      : defaultClassNameGetters.back,\n    tip: baseClassNameGetters?.tip\n      ? params =>\n          baseClassNameGetters.tip(\n            params,\n            defaultClassNameGetters.tip(params)\n          ) ?? defaultClassNameGetters.tip(params)\n      : defaultClassNameGetters.tip,\n  };\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.markers[e.inEditMarkerIndex];\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div\n            id={id}\n            className=\"textarea-container\"\n            style={{backgroundColor, width: restProps.style?.width}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n                tipsZIndex={tipsZIndex}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div\n        className=\"textarea-with-resize-container\"\n        style={{width: restProps.style?.width}}>\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nexport const TOTAL_HIDE = 1;\nexport const SKIP_HIDE = false;\nexport const DEFAULT_HIDE = true;\n\nexport const VISIBLE = true;\nexport const NOT_VISIBLE = false;\nexport const TOGGLE_VISIBLITY = 'toggle';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst wrapHideAction =\n  (baseHideAction = () => DEFAULT_HIDE) =>\n  ({markerUuid, visiblityStack, requestedHideType}) => {\n    const hideOrNewVisiblityStack = baseHideAction({\n      markerUuid,\n      visiblityStack,\n      requestedHideType,\n    });\n    if (Array.isArray(hideOrNewVisiblityStack)) {\n      return hideOrNewVisiblityStack;\n    }\n    if (hideOrNewVisiblityStack === SKIP_HIDE) {\n      return visiblityStack;\n    }\n    if (hideOrNewVisiblityStack === TOTAL_HIDE || !requestedHideType) {\n      return [];\n    }\n    return visiblityStack.filter(({type}) => type !== requestedHideType);\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({});\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visible, labelLineIndex, hideAction}) => {\n            hideAction = wrapHideAction(hideAction);\n            const markerUuid = marker?.uuid || marker;\n            if (!visible && !markerUuid) {\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  const newCurrMarkerDataStack = hideAction({\n                    markerUuid,\n                    visiblityStack: tipsDataStack[markerUuid],\n                    requestedHideType: type,\n                  });\n                  if (newCurrMarkerDataStack.length) {\n                    newTipsDataStack[markerUuid] = newCurrMarkerDataStack;\n\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              visible =\n                visible === TOGGLE_VISIBLITY\n                  ? !tipsDataStack[markerUuid]?.find(data => data.type === type)\n                  : Boolean(visible);\n\n              if (!visible) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (!oldDataStack) {\n                  return visibleTipsSettings;\n                }\n                const newCurrMarkerDataStack = hideAction({\n                  markerUuid,\n                  visiblityStack: oldDataStack,\n                  requestedHideType: type,\n                });\n\n                if (newCurrMarkerDataStack.length) {\n                  const lastTipData =\n                    newCurrMarkerDataStack[newCurrMarkerDataStack.length - 1];\n                  return {\n                    data: {\n                      ...tipsData,\n                      [markerUuid]: {\n                        type: lastTipData.type,\n                        labelLineIndex: lastTipData.labelLineIndex,\n                        focus: tipsData[markerUuid].focus,\n                      },\n                    },\n                    dataStack: {\n                      ...tipsDataStack,\n                      [markerUuid]: newCurrMarkerDataStack,\n                    },\n                  };\n                }\n\n                const newTipsData = {...tipsData};\n                delete newTipsData[markerUuid];\n\n                const newDataStack = {...tipsDataStack};\n                delete newDataStack[markerUuid];\n\n                return {\n                  data: newTipsData,\n                  dataStack: newDataStack,\n                };\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {markers, inEditMarkerIndex} = e;\n              const inEditMarker = markers[inEditMarkerIndex];\n              const oldInEditMarker = mutableRef.current.inEditMarker;\n              mutableRef.current.inEditMarker = inEditMarker;\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visible: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker && inEditMarker !== oldInEditMarker) {\n                // whether a different marker or same marker but updated\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visible: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visible: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n            e.stopPropagation();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visible: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      const onInEditMarkerChange = e => {\n        const inEditMarker = e.markers[e.inEditMarkerIndex];\n        const prevInEditMarker = mutableRef.current.inEditMarker;\n        if (prevInEditMarker && prevInEditMarker.uuid !== inEditMarker?.uuid) {\n          mutableRef.current.updateTipVisibility({\n            visible: false,\n            type: 'keyboard',\n          });\n        }\n        mutableRef.current.inEditMarker = inEditMarker;\n        onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={onInEditMarkerChange}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport {\n  DEFAULT_HIDE,\n  SKIP_HIDE,\n  TOGGLE_VISIBLITY,\n  TOTAL_HIDE,\n} from './withTips';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const clickListener = e => {\n        let elem = e.target;\n        let onTextArea = false;\n        let onTip = false;\n        let onMarker = false;\n        while (elem) {\n          onTextArea = elem.id === id;\n          onTip = elem.dataset?.tipForTextarea === id;\n          onMarker = elem.dataset?.tipAnchorForTextarea === id;\n          if (onTextArea || onTip || onMarker) {\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!onTextArea && !onTip && !onMarker) {\n          mutable.updateTipVisibility({\n            visible: false,\n          });\n          e.preventDefault();\n        } else {\n          const anchorMarkerUuid = onMarker && elem.dataset.tipAnchorForMarker;\n          mutable.updateTipVisibility({\n            visible: false,\n            type: 'clickOnTip',\n            hideAction: ({markerUuid, visiblityStack}) => {\n              if (markerUuid !== anchorMarkerUuid) {\n                return DEFAULT_HIDE;\n              }\n              return SKIP_HIDE;\n            },\n          });\n          if (onMarker) {\n            mutable.updateTipVisibility({\n              marker: anchorMarkerUuid,\n              visible: TOGGLE_VISIBLITY,\n              type: 'clickOnTip',\n              hideAction: () => TOTAL_HIDE,\n            });\n          } else if (onTip) {\n            mutable.updateTipVisibility({\n              marker: elem.dataset.tipForMarker,\n              visible: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', clickListener);\n      return () => document.removeEventListener('click', clickListener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBaseTextArea = (TextArea = 'textarea') =>\n  React.forwardRef(({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <TextArea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBaseTextArea;\n","const fortifyGetCache = getCache => options => {\n  const cache = getCache(options);\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nexport default fortifyGetCache;\n","const defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nexport default defaultGetCache;\n","/**\n * @template I\n * @template O\n * @callback MapFunction\n * @param {I} item\n * @param {number} index\n * @param {I[]} array\n * @returns {O}\n */\n\n/**\n * @template I\n * @callback KeyFunction\n * @param {I} item\n * @returns {string}\n */\n\n/**\n * @template I\n * @template O\n * @param {I[]} array\n * @param {MapFunction<I,O>} mapFunction\n * @param {KeyFunction<I> | string} keyFunction\n * @returns {Object<string, O>}\n */\nconst mapAndKeyBy = (array, mapFunction, keyFunction) => {\n  if (typeof keyFunction !== 'function') {\n    const key = keyFunction;\n    keyFunction = item => item[key];\n  }\n  const keyed = {};\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    keyed[keyFunction(item)] = mapFunction(item, i, array);\n  }\n  return keyed;\n};\n\nexport default mapAndKeyBy;\n","const doesItemMatchSearch = (item, searchText) => {\n  const searchTextLowerCased = (searchText ?? '').toLowerCase();\n  if (typeof item === 'string') {\n    return item.toLowerCase().includes(searchTextLowerCased);\n  }\n  // eslint-disable-next-line guard-for-in\n  for (const i in item) {\n    const val = item[i];\n    switch (typeof val) {\n      case 'string':\n        if (val.toLowerCase().includes(searchTextLowerCased)) {\n          return true;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return false;\n};\nconst searchArray = (array, searchText) =>\n  array.filter(item => doesItemMatchSearch(item, searchText));\n\nexport default searchArray;\n","const ensureLoaderIsAsync =\n  loader =>\n  (...args) => {\n    const ret = loader(...args);\n    return Promise.resolve().then(() => ret);\n  };\n\nexport default ensureLoaderIsAsync;\n","import React, {forwardRef, useRef} from 'react';\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nexport default withId;\n","import React, {forwardRef} from 'react';\n\nconst withStyle =\n  ({defaultLineHeight = '135%', defaultWidth}) =>\n  (TextArea = 'textarea') =>\n    forwardRef(({width, lineHeight, ...restProps}, ref) => (\n      <TextArea\n        ref={ref}\n        {...restProps}\n        style={{\n          ...restProps.style,\n          width: width ?? restProps.style?.width ?? defaultWidth,\n          lineHeight:\n            lineHeight ?? restProps.style?.lineHeight ?? defaultLineHeight,\n        }}\n      />\n    ));\n\nexport default withStyle;\n","import {useRef, useState, useCallback, useEffect} from 'react';\nimport AbortController from 'abort-controller';\n\nconst buildDetailsDataLoaderHook = ({\n  partKey,\n  loader,\n  cache,\n  getLoadData,\n  getCacheKey = loadData => JSON.stringify(loadData),\n  shouldReloadData = () => false,\n  isAbortError,\n}) => {\n  getLoadData =\n    getLoadData ||\n    (({marker}) => {\n      const partsConfig = marker.partsConfig;\n      const partsIds = marker.partsIds;\n      const loadData = {};\n      for (let i = 0; i < partsConfig.length; i++) {\n        const currPartKey = partsConfig[i].key;\n        loadData[currPartKey] = partsIds[currPartKey];\n        if (currPartKey === partKey) {\n          return loadData;\n        }\n      }\n      return loadData;\n    });\n\n  const useDetailsDataLoader = ({marker, markers, markersHandlers}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error, retry}, setResultData] = useState({});\n\n    const data = marker.partsData[partKey];\n    const doLoad = data === undefined || shouldReloadData(data);\n    const loadData = doLoad ? getLoadData({partKey, marker, markers}) : null;\n    const cacheKey = loadData ? getCacheKey(loadData) : null;\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.markersHandlers = markersHandlers;\n    mutableRef.current.cacheKey = cacheKey;\n    mutableRef.current.marker = marker;\n\n    const retryFunction = useCallback(\n      () =>\n        setResultData(resultData => ({\n          ...resultData,\n          retry: (resultData.retry ?? 0) + 1,\n        })),\n      []\n    );\n\n    useEffect(() => {\n      const {loadData, marker} = mutableRef.current;\n      if (!loadData) {\n        return undefined;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.markersHandlers.updateMarkerPart(\n          {\n            partKey,\n            marker,\n          },\n          {\n            data: cachedData,\n          }\n        );\n        setResultData({});\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResultData({loading: true});\n      loader(loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.markersHandlers.updateMarkerPart(\n              {\n                partKey,\n                marker,\n              },\n              {\n                data: result,\n              }\n            );\n            setResultData({});\n          }\n        })\n        .catch(error => {\n          if (isAbortError(error)) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResultData({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, retry]);\n\n    return {loading, error, loadData, data, retry: retryFunction};\n  };\n  return useDetailsDataLoader;\n};\n\nexport default buildDetailsDataLoaderHook;\n","import React from 'react';\nimport buildDetailsDataLoaderHook from '../hook/buildDetailsDataLoaderHook';\n\nconst buildDetailsComponent = ({\n  markerType,\n  partKey,\n  Component,\n  NotFoundComponent,\n  loader,\n  shouldReloadData,\n  getLoadData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n  isAbortError,\n}) => {\n  const cache = getCache({type: 'details', markerType, partKey});\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  const useDetailDataLoader = buildDetailsDataLoaderHook({\n    partKey,\n    loader,\n    cache,\n    getLoadData,\n    getCacheKey,\n    shouldReloadData,\n    isAbortError,\n  });\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const {loading, error, data, loadData, retry} = useDetailDataLoader({\n      marker,\n      markers,\n      markersHandlers,\n    });\n\n    if (error) {\n      return (\n        <ErrorComponent\n          error={error}\n          retry={retry}\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    if (loading || !data) {\n      return (\n        <LoaderComponent\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    return (\n      <Component\n        data={data}\n        partKey={partKey}\n        loadData={loadData}\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        markersHandlers={markersHandlers}\n      />\n    );\n  };\n};\n\nexport default buildDetailsComponent;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import useDebounceValue from 'lib/hooks/useDebounceValue';\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport AbortController from 'abort-controller';\n\nconst buildSearchDataLoaderHook = ({\n  partKey,\n  loader,\n  cache,\n  getSearchData = ({searchText, marker}) => ({\n    searchText,\n    partsIds: marker.partsIds,\n  }),\n  getCacheKey = searchData => JSON.stringify(searchData),\n  filterResults,\n  debounceDuration,\n  isAbortError,\n}) => {\n  const useSearchDataLoader = ({marker, markers}) => {\n    const mutableRef = useRef({});\n\n    const searchText = marker.partsText[partKey];\n\n    const searchData =\n      getSearchData({\n        searchText,\n        partKey,\n        marker,\n        markers,\n      }) ?? null;\n\n    const cacheKey = searchData != null ? getCacheKey(searchData) : null;\n    const debouncedCacheKey = useDebounceValue(cacheKey, debounceDuration);\n\n    const noSearch = cacheKey === null;\n\n    const [{loading, error, results, resultsCacheKey, retry}, setResultsData] =\n      useState({});\n\n    const isResultForCurrentSearch = resultsCacheKey === cacheKey;\n\n    mutableRef.current.marker = marker;\n    mutableRef.current.markers = markers;\n    mutableRef.current.searchData = searchData;\n\n    const retryFunction = useCallback(\n      () =>\n        setResultsData(resultsData => ({\n          ...resultsData,\n          retry: (resultsData.retry ?? 0) + 1,\n        })),\n      []\n    );\n\n    useEffect(() => {\n      mutableRef.current.cacheKey = debouncedCacheKey;\n      if (debouncedCacheKey === null) {\n        setResultsData({});\n        return undefined;\n      }\n\n      const searchData = mutableRef.current.searchData;\n\n      const cachedResults = cache.getItem(debouncedCacheKey);\n      if (cachedResults) {\n        setResultsData({\n          results: filterResults(cachedResults, searchData),\n          resultsCacheKey: debouncedCacheKey,\n        });\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResultsData({loading: true});\n      loader(searchData, abortCtrl.signal)\n        .then(results => {\n          cache.setItem(debouncedCacheKey, results);\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResultsData({\n              results: filterResults(results, searchData),\n              resultsCacheKey: debouncedCacheKey,\n            });\n          }\n        })\n        .catch(error => {\n          if (isAbortError(error)) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResultsData({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [debouncedCacheKey, retry]);\n\n    return {\n      noSearch,\n      loading,\n      error: isResultForCurrentSearch ? error : null,\n      searchText,\n      searchData,\n      results: isResultForCurrentSearch ? results : null,\n      retry: retryFunction,\n    };\n  };\n\n  return useSearchDataLoader;\n};\n\nexport default buildSearchDataLoaderHook;\n","import {useEffect, useRef} from 'react';\n\nconst buildAutoSelectHook = ({partKey, autoSelect}) => {\n  const useAutoSelect = ({\n    searchText,\n    searchData,\n    results,\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n  }) => {\n    const mutableRef = useRef({});\n    mutableRef.current.searchData = searchData;\n    mutableRef.current.marker = marker;\n    mutableRef.current.markers = markers;\n    mutableRef.current.focusParent = focusParent;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.markersHandlers = markersHandlers;\n\n    const isLastPart = marker.parts[marker.parts.length - 1].key === partKey;\n    useEffect(() => {\n      if (!results) {\n        return;\n      }\n      const {\n        searchData,\n        marker,\n        markers,\n        focusParent,\n        onHide,\n        markersHandlers,\n      } = mutableRef.current;\n      const update = autoSelect({\n        marker,\n        markers,\n        searchText,\n        searchData,\n        results,\n        isLastPart,\n      });\n      if (!update) {\n        return;\n      }\n      if (!update.id) {\n        throw new Error(\n          `autoSelect function in part \"${partKey}\"'s search options did not return an \"id\" field which is required`\n        );\n      }\n      const newMarker = markersHandlers.updateMarkerPart(\n        {\n          marker,\n          partKey,\n        },\n        {\n          ...update,\n          cursor: update.cursor ?? 'end',\n          isLocked: update.isLocked ?? true,\n        }\n      );\n      focusParent();\n      if (update.hide || (update.hide === undefined && newMarker?.isLocked)) {\n        setTimeout(() => onHide(false));\n      }\n    }, [results, searchText, isLastPart]);\n  };\n\n  return useAutoSelect;\n};\n\nexport default buildAutoSelectHook;\n","import React, {useEffect} from 'react';\n\nimport buildSearchDataLoaderHook from '../hook/buildSearchDataLoaderHook';\nimport buildAutoSelectHook from '../hook/buildAutoSelectHook';\n\nconst buildSearchComponent = ({\n  markerType,\n  partKey,\n  detailsComponents,\n  loader,\n  filterResults,\n  getSearchData,\n  getCacheKey,\n  getCache,\n  ZeroSearchResultsComponent,\n  NoSearchComponent,\n  ResultsComponent,\n  LoaderComponent,\n  ErrorComponent,\n  debounceDuration,\n  autoSelect,\n  isAbortError,\n}) => {\n  const cache = getCache({type: 'search', markerType, partKey});\n\n  const useSearchDataLoader = buildSearchDataLoaderHook({\n    partKey,\n    loader,\n    cache,\n    getSearchData,\n    getCacheKey,\n    filterResults,\n    debounceDuration,\n    isAbortError,\n  });\n\n  const useAutoSelect = buildAutoSelectHook({\n    partKey,\n    autoSelect,\n  });\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const {noSearch, loading, error, searchText, searchData, results, retry} =\n      useSearchDataLoader({\n        marker,\n        markers,\n      });\n\n    useEffect(() => {\n      if (noSearch && !NoSearchComponent) {\n        onHide();\n      }\n    }, [noSearch, onHide]);\n\n    useAutoSelect({\n      searchText,\n      searchData,\n      results,\n      marker,\n      markers,\n      focusParent,\n      onHide,\n      markersHandlers,\n    });\n\n    if (noSearch && NoSearchComponent) {\n      return (\n        <NoSearchComponent\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (error) {\n      return (\n        <ErrorComponent\n          error={error}\n          retry={retry}\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (loading || !results) {\n      return (\n        <LoaderComponent\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (!results.length) {\n      return (\n        <ZeroSearchResultsComponent\n          results={results}\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    return (\n      <ResultsComponent\n        results={results}\n        detailsComponents={detailsComponents}\n        partKey={partKey}\n        searchText={searchText}\n        searchData={searchData}\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        markersHandlers={markersHandlers}\n      />\n    );\n  };\n};\n\nexport default buildSearchComponent;\n","const negativeSupportingModulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nexport default negativeSupportingModulo;\n","import negativeSupportingModulo from 'lib/helpers/negativeSupportingModulo';\nimport React, {useEffect, useImperativeHandle, useRef, useState} from 'react';\n\nconst buildSearchResultsPickerComponent = ({\n  partKey,\n  ItemComponent,\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    markers,\n    markersHandlers,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        partKey,\n        selectedItem: data,\n        marker,\n        markers,\n      });\n      if (!update.id) {\n        throw new Error(\n          `onSelect function in part \"${partKey}\"'s search options did not return an \"id\" field which is required`\n        );\n      }\n      const newMarker = markersHandlers.updateMarkerPart(\n        {\n          marker,\n          partKey,\n        },\n        {\n          data,\n          ...update,\n          cursor: update.cursor ?? 'end',\n          isLocked: update.isLocked ?? true,\n        }\n      );\n      focusParent();\n      if (update.hide || (update.hide === undefined && newMarker?.isLocked)) {\n        setTimeout(() => onHide(false));\n      }\n    };\n\n    const focused =\n      focusedIndex == null\n        ? null\n        : negativeSupportingModulo(focusedIndex, results.length);\n    const focusedRef = useRef();\n\n    useEffect(() => {\n      if (focused != null && focusedRef.current) {\n        focusedRef.current.focus();\n        const t = setTimeout(() => {\n          if (\n            document.activeElement !== focusedRef.current &&\n            document.activeElement.getAttribute('tabIndex') === '-1'\n          ) {\n            document.activeElement.removeAttribute('tabIndex');\n            focusedRef.current.focus();\n          }\n        });\n        return () => clearTimeout(t);\n      }\n      return undefined;\n    }, [focused]);\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      }\n    };\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={elem => {\n                if (focused === i) {\n                  focusedRef.current = elem;\n                }\n              }}\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent\n                partKey={partKey}\n                item={item}\n                marker={marker}\n                markers={markers}\n              />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nexport default buildSearchResultsPickerComponent;\n","import mapAndKeyBy from 'lib/helpers/mapAndKeyBy';\nimport React from 'react';\nimport buildDetailsComponent from './buildDetailsComponent';\nimport buildSearchComponent from './buildSearchComponent';\nimport buildSearchResultsPickerComponent from './buildSearchResultsPickerComponent';\n\nconst buildMarkerTipComponent = ({\n  tipOptions: {markerType, anchorChar, parts},\n  isAbortError,\n}) => {\n  const detailsComponents = mapAndKeyBy(\n    parts,\n    ({key, details}) => {\n      if (!details) {\n        return null;\n      }\n      const {\n        Component,\n        NotFoundComponent,\n        loader,\n        getCacheKey,\n        shouldReloadData,\n        getLoadData,\n        LoaderComponent,\n        ErrorComponent,\n        getCache,\n      } = details;\n      return buildDetailsComponent({\n        markerType,\n        anchorChar,\n        partKey: key,\n        Component,\n        NotFoundComponent,\n        loader,\n        getCacheKey,\n        shouldReloadData,\n        getLoadData,\n        LoaderComponent,\n        ErrorComponent,\n        getCache,\n        isAbortError,\n      });\n    },\n    'key'\n  );\n\n  const searchComponents = mapAndKeyBy(\n    parts,\n    ({\n      key,\n      search: {\n        ResultsComponent,\n        ResultItemComponent,\n        onItemSelect,\n        ZeroSearchResultsComponent = () => 'No matching entries found',\n        NoSearchComponent,\n        loader,\n        filterResults,\n        getSearchData,\n        autoSelect: baseAutoSelect,\n        getCacheKey = searchData => JSON.stringify(searchData),\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n      },\n    }) => {\n      if (baseAutoSelect && !onItemSelect) {\n        throw new Error('autoSelect needs onItemSelect to be defined');\n      }\n      const autoSelect = baseAutoSelect\n        ? params => {\n            const {partKey, marker, markers} = params;\n            const selectedItem = baseAutoSelect(params);\n            if (!selectedItem) {\n              return undefined;\n            }\n            const update = onItemSelect({\n              partKey,\n              selectedItem,\n              marker,\n              markers,\n            });\n            if (update) {\n              return {\n                data: selectedItem,\n                ...update,\n              };\n            }\n            return update;\n          }\n        : () => undefined;\n      return buildSearchComponent({\n        markerType,\n        anchorChar,\n        partKey: key,\n        detailsComponents,\n        loader,\n        filterResults,\n        getSearchData,\n        getCacheKey,\n        NoSearchComponent,\n        ZeroSearchResultsComponent,\n        ResultsComponent: ResultItemComponent\n          ? buildSearchResultsPickerComponent({\n              partKey: key,\n              ItemComponent: ResultItemComponent,\n              ContainerComponent: ResultsComponent,\n              onSelect: onItemSelect,\n            })\n          : ResultsComponent,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n        autoSelect,\n        isAbortError,\n      });\n    },\n    'key'\n  );\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    if (marker.isLocked) {\n      const lastPartConfig = marker.partsConfig[marker.partsConfig.length - 1];\n      const DetailsComponent = detailsComponents[lastPartConfig.key];\n      return (\n        <DetailsComponent\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n\n    const firstUnresolvedPartIndex = marker.lastResolvedPartIndex + 1;\n    const firstUnresolvedPartConfig =\n      marker.partsConfig[firstUnresolvedPartIndex];\n    const SearchComponent = searchComponents[firstUnresolvedPartConfig.key];\n\n    return (\n      <SearchComponent\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        markersHandlers={markersHandlers}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n      />\n    );\n  };\n};\n\nexport default buildMarkerTipComponent;\n","import React, {useEffect, useRef} from 'react';\nimport buildMarkerTipComponent from './buildMarkerTipComponent';\n\nconst buildTipComponent = ({tipsOptionsByType, isAbortError}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = buildMarkerTipComponent({\n      tipOptions: tipsOptionsByType[type],\n      isAbortError,\n    });\n  }\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nexport default buildTipComponent;\n","import withSmartTextArea from './hocs/withSmartTextArea';\n\nexport default withSmartTextArea;\n","import withMarkerParser from '../../withMarkerParser';\nimport withMarkableTextArea from '../../withMarkableTextArea';\nimport withResize from '../../withResize';\nimport withSelectionChange from '../../withSelectionChange';\nimport withMarkerSelection from '../../withMarkerSelection';\nimport withTips from '../../withTips';\nimport withFocusTipOnDown from '../../withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from '../../withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport withBlockUndoRedoAndDragDropText from '../../withBlockUndoRedoAndDragDropText';\nimport withBaseTextArea from '../../withBaseTextArea';\nimport fortifyGetCache from '../helpers/fortifyGetCache.';\nimport defaultGetCache from '../helpers/defaultGetCache';\nimport mapAndKeyBy from '../../../helpers/mapAndKeyBy';\nimport searchArray from '../../../helpers/searchArray';\nimport ensureLoaderIsAsync from '../helpers/ensureLoaderIsAsync';\nimport withId from './withId';\nimport withStyle from './withStyle';\nimport buildTipComponent from '../builders/component/buildTipComponent';\n\n/** @type {import('./types.jsdocs').WithSmartTextAreaHOC} */\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version = 0,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  debounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  lineHeight,\n  width,\n  TextArea,\n  tipsZIndex,\n  isAbortError = error =>\n    error.aborted || error.message.toLowerCase().includes('abort'),\n}) => {\n  getCache = getCache ? fortifyGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = mapAndKeyBy(\n    baseAnchors,\n    anchor => {\n      const anchorGetCache = anchor.getCache\n        ? fortifyGetCache(anchor.getCache)\n        : getCache;\n      const anchorLoaderComponent =\n        anchor.LoaderComponent || LoaderComponent || (() => 'Loading...');\n      const anchorErrorComponent =\n        anchor.ErrorComponent ||\n        ErrorComponent ||\n        (({error}) => error?.message || 'Oops');\n      const anchorDebounceDuration =\n        anchor.debounceDuration || debounceDuration;\n\n      return {\n        markerType: anchor.type,\n        parts: anchor.parts.map(\n          (\n            {\n              key,\n              searchConfig,\n              detailsConfig,\n              searchOptions,\n              detailsOptions,\n              LoaderComponent,\n              ErrorComponent,\n              debounceDuration,\n              getCache,\n            },\n            i\n          ) => {\n            searchConfig = searchConfig || searchOptions;\n            detailsConfig = detailsConfig || detailsOptions;\n            let searchLoader;\n            if (searchConfig.data) {\n              searchLoader = (\n                searchConfig.filterData ||\n                ((data, searchData) => searchArray(data, searchData.searchText))\n              ).bind(null, searchConfig.data);\n            } else {\n              searchLoader =\n                searchConfig.loader ||\n                searchConfig.search ||\n                searchConfig.searchFunction;\n            }\n            if (!searchLoader) {\n              throw new Error(\n                `${anchor.type}'s ${key} part does not have a search \"loader\" function nor (a \"data\" field with optional \"filterData\" function)`\n              );\n            }\n            let detailsLoader;\n            if (detailsConfig) {\n              if (searchConfig.data) {\n                if (!detailsConfig.findInSearchData) {\n                  throw new Error(\n                    `${anchor.type}'s ${key} part which has a \"data\" search field does not provide a \"findInSearchData\" function. It is needed to locate an specific item by id in the search \"data\"`\n                  );\n                }\n                detailsLoader = detailsConfig.findInSearchData.bind(\n                  null,\n                  searchConfig.data\n                );\n              } else {\n                detailsLoader =\n                  detailsConfig.loader ||\n                  detailsConfig.loadDetails ||\n                  detailsConfig.loadDetail;\n              }\n              if (!detailsLoader) {\n                throw new Error(\n                  `${anchor.type}'s ${key} part does not have a details \"loader\" function nor a (details \"findInSearchData\" function and a search \"data\" field)`\n                );\n              }\n            } else if (i === anchor.parts[i].length - 1) {\n              throw new Error(\n                `detailsConfig is issing for last part (${key}) of marker ${anchor.type}. Last part of a marker must have a detailsConfig defined`\n              );\n            }\n\n            return {\n              key,\n              search: {\n                LoaderComponent: LoaderComponent || anchorLoaderComponent,\n                ErrorComponent: ErrorComponent || anchorErrorComponent,\n                debounceDuration: debounceDuration || anchorDebounceDuration,\n                ...searchConfig,\n                filterResults:\n                  searchConfig.filterResults || (results => results),\n                getCache:\n                  searchConfig.getCache || getCache\n                    ? fortifyGetCache(searchConfig.getCache || getCache)\n                    : anchorGetCache,\n                loader: ensureLoaderIsAsync(searchLoader),\n              },\n              details: detailsConfig\n                ? {\n                    LoaderComponent: LoaderComponent || anchorLoaderComponent,\n                    ErrorComponent: ErrorComponent || anchorErrorComponent,\n                    ...detailsConfig,\n                    Component:\n                      detailsConfig.Component ||\n                      detailsConfig.DisplayComponent ||\n                      detailsConfig.DetailsComponent ||\n                      detailsConfig.DetailComponent,\n                    getCache:\n                      detailsConfig.getCache || getCache\n                        ? fortifyGetCache(detailsConfig.getCache || getCache)\n                        : anchorGetCache,\n                    loader: ensureLoaderIsAsync(detailsLoader),\n                  }\n                : null,\n            };\n          }\n        ),\n      };\n    },\n    'type'\n  );\n  const anchors = baseAnchors.map(anchor => ({\n    anchorChar: anchor.anchorChar,\n    type: anchor.type,\n    parts: anchor.parts.map(\n      ({\n        searchConfig,\n        detailsConfig,\n        searchOptions,\n        detailsOptions,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n        ...restOptions\n      }) => restOptions\n    ),\n  }));\n\n  return withId(getId)(\n    withStyle({\n      defaultLineHeight: lineHeight,\n      defaultWidth: width,\n    })(\n      withTips({\n        hideOnEscape: hideTipOnEscape,\n        TipComponent: buildTipComponent({\n          tipsOptionsByType,\n          isAbortError,\n        }),\n      })(\n        withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n          withFocusTipOnDown(\n            withMarkableTextArea({\n              classNameGetters,\n              tipsZIndex,\n              defaultBackgroundColor: backgroundColor,\n            })(\n              withResize(\n                withMarkerParser({\n                  markerParserOptions: {\n                    version,\n                    anchors,\n                  },\n                })(\n                  withMarkerSelection(\n                    withSelectionChange(\n                      withBlockUndoRedoAndDragDropText(\n                        withBaseTextArea(TextArea)\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({marker, markersHandlers}) => (\n  <b>\n    Person not found!\n    <br />\n    <br />\n    <button type=\"button\" onClick={() => markersHandlers.deleteMarker(marker)}>\n      Delete\n    </button>{' '}\n    <button type=\"button\" onClick={() => markersHandlers.unmarkMarker(marker)}>\n      Unmark\n    </button>\n  </b>\n);\n\nconst capitalize = str =>\n  str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase();\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  classNameGetters: {\n    back: ({marker}, defaultClassName) => {\n      if (marker.type === 'combined' && marker.partsIds.type) {\n        return `${defaultClassName} textarea-back-${marker.partsIds.type}-label`;\n      }\n      return undefined;\n    },\n  },\n  anchors: [\n    {\n      anchorChar: '!',\n      type: 'combined',\n      parts: [\n        {\n          key: 'type',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: ({item}) => <div>{capitalize(item)}</div>,\n            data: ['person', 'thing'],\n            onItemSelect: ({selectedItem}) => ({\n              text: capitalize(selectedItem),\n              id: selectedItem,\n            }),\n            autoSelect: ({searchText}) => {\n              switch (searchText?.trim().toLowerCase()) {\n                case 'person':\n                  return 'person';\n                case 'thing':\n                  return 'thing';\n                default:\n                  return undefined;\n              }\n            },\n          },\n        },\n        {\n          key: 'item',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: props => {\n              switch (props.marker.partsIds.type) {\n                case 'person':\n                  return <PersonSearchResultItem {...props} />;\n                case 'thing':\n                  return <ThingSearchResultItem {...props} />;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            loader: ({searchText, partsIds: {type}}, signal) => {\n              switch (type) {\n                case 'person':\n                  return personSearch(searchText, signal);\n                case 'thing':\n                  return thingSearch(searchText, signal);\n                default:\n                  throw new Error('Oops! Unknown type!');\n              }\n            },\n            onItemSelect: ({\n              selectedItem,\n              marker: {\n                partsIds: {type},\n              },\n            }) => {\n              switch (type) {\n                case 'person':\n                  return {\n                    text: selectedItem.name,\n                    id: selectedItem.id,\n                  };\n                case 'thing':\n                  return {\n                    text: selectedItem.name,\n                    id: selectedItem.id,\n                  };\n                default:\n                  return false;\n              }\n            },\n            getCacheKey: ({searchText, partsIds: {type}}) =>\n              `${type}:${searchText?.trim().toLowerCase() || ''}`,\n          },\n          detailsOptions: {\n            Component: props => {\n              switch (props.marker.partsIds.type) {\n                case 'person':\n                  return <PersonDetails {...props} />;\n                case 'thing':\n                  return <ThingDetails {...props} />;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            NotFoundComponent: props => {\n              const onHide = props.onHide;\n              const type = props.marker.partsIds.type;\n              useEffect(() => {\n                if (type === 'thing') {\n                  onHide();\n                }\n              }, [type, onHide]);\n              switch (type) {\n                case 'person':\n                  return <NotFoundPersonComponent {...props} />;\n                case 'thing':\n                  return null;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            loader: ({type, item: id}, signal) => {\n              switch (type) {\n                case 'person':\n                  return personDetails(id, signal);\n                case 'thing':\n                  return thingDetails(id, signal);\n                default:\n                  throw new Error('Oops! Unknown type!');\n              }\n            },\n            getCacheKey: ({type, item: id}) => `${type}:${id}`,\n          },\n        },\n      ],\n    },\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'person',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: PersonSearchResultItem,\n            NoResultItemComponent: () => 'No matching people found',\n            onItemSelect: ({selectedItem: person}) => ({\n              text: person.name,\n              id: person.id,\n            }),\n            loader: ({searchText: name}, signal) => personSearch(name, signal),\n            getCacheKey: ({searchText: name}) =>\n              name?.trim().toLowerCase() || null,\n            debounceDuration: 350,\n          },\n          detailsOptions: {\n            Component: PersonDetails,\n            NotFoundComponent: NotFoundPersonComponent,\n            loader: ({person: id}, signal) => personDetails(id, signal),\n            getCacheKey: ({person: id}) => id,\n          },\n        },\n      ],\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'thing',\n          endChar: ':',\n          searchOptions: {\n            ResultsComponent: ({ResultListComponent, ...props}) => (\n              <p>\n                <h5>Found the following things:</h5>\n                <ResultListComponent {...props} />\n              </p>\n            ),\n            NoSearchComponent: () => (\n              <pre>\n                Write something to start the search.\n                <br />\n                This custom no search message is only configured for things\n              </pre>\n            ),\n            ResultItemComponent: ThingSearchResultItem,\n            onItemSelect: ({selectedItem: thing}) => ({\n              text: thing.name,\n              id: thing.id,\n            }),\n            loader: ({searchText: name}, signal) => thingSearch(name, signal),\n            getCacheKey: ({searchText: name}) =>\n              name?.trim().toLowerCase() || null,\n            debounceDuration: 350,\n          },\n          detailsOptions: {\n            Component: ThingDetails,\n            loader: ({thing: id}, signal) => thingDetails(id, signal),\n            getCacheKey: ({thing: id}) => id,\n          },\n        },\n      ],\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useRef, useState} from 'react';\nimport classes from './App.module.css';\nimport SmartTextArea, {people, things} from './SmartTextArea';\n\nconst availablePpl = people.map(person => person.name).join(', ');\nconst availableThings = things.map(thing => thing.name).join(', ');\nconst App = () => {\n  const [markers, setMarkers] = useState([]);\n  const [inEditMarker, setInEditMarker] = useState([]);\n  const imperativeRef = useRef();\n  return (\n    <div className={classes.container}>\n      <ul>\n        <li>\n          use <b>!</b> to trigger mixed marker start. Here you first need to\n          select a type (person/thing), then select the item you want.\n          <ul>\n            <li>\n              Available people:\n              <br />\n              {availablePpl}\n            </li>\n            <li>\n              Available things:\n              <br />\n              {availableThings}\n            </li>\n            <li>\n              Mixed marker has autoSelect enabled on its first part (the type\n              part). to test it out try writing &quot;!person&quot; and it\n              should automatically select the person type.\n            </li>\n            <li>\n              if selected type is thing the color of the marker will be orange,\n              else it will default to gray\n            </li>\n            <li>\n              All mixed markers will have a custom gray border (actually its an\n              outline)\n            </li>\n          </ul>\n        </li>\n        <li>\n          use <b>@</b> to trigger person marker start. Available people to\n          search same as above.\n          <br />\n          people marker color is the default gray color\n        </li>\n        <li>\n          use <b>#</b> to trigger things marker start. Available things to\n          search same as above.\n          <br />\n          things marker color is a custom orange color\n        </li>\n      </ul>\n      <SmartTextArea\n        className=\"smart-text-area\"\n        imperativeRef={imperativeRef}\n        initValue={\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\n        }\n        initMarkers={[\n          {\n            start: 0,\n            end: 13,\n            type: 'combined',\n            partsIds: {type: 'person', item: 'mo'},\n          },\n          {start: 46, end: 54, type: 'person', partsIds: {person: 'john'}},\n          {start: 78, end: 86, type: 'person', partsIds: {person: 'jane'}},\n          {start: 112, end: 117, type: 'person', partsIds: {person: 'asdfg'}},\n          {start: 149, end: 153, type: 'thing', partsIds: {thing: 'fork'}},\n          {\n            start: 155,\n            end: 160,\n            type: 'combined',\n            partsIds: {type: 'thing', item: 'knife'},\n          },\n          {start: 165, end: 170, type: 'thing', partsIds: {thing: 'spoon'}},\n        ]}\n        onMarkersChange={e => {\n          setMarkers(e.markers);\n        }}\n        onInEditMarkerChange={e => {\n          setInEditMarker(e.markers[e.inEditMarkerIndex]);\n        }}\n      />\n      <h5>Markers:</h5>\n      <pre>\n        {markers.map(({partsConfig, ...marker}) => (\n          <div\n            key={marker.uuid}\n            className={\n              marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\n            }>\n            {JSON.stringify(marker, null, 3)}\n          </div>\n        ))}\n      </pre>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}