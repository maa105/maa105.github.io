{"version":3,"sources":["environment/App/App.module.css","lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withMarkerSelection.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/components/BaseTextArea.js","lib/hooks/useDebounceValue.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hooks/usePrev.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["module","exports","mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","blockMarkerUpdates","selection","markers","midSelectedMarkerIndex","endSelectedMarkerIndex","startSelectedMarkerIndex","midSelectedMarker","endSelectedMarker","startSelectedMarker","isLocked","block","selectionStart","start","selectionEnd","end","withInEditMarkerIndex","inEditMarkerIndex","markerWithEndTouchedIndex","getInEditMarkerIndex","getMarkerSelections","prevMarkerIndex","nextMarkerIndex","selectedMarkersRange","startIndex","endIndex","markerWithStartTouchedIndex","getReturn","marker","startTotallySelected","endTotallySelected","totalySelected","withMarkerSelection","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","onInEditMarkerChange","restProps","innerRef","e","textarea","target","isSingleSelection","prevSelection","startCursorMoved","endCursorMoved","newSelection","oldInEditMarkerIndex","DEFAULT_END","spaces","createMarker","uuid","anchor","type","markerData","data","Math","round","random","Date","now","parseMarkers","options","anchors","parts","j","key","startChar","endChars","partStart","substring","push","anchorChar","version","wrapMarkerParser","markerOffset","oldFirstMarker","map","prevValue","insertedText","markerParser","newValue","lengthChange","newMarkers","slice","nextMarkers","inEditMarker","startParse","endParse","toParse","parsedValue","parsedMarkers","nextNewMarkers","withMarkerParser","markerParserOptions","forEach","endChar","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","imperativeRef","props","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","updateMarker","findIndex","m","updateFunction","newMarker","textValue","appendText","markerUpdates","hasNewText","join","oldValue","oldMarkers","undefined","childImperativeRef","useEffect","newSelectionEnd","prevSelectionEnd","minSelectionEnd","min","blockResult","blockTimer","clearTimeout","setTimeout","err","preventDefault","error","newCursorPosition","properties","getCoordinatesAtPositions","positions","debug","el","document","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","mouseEnter","timer","visibile","showTip","hideTip","mouseLeave","focus","delta","markerUuid","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onMouseEnter","onMouseLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","constraints","to","renderTarget","renderElement","focusParent","onHide","whereToFocus","onPointerEnter","onPointerLeave","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","Boolean","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultLineHeight","defaultBackgroundColor","classNameGetters","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","addEventListener","onKeyUpListener","removeEventListener","SKIP_HIDE","DEFAULT_HIDE","TOGGLE_VISIBLITY","withHideTipOnEscape","listener","wrapHideAction","baseHideAction","visiblityStack","requestedHideType","hideOrNewVisiblityStack","Array","isArray","filter","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","hideAction","find","oldDataStack","newCurrMarkerDataStack","lastTipData","newTipsData","newDataStack","newTipsDataStack","oldInEditMarker","BaseTextArea","React","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","withFocusTipOnDown","tipData","prevInEditMarker","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","clickListener","onTextArea","onTip","onMarker","dataset","tipForTextarea","tipAnchorForTextarea","anchorMarkerUuid","tipAnchorForMarker","tipForMarker","usePrev","preValue","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","getSingleTip","tipOptions","search","SearchResultsComponent","ResultsComponent","SearchResultsItemComponent","ResultItemComponent","resultItemComponentOnSelect","NoResultItemComponent","searchFunction","loader","preProcessMarkerData","preProcessMarkerDataForSearch","getCacheKey","getSearchCacheKey","searchData","SearchLoaderComponent","LoaderComponent","SearchErrorComponent","ErrorComponent","debounceDuration","details","DetailComponent","Component","loadSingleFunction","DetailNotFoundComponent","NotFoundComponent","preProcessMarkerDataForSingleLoad","getDetailsCacheKey","DetailLoaderComponent","DetailErrorComponent","CommonLoaderComponent","CommonErrorComponent","getCache","cache","loading","setResult","loadData","cacheKey","cachedData","getItem","abortCtrl","AbortController","signal","then","result","setItem","catch","aborted","abort","getDetailComponent","ItemComponent","NoItemsComponent","ContainerComponent","ResultListComponent","onSelect","results","focusedIndex","setFocusedIndex","index","num","mod","select","selectedItem","focused","toFocus","onKeyDown","next","item","tabIndex","getSearchResultPickerComponent","setResults","cachedResults","getTip","tipsOptionsByType","ComponentsByType","defaultGetCache","withSmartTextArea","baseAnchors","hideTipOnEscape","getId","wrapGetCache","searchOptions","detailsOptions","withId","people","name","imageUrl","things","SmartTextArea","person","src","alt","Promise","resolve","reject","trim","toLocaleLowerCase","includes","toLowerCase","Error","personSearch","countDown","setCountDown","updateMarkerRef","setInterval","clearInterval","done","personDetails","thing","thingSearch","thingDetails","message","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.25e46fa1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"inEditMarker\":\"App_inEditMarker__2hzif\"};","const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (typeof ref === 'string') {\n        // console.log(ref, element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","export const blockMarkerUpdates = selection => {\n  const {\n    markers,\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = selection;\n\n  const midSelectedMarker = markers[midSelectedMarkerIndex];\n  const endSelectedMarker = markers[endSelectedMarkerIndex];\n  const startSelectedMarker = markers[startSelectedMarkerIndex];\n\n  if (midSelectedMarker && midSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: midSelectedMarker.start,\n      selectionEnd: midSelectedMarker.end,\n    };\n  }\n  if (endSelectedMarker && endSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: endSelectedMarker.start,\n      selectionEnd: endSelectedMarker.end,\n    };\n  }\n  if (startSelectedMarker && startSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: startSelectedMarker.start,\n      selectionEnd: startSelectedMarker.end,\n    };\n  }\n  return {\n    block: false,\n  };\n};\n","import React, {forwardRef, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst getInEditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\nconst withInEditMarkerIndex = selection => {\n  const inEditMarkerIndex = getInEditMarkerIndex(selection);\n  selection.inEditMarkerIndex = inEditMarkerIndex;\n  return selection;\n};\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart: start,\n  selectionEnd: end,\n}) => {\n  const selectedMarkersRange = {startIndex: -1, endIndex: -1};\n  let startSelectedMarkerIndex = -1;\n  let endSelectedMarkerIndex = -1;\n  let midSelectedMarkerIndex = -1;\n  let markerWithStartTouchedIndex = -1;\n  let markerWithEndTouchedIndex = -1;\n  let prevMarkerIndex;\n  let nextMarkerIndex;\n  let i = 0;\n\n  const getReturn = () =>\n    withInEditMarkerIndex({\n      markers,\n      selectedMarkersRange,\n      startSelectedMarkerIndex,\n      endSelectedMarkerIndex,\n      midSelectedMarkerIndex,\n      markerWithStartTouchedIndex,\n      markerWithEndTouchedIndex,\n      prevMarkerIndex,\n      nextMarkerIndex:\n        (nextMarkerIndex ?? -1) >= markers.length ? -1 : nextMarkerIndex ?? -1,\n    });\n\n  for (; i < markers.length && markers[i].end < start; i++);\n\n  prevMarkerIndex = i - 1;\n\n  let marker = markers[i];\n  if (!marker) {\n    return getReturn();\n  }\n\n  if (marker.end === start) {\n    markerWithEndTouchedIndex = prevMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n  }\n\n  if (marker.start >= end) {\n    nextMarkerIndex = i;\n    if (marker.start === end) {\n      markerWithStartTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected = start <= marker.start && marker.start < end;\n  let endTotallySelected = start < marker.end && marker.end <= end;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedMarkerIndex = i;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedMarkerIndex = i;\n      nextMarkerIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedMarkersRange.startIndex = i;\n\n  i++;\n  for (; i < markers.length; i++) {\n    marker = markers[i];\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedMarkersRange.endIndex = i;\n  return getReturn();\n};\n\nconst withMarkerSelection = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {\n        onSelectionChange: onSelectionChangeFromParent,\n        value,\n        markers,\n        onInEditMarkerChange,\n        ...restProps\n      },\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        let start = selectionStart;\n        let end = selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.selectionStart === selectionStart\n            ? 0\n            : selectionStart - prevSelection.selectionStart;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.selectionEnd === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.selectionEnd;\n\n        let {\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          // eslint-disable-next-line prefer-const\n          prevMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          nextMarkerIndex,\n        } = getMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n        });\n\n        if (midSelectedMarkerIndex >= 0) {\n          const midSelectedMarker = markers[midSelectedMarkerIndex];\n          if (midSelectedMarker.isLocked) {\n            if (isSingleSelection) {\n              if (startCursorMoved < 0) {\n                start = end = midSelectedMarker.start;\n                markerWithStartTouchedIndex = midSelectedMarkerIndex;\n              } else {\n                start = end = midSelectedMarker.end;\n                markerWithEndTouchedIndex = midSelectedMarkerIndex;\n              }\n              midSelectedMarkerIndex = -1;\n            } else {\n              start = midSelectedMarker.start;\n              end = midSelectedMarker.end;\n              selectedMarkersRange.startIndex = midSelectedMarkerIndex;\n              selectedMarkersRange.endIndex = midSelectedMarkerIndex;\n              midSelectedMarkerIndex = -1;\n            }\n          }\n        } else {\n          if (endSelectedMarkerIndex >= 0) {\n            const endSelectedMarker = markers[endSelectedMarkerIndex];\n            if (endSelectedMarker.isLocked) {\n              if (startCursorMoved < 0) {\n                start = endSelectedMarker.start;\n                selectedMarkersRange.startIndex = endSelectedMarkerIndex;\n                if (selectedMarkersRange.endIndex === -1) {\n                  selectedMarkersRange.endIndex = endSelectedMarkerIndex;\n                }\n                endSelectedMarkerIndex = -1;\n              } else {\n                start = endSelectedMarker.end;\n                markerWithEndTouchedIndex = endSelectedMarkerIndex;\n                endSelectedMarkerIndex = -1;\n              }\n            }\n          }\n          if (startSelectedMarkerIndex >= 0) {\n            const startSelectedMarker = markers[startSelectedMarkerIndex];\n            if (startSelectedMarker.isLocked) {\n              if (endCursorMoved > 0) {\n                end = startSelectedMarker.end;\n                selectedMarkersRange.endIndex = startSelectedMarkerIndex;\n                if (selectedMarkersRange.startIndex === -1) {\n                  selectedMarkersRange.startIndex = startSelectedMarkerIndex;\n                }\n                startSelectedMarkerIndex = -1;\n              } else {\n                end = startSelectedMarker.start;\n                markerWithStartTouchedIndex = startSelectedMarkerIndex;\n                startSelectedMarkerIndex = -1;\n              }\n            }\n          }\n        }\n\n        if (selectionEnd !== end) {\n          textarea.selectionEnd = end;\n        }\n        if (selectionStart !== start) {\n          textarea.selectionStart = start;\n        }\n\n        const newSelection = withInEditMarkerIndex({\n          markers,\n\n          selectionStart: start,\n          selectionEnd: end,\n\n          prevMarkerIndex,\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          nextMarkerIndex,\n        });\n\n        mutableRef.current.selection = newSelection;\n\n        onInEditMarkerChange &&\n          onInEditMarkerChange({\n            target: textarea,\n            value,\n            markers,\n            inEditMarkerIndex: newSelection.inEditMarkerIndex,\n            oldInEditMarkerIndex: prevSelection?.inEditMarkerIndex,\n          });\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            ...newSelection,\n          });\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          {...restProps}\n          value={value}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelection;\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {getMarkerSelections} from './withMarkerSelection';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n};\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  anchor,\n  type,\n  start,\n  end,\n  markerData = {},\n  data,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  anchor,\n  type,\n  start,\n  end,\n  markerData,\n  data,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if ((i === 0 || spaces[value[i - 1]]) && anchors[value[i]]) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const markerData = {};\n\n    const parts = anchor.parts;\n    for (let j = 0; j < parts.length; j++) {\n      const {key, startChar, endChars} = parts[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      markerData[key] = value.substring(partStart, i);\n      if (i >= value.length || endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n      if (endChars[value[i]] === CURRENT_END) {\n        i++;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      markerData,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser =\n  (parseMarkers, options) => (value, markerOffset, oldFirstMarker) => {\n    const markers = parseMarkers(value, options).map((marker, i) => {\n      const updatedMarker = createMarker({\n        isLocked: false,\n        ...(i === 0 && marker.start === 0 ? oldFirstMarker : {}),\n        ...marker,\n        uuid:\n          i === 0 && marker.start === 0 && oldFirstMarker\n            ? oldFirstMarker.uuid\n            : null,\n        start: marker.start + markerOffset,\n        end: marker.end + markerOffset,\n        value,\n      });\n      return updatedMarker;\n    });\n    return [value, markers];\n  };\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  let lengthChange = newValue.length - prevValue.length;\n  let inEditMarkerIndex = -1;\n\n  let newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    inEditMarkerIndex = midSelectedMarkerIndex;\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end: selectionEnd,\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n      lengthChange = insertedText.length;\n      newValue =\n        prevValue.substring(0, selectionStart) +\n        insertedText +\n        prevValue.substring(selectionEnd);\n    }\n    newMarkers.push(\n      ...markers.slice(midSelectedMarkerIndex + 1).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }))\n    );\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      inEditMarkerIndex = markerWithEndTouchedIndex;\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex + 1));\n    } else if (endSelectedMarkerIndex >= 0) {\n      inEditMarkerIndex = endSelectedMarkerIndex;\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n      if (!endSelectedMarker.isLocked) {\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart,\n        });\n      } else {\n        selectionStart = selectionEnd = endSelectedMarker.end;\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex + 1));\n        lengthChange = insertedText.length;\n        newValue =\n          prevValue.substring(0, selectionStart) +\n          insertedText +\n          prevValue.substring(selectionEnd);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker && !inEditMarker.isLocked) {\n    const startParse = inEditMarker.start;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(\n      toParse,\n      startParse,\n      inEditMarker // will just update him and should be returned as first element\n    );\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    newMarkers = [\n      ...newMarkers.slice(0, inEditMarkerIndex),\n      ...parsedMarkers,\n      ...newMarkers.slice(inEditMarkerIndex + 1),\n    ];\n  } else {\n    const startParse =\n      prevMarkerIndex >= 0 ? newMarkers[prevMarkerIndex].end : 0;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(toParse, startParse);\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    const nextNewMarkers = [];\n    if (prevMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(0, prevMarkerIndex + 1));\n    }\n    nextNewMarkers.push(...parsedMarkers);\n    if (nextMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(nextMarkerIndex));\n    }\n    newMarkers = nextNewMarkers;\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst withMarkerParser = ({\n  markerParser = parseMarkers,\n  markerParserOptions = {\n    version: 0,\n    anchors: [\n      {\n        anchorChar: '@',\n        type: 'person',\n        parts: [\n          {\n            key: 'username',\n          },\n        ],\n      },\n      {\n        anchorChar: '#',\n        type: 'rfi',\n        parts: [\n          {\n            key: 'rifId',\n          },\n        ],\n      },\n    ],\n  },\n} = {}) => {\n  if (markerParser === parseMarkers) {\n    const anchors = {};\n    markerParserOptions.anchors.forEach(anchor => {\n      const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n        key,\n        startChar,\n        endChars: {\n          ...(endChar ? {[endChar]: CURRENT_END} : spaces),\n          ...(parts[i + 1]?.startChar\n            ? {\n                [parts[i + 1].startChar]: NEXT_START,\n              }\n            : null),\n        },\n      }));\n      anchors[anchor.anchorChar] = {\n        ...anchor,\n        parts,\n      };\n    });\n    markerParserOptions = {...markerParserOptions, anchors};\n  }\n\n  markerParser = wrapMarkerParser(markerParser, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onMarkersChange,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers: (initMarkers ?? []).map(marker =>\n            createMarker({\n              ...marker,\n              isLocked: true,\n            })\n          ),\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const updateMarker = (marker, update) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const updateFunction = update => {\n                if (!update && update !== null) {\n                  return marker;\n                }\n\n                let newValue;\n                let newMarkers;\n                let newMarker = null;\n\n                if (update) {\n                  const {textValue, appendText = '', ...markerUpdates} = update;\n                  const hasNewText = textValue != null;\n                  const lengthChange = hasNewText\n                    ? textValue.length +\n                      appendText.length -\n                      (marker.end - marker.start)\n                    : 0;\n\n                  newMarkers = [...markers.slice(0, i)];\n                  newMarker = {\n                    ...marker,\n                    end: hasNewText\n                      ? marker.start + textValue.length\n                      : marker.end,\n                    ...markerUpdates,\n                  };\n                  newMarkers.push(newMarker);\n                  if (lengthChange) {\n                    newMarkers.push(\n                      ...markers.slice(i + 1).map(marker => ({\n                        ...marker,\n                        start: marker.start + lengthChange,\n                        end: marker.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newMarkers.push(...markers.slice(i + 1));\n                  }\n\n                  newValue = value;\n                  if (hasNewText) {\n                    newValue = [\n                      value.substring(0, marker.start),\n                      textValue,\n                      appendText,\n                      value.substring(marker.end),\n                    ].join('');\n\n                    setValue(newValue);\n                  }\n                  setMarkers(newMarkers);\n                } else {\n                  const {start: selectionStart, end: selectionEnd} = marker;\n                  const lengthChange = selectionEnd - selectionStart;\n\n                  newValue =\n                    value.substring(0, marker.start) +\n                    value.substring(marker.end);\n\n                  newMarkers = [\n                    ...markers.slice(0, i),\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      start: marker.start - lengthChange,\n                      end: marker.end - lengthChange,\n                    })),\n                  ];\n\n                  setValue(newValue);\n                  setMarkers(newMarkers);\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update(marker));\n              }\n              return updateFunction(update);\n            };\n            return {\n              updateMarker: (marker, update) =>\n                updateMarker(marker, marker => {\n                  if (typeof update === 'function') {\n                    update = update(marker);\n                  }\n                  if (update) {\n                    let isLocked;\n                    if (marker.isLocked) {\n                      isLocked = true;\n                      if (update.isLocked === false) {\n                        console.warn(\n                          'cannot unloack a locked marker. Will keep it locked!'\n                        );\n                      }\n                    } else {\n                      isLocked = update.isLocked ?? false;\n                    }\n                    return {\n                      isLocked,\n                      textValue: update.textValue,\n                      data:\n                        update.data === undefined ? marker.data : update.data,\n                      markerData: update.markerData ?? marker.markerData,\n                    };\n                  }\n                  return update;\n                }),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          const newSelectionEnd = textarea.selectionEnd;\n          const prevSelectionEnd =\n            prevValue.length - (newValue.length - newSelectionEnd);\n          const minSelectionEnd = Math.min(prevSelectionEnd, newSelectionEnd);\n\n          let selectionStart;\n          for (\n            selectionStart = 0;\n            selectionStart < minSelectionEnd &&\n            prevValue[selectionStart] === newValue[selectionStart];\n            selectionStart++\n          );\n\n          let selection = getMarkerSelections({\n            markers,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          const blockResult = blockMarkerUpdates(selection);\n\n          if (mutableRef.current.blockTimer) {\n            clearTimeout(mutableRef.current.blockTimer);\n            mutableRef.current.blockTimer = null;\n          }\n          if (blockResult.block) {\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            mutableRef.current.blockTimer = setTimeout(() => {\n              mutableRef.current.blockTimer = null;\n              try {\n                textarea.selectionStart = blockResult.selectionStart;\n                textarea.selectionEnd = blockResult.selectionEnd;\n                // eslint-disable-next-line no-empty\n              } catch (err) {}\n            });\n            e.preventDefault();\n            return false;\n          }\n\n          const insertedText = newValue.substring(\n            selectionStart,\n            newSelectionEnd\n          );\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {newValue: parsedValue, newMarkers: parsedMarkers} = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          if (parsedValue !== newValue) {\n            console.error(\n              `OOPS! input tracking is broken. Expected \"${newValue}\" got \"${parsedValue}\"`\n            );\n          }\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const newCursorPosition = newSelectionEnd; // might need to be refined!!!\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs(ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const mouseEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('mouseOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: false,\n        type,\n      });\n    }\n  };\n  const mouseLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('mouseOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = ({start, delta} = {}) => {\n    delta = delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else {\n      markersHandlers.focus(marker.end + delta);\n    }\n  };\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onMouseEnter={() => mouseEnter(i)}\n        onMouseLeave={mouseLeave}\n        onPointerDown={focus}\n        onPointerUp={focus}\n        onClick={focus}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onPointerEnter: () => mouseEnter(i),\n              onPointerLeave: mouseLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({marker})}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultLineHeight = '135%',\n  defaultBackgroundColor = 'white',\n  classNameGetters = defaultClassNameGetters,\n} = {}) => {\n  classNameGetters = {...defaultClassNameGetters, ...classNameGetters};\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          lineHeight = defaultLineHeight,\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.markers[e.inEditMarkerIndex];\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div id={id} className=\"textarea-container\" style={{backgroundColor}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              style={{\n                ...restProps.style,\n                lineHeight: restProps.style?.lineHeight ?? lineHeight,\n              }}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div className=\"textarea-with-resize-container\">\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nexport const TOTAL_HIDE = 1;\nexport const SKIP_HIDE = false;\nexport const DEFAULT_HIDE = true;\n\nexport const VISIBLE = true;\nexport const NOT_VISIBLE = false;\nexport const TOGGLE_VISIBLITY = 'toggle';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst wrapHideAction =\n  (baseHideAction = () => DEFAULT_HIDE) =>\n  ({markerUuid, visiblityStack, requestedHideType}) => {\n    const hideOrNewVisiblityStack = baseHideAction({\n      markerUuid,\n      visiblityStack,\n    });\n    if (Array.isArray(hideOrNewVisiblityStack)) {\n      return hideOrNewVisiblityStack;\n    }\n    if (hideOrNewVisiblityStack === SKIP_HIDE) {\n      return visiblityStack;\n    }\n    if (hideOrNewVisiblityStack === TOTAL_HIDE || !requestedHideType) {\n      return [];\n    }\n    return visiblityStack.filter(({type}) => type !== requestedHideType);\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visibile, labelLineIndex, hideAction}) => {\n            hideAction = wrapHideAction(hideAction);\n            const markerUuid = marker?.uuid || marker;\n            if (!visibile && !markerUuid) {\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  const newCurrMarkerDataStack = hideAction({\n                    markerUuid,\n                    visiblityStack: tipsDataStack[markerUuid],\n                    requestedHideType: type,\n                  });\n                  if (newCurrMarkerDataStack.length) {\n                    newTipsDataStack[markerUuid] = newCurrMarkerDataStack;\n\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              visibile =\n                visibile === TOGGLE_VISIBLITY\n                  ? !tipsDataStack[markerUuid]?.find(data => data.type === type)\n                  : Boolean(visibile);\n\n              if (!visibile) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (!oldDataStack) {\n                  return visibleTipsSettings;\n                }\n                const newCurrMarkerDataStack = hideAction({\n                  markerUuid,\n                  visiblityStack: oldDataStack,\n                  requestedHideType: type,\n                });\n\n                if (newCurrMarkerDataStack.length) {\n                  const lastTipData =\n                    newCurrMarkerDataStack[newCurrMarkerDataStack.length - 1];\n                  return {\n                    data: {\n                      ...tipsData,\n                      [markerUuid]: {\n                        type: lastTipData.type,\n                        labelLineIndex: lastTipData.labelLineIndex,\n                        focus: tipsData[markerUuid].focus,\n                      },\n                    },\n                    dataStack: {\n                      ...tipsDataStack,\n                      [markerUuid]: newCurrMarkerDataStack,\n                    },\n                  };\n                }\n\n                const newTipsData = {...tipsData};\n                delete newTipsData[markerUuid];\n\n                const newDataStack = {...tipsDataStack};\n                delete newDataStack[markerUuid];\n\n                return {\n                  data: newTipsData,\n                  dataStack: newDataStack,\n                };\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {markers, inEditMarkerIndex, oldInEditMarkerIndex} = e;\n              const inEditMarker = markers[inEditMarkerIndex];\n              const oldInEditMarker = markers[oldInEditMarkerIndex];\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visibile: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker) {\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visibile: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst BaseTextArea = React.forwardRef(\n  ({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <textarea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  }\n);\n\nexport default BaseTextArea;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visibile: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visibile: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      const onInEditMarkerChange = e => {\n        const inEditMarker = e.markers[e.inEditMarkerIndex];\n        const prevInEditMarker = mutableRef.current.inEditMarker;\n        if (prevInEditMarker && prevInEditMarker.uuid !== inEditMarker?.uuid) {\n          mutableRef.current.updateTipVisibility({\n            visibile: false,\n            type: 'keyboard',\n          });\n        }\n        mutableRef.current.inEditMarker = inEditMarker;\n        onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={onInEditMarkerChange}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport {\n  DEFAULT_HIDE,\n  SKIP_HIDE,\n  TOGGLE_VISIBLITY,\n  TOTAL_HIDE,\n} from './withTips';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const clickListener = e => {\n        let elem = e.target;\n        let onTextArea = false;\n        let onTip = false;\n        let onMarker = false;\n        while (elem) {\n          onTextArea = elem.id === id;\n          onTip = elem.dataset?.tipForTextarea === id;\n          onMarker = elem.dataset?.tipAnchorForTextarea === id;\n          if (onTextArea || onTip || onMarker) {\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!onTextArea && !onTip && !onMarker) {\n          mutable.updateTipVisibility({\n            visibile: false,\n          });\n          e.preventDefault();\n        } else {\n          const anchorMarkerUuid = onMarker && elem.dataset.tipAnchorForMarker;\n          mutable.updateTipVisibility({\n            visibile: false,\n            type: 'clickOnTip',\n            hideAction: ({markerUuid, visiblityStack}) => {\n              if (markerUuid !== anchorMarkerUuid) {\n                return DEFAULT_HIDE;\n              }\n              return SKIP_HIDE;\n            },\n          });\n          if (onMarker) {\n            mutable.updateTipVisibility({\n              marker: anchorMarkerUuid,\n              visibile: TOGGLE_VISIBLITY,\n              type: 'clickOnTip',\n              hideAction: () => TOTAL_HIDE,\n            });\n          } else if (onTip) {\n            mutable.updateTipVisibility({\n              marker: elem.dataset.tipForMarker,\n              visibile: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', clickListener);\n      return () => document.removeEventListener('click', clickListener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import {useRef} from 'react';\n\nconst usePrev = value => {\n  const ref = useRef(undefined);\n  const preValue = ref.current;\n  ref.current = value;\n  return preValue;\n};\n\nexport default usePrev;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport AbortController from 'abort-controller';\n\nimport withMarkerParser from './withMarkerParser';\nimport withMarkableTextArea from './withMarkableTextArea';\nimport withResize from './withResize';\nimport withSelectionChange from './withSelectionChange';\nimport withMarkerSelection from './withMarkerSelection';\nimport withTips from './withTips';\n\nimport BaseTextArea from '../components/BaseTextArea';\nimport useDebounceValue from '../hooks/useDebounceValue';\nimport withFocusTipOnDown from './withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from './withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport usePrev from '../hooks/usePrev';\nimport withBlockUndoRedoAndDragDropText from './withBlockUndoRedoAndDragDropText';\n\nconst getDetailComponent = ({\n  Component,\n  NotFoundComponent,\n  loader,\n  preProcessMarkerData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n}) => {\n  const cache = getCache();\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  return ({marker, updateMarker}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error}, setResult] = useState({});\n\n    const {data, markerData} = marker;\n    const loadData = preProcessMarkerData(markerData);\n    const cacheKey = getCacheKey(loadData);\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.updateMarker = updateMarker;\n    mutableRef.current.cacheKey = cacheKey;\n\n    useEffect(() => {\n      if (data || data === null) {\n        return null;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.updateMarker({\n          data: cachedData,\n        });\n        setResult({});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResult({loading: true});\n      loader(mutableRef.current.loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.updateMarker({\n              data: result,\n            });\n            setResult({});\n          }\n        })\n        .catch(error => {\n          if (error.aborted) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResult({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, data]);\n\n    if (loading) {\n      return <LoaderComponent loadData={loadData} />;\n    }\n\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          marker={marker}\n          updateMarker={updateMarker}\n        />\n      );\n    }\n\n    if (data) {\n      return (\n        <Component data={data} marker={marker} updateMarker={updateMarker} />\n      );\n    }\n\n    return null;\n  };\n};\n\nconst modulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nconst getSearchResultPickerComponent = ({\n  ItemComponent,\n  NoItemsComponent = () => 'No matching entries found',\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    updateMarker,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        selectedItem: data,\n        marker,\n      });\n      updateMarker({\n        data,\n        ...update,\n        isLocked: update.isLocked ?? true,\n      });\n      setTimeout(() => onHide());\n    };\n\n    const focused =\n      focusedIndex == null ? null : modulo(focusedIndex, results.length);\n    const toFocus = usePrev(focused) !== focused ? focused : null;\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n        }\n      }\n    };\n\n    if (!results.length) {\n      return <NoItemsComponent marker={marker} />;\n    }\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={\n                toFocus === i\n                  ? elem => {\n                      if (elem?.focus) {\n                        elem.focus();\n                      }\n                    }\n                  : null\n              }\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent item={item} />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nconst getSingleTip = ({\n  tipOptions: {\n    search: {\n      ResultsComponent: SearchResultsComponent,\n      ResultItemComponent: SearchResultsItemComponent,\n      resultItemComponentOnSelect,\n      NoResultItemComponent,\n      loader: searchFunction,\n      preProcessMarkerData: preProcessMarkerDataForSearch = markerData =>\n        markerData,\n      getCacheKey: getSearchCacheKey = searchData => JSON.stringify(searchData),\n      LoaderComponent: SearchLoaderComponent,\n      ErrorComponent: SearchErrorComponent,\n      debounceDuration = 350,\n    },\n    details: {\n      Component: DetailComponent,\n      loader: loadSingleFunction,\n      NotFoundComponent: DetailNotFoundComponent,\n      preProcessMarkerData: preProcessMarkerDataForSingleLoad = markerData =>\n        markerData,\n      getCacheKey: getDetailsCacheKey = searchData =>\n        JSON.stringify(searchData),\n      LoaderComponent: DetailLoaderComponent,\n      ErrorComponent: DetailErrorComponent,\n    },\n  },\n  LoaderComponent: CommonLoaderComponent,\n  ErrorComponent: CommonErrorComponent,\n  getCache,\n}) => {\n  DetailComponent = getDetailComponent({\n    Component: DetailComponent,\n    NotFoundComponent: DetailNotFoundComponent,\n    loader: loadSingleFunction,\n    getCacheKey: getDetailsCacheKey,\n    preProcessMarkerData: preProcessMarkerDataForSingleLoad,\n    LoaderComponent: DetailLoaderComponent || CommonLoaderComponent,\n    ErrorComponent: DetailErrorComponent || CommonErrorComponent,\n    getCache,\n  });\n\n  SearchResultsComponent = SearchResultsItemComponent\n    ? getSearchResultPickerComponent({\n        ItemComponent: SearchResultsItemComponent,\n        NoItemsComponent: NoResultItemComponent,\n        ContainerComponent: SearchResultsComponent,\n        onSelect: resultItemComponentOnSelect,\n      })\n    : SearchResultsComponent;\n\n  const cache = getCache();\n\n  const LoaderComponent = SearchLoaderComponent || CommonLoaderComponent;\n  const ErrorComponent = SearchErrorComponent || CommonErrorComponent;\n\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    const {markerData} = marker;\n    const searchData = preProcessMarkerDataForSearch(markerData) ?? null;\n\n    const [{loading, error, results}, setResults] = useState({});\n\n    mutableRef.current.isLocked = marker.isLocked;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.searchData = searchData;\n\n    const cacheKey = useDebounceValue(\n      searchData != null ? getSearchCacheKey(searchData) : null,\n      debounceDuration\n    );\n    useEffect(() => {\n      if (mutableRef.current.isLocked) {\n        setResults({});\n        return null;\n      }\n      mutableRef.current.cacheKey = cacheKey;\n      if (cacheKey === null) {\n        mutableRef.current.onHide();\n        return null;\n      }\n\n      const cachedResults = cache.getItem(cacheKey);\n      if (cachedResults) {\n        setResults({results: cachedResults});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResults({loading: true});\n      searchFunction(mutableRef.current.searchData, abortCtrl.signal)\n        .then(results => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          cache.setItem(cacheKey, results);\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({results});\n          }\n        })\n        .catch(error => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          if (error.aborted) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey]); // , marker.isLocked, onHide, searchData\n\n    if (marker.isLocked) {\n      return (\n        <DetailComponent\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          updateMarker={update => {\n            markersHandlers.updateMarker(marker, update);\n          }}\n        />\n      );\n    }\n\n    if (loading) {\n      return <LoaderComponent loadData={searchData} />;\n    }\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n    if (!results) {\n      return null;\n    }\n    return (\n      <SearchResultsComponent\n        results={results}\n        marker={marker}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        updateMarker={update => {\n          markersHandlers.updateMarker(marker, update);\n        }}\n      />\n    );\n  };\n};\n\nconst getTip = ({\n  tipsOptionsByType,\n  LoaderComponent,\n  ErrorComponent,\n  debounceDuration,\n  getCache,\n}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = getSingleTip({\n      tipOptions: tipsOptionsByType[type],\n      LoaderComponent,\n      ErrorComponent,\n      debounceDuration,\n      getCache,\n    });\n  }\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nconst defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nconst wrapGetCache = getCache => () => {\n  const cache = getCache();\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  debounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  lineHeight,\n}) => {\n  getCache = getCache ? wrapGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = {};\n  const anchors = [];\n  baseAnchors.forEach(anchor => {\n    tipsOptionsByType[anchor.type] = {\n      search: anchor.searchOptions,\n      details: anchor.detailsOptions,\n    };\n    anchors.push({\n      anchorChar: anchor.anchorChar,\n      type: anchor.type,\n      parts: anchor.parts,\n    });\n  });\n  return withId(getId)(\n    withTips({\n      hideOnEscape: hideTipOnEscape,\n      TipComponent: getTip({\n        tipsOptionsByType,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n      }),\n    })(\n      withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n        withFocusTipOnDown(\n          withMarkableTextArea({\n            classNameGetters,\n            defaultBackgroundColor: backgroundColor,\n            defaultLineHeight: lineHeight,\n          })(\n            withResize(\n              withMarkerParser({\n                markerParserOptions: {\n                  version,\n                  anchors,\n                },\n              })(\n                withMarkerSelection(\n                  withSelectionChange(\n                    withBlockUndoRedoAndDragDropText(BaseTextArea)\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({updateMarker}) => {\n  const [countDown, setCountDown] = useState(4);\n  const updateMarkerRef = useRef();\n  updateMarkerRef.current = updateMarker;\n  useEffect(() => {\n    const t = setInterval(() => {\n      setCountDown(countDown => countDown - 1);\n    }, 1000);\n    return () => clearInterval(t);\n  }, []);\n  const done = countDown === 0;\n  useEffect(() => {\n    if (done) {\n      updateMarkerRef.current(null);\n    }\n  }, [done]);\n  return <b>Person not found! will delete in {countDown}</b>;\n};\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  anchors: [\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultItemComponent: PersonSearchResultItem,\n        NoResultItemComponent: () => 'No matching people found',\n        resultItemComponentOnSelect: ({selectedItem: person}) => ({\n          textValue: person.name,\n          markerData: {\n            id: person.id,\n          },\n        }),\n        loader: ({name}, signal) => personSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: PersonDetails,\n        NotFoundComponent: NotFoundPersonComponent,\n        loader: ({id}, signal) => personDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultsComponent: ({ResultListComponent, ...props}) => (\n          <p>\n            <h5>Found the following things:</h5>\n            <ResultListComponent {...props} />\n          </p>\n        ),\n        ResultItemComponent: ThingSearchResultItem,\n        resultItemComponentOnSelect: ({selectedItem: thing}) => ({\n          textValue: thing.name,\n          markerData: {\n            id: thing.id,\n          },\n        }),\n        loader: ({name}, signal) => thingSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: ThingDetails,\n        loader: ({id}, signal) => thingDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useState} from 'react';\nimport classes from './App.module.css';\nimport SmartTextArea, {people, things} from './SmartTextArea';\n\nconst availablePpl = people.map(person => person.name).join(', ');\nconst availableThings = things.map(thing => thing.name).join(', ');\nconst App = () => {\n  const [markers, setMarkers] = useState([]);\n  const [inEditMarker, setInEditMarker] = useState([]);\n  return (\n    <div className={classes.container}>\n      <ul>\n        <li>\n          use @ to trigger person marker start. Available people to search:\n          <ul>\n            <li>{availablePpl}</li>\n          </ul>\n          people marker color is the default gray color\n        </li>\n        <li>\n          use # to trigger things marker start. Available things to search:\n          <ul>\n            <li>{availableThings}</li>\n          </ul>\n          things marker color is a custom orange color\n        </li>\n      </ul>\n      <SmartTextArea\n        className=\"smart-text-area\"\n        initValue={\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\n        }\n        initMarkers={[\n          {start: 0, end: 13, type: 'person', markerData: {id: 'mo'}},\n          {start: 46, end: 54, type: 'person', markerData: {id: 'john'}},\n          {start: 78, end: 86, type: 'person', markerData: {id: 'jane'}},\n          {start: 112, end: 117, type: 'person', markerData: {id: 'asdfg'}},\n          {start: 149, end: 153, type: 'thing', markerData: {id: 'fork'}},\n          {start: 155, end: 160, type: 'thing', markerData: {id: 'knife'}},\n          {start: 165, end: 170, type: 'thing', markerData: {id: 'spoon'}},\n        ]}\n        onMarkersChange={e => {\n          setMarkers(e.markers);\n        }}\n        onInEditMarkerChange={e => {\n          setInEditMarker(e.markers[e.inEditMarkerIndex]);\n        }}\n      />\n      <p>\n        <h5>Markers:</h5>\n        <pre>\n          {markers.map(marker => (\n            <div\n              className={\n                marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\n              }>\n              {JSON.stringify(marker, null, 3)}\n            </div>\n          ))}\n        </pre>\n      </p>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}