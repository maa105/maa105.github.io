{"version":3,"sources":["lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/hocs/withMarkerSelection.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withBaseTextArea.js","lib/hocs/withSmartTextArea/helpers/fortifyGetCache..js","lib/hocs/withSmartTextArea/helpers/defaultGetCache.js","lib/helpers/mapAndKeyBy.js","lib/helpers/searchArray.js","lib/hocs/withSmartTextArea/helpers/ensureLoaderIsAsync.js","lib/hocs/withSmartTextArea/hocs/withId.js","lib/hocs/withSmartTextArea/hocs/withStyle.js","lib/hocs/withSmartTextArea/builders/hook/buildDetailsDataLoaderHook.js","lib/hocs/withSmartTextArea/builders/component/buildDetailsComponent.js","lib/hooks/useDebounceValue.js","lib/hocs/withSmartTextArea/builders/hook/buildSearchDataLoaderHook.js","lib/hocs/withSmartTextArea/builders/hook/buildAutoSelectHook.js","lib/hocs/withSmartTextArea/builders/component/buildSearchComponent.js","lib/helpers/negativeSupportingModulo.js","lib/hocs/withSmartTextArea/builders/component/buildSearchResultsPickerComponent.js","lib/hocs/withSmartTextArea/builders/component/buildMarkerTipComponent.js","lib/hocs/withSmartTextArea/builders/component/buildTipComponent.js","lib/hocs/withSmartTextArea/index.js","lib/hocs/withSmartTextArea/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","withInEditMarkerIndex","selection","inEditMarkerIndex","midSelectedMarkerIndex","endSelectedMarkerIndex","markerWithEndTouchedIndex","getInEditMarkerIndex","getSelections","prevIndex","nextIndex","partsOrMarkers","selectionStart","selectionEnd","selectedRange","startIndex","endIndex","startSelectedIndex","endSelectedIndex","midSelectedIndex","startTouchedIndex","endTouchedIndex","getReturn","end","part","start","startTotallySelected","endTotallySelected","totalySelected","getMarkerSelections","markers","selectedMarkersRange","startSelectedMarkerIndex","markerWithStartTouchedIndex","prevMarkerIndex","nextMarkerIndex","getMarkerPartsSelections","marker","parts","selectedPartRange","startSelectedPartIndex","endSelectedPartIndex","midSelectedPartIndex","partWithStartTouchedIndex","partWithEndTouchedIndex","prevPartIndex","nextPartIndex","anchorIndex","anchorSelected","markerUuid","uuid","fixPartSelections","isSingleSelection","startCursorMoved","endCursorMoved","lastResolvedPartIndex","midSelectedPart","isLocked","lastResolvedPart","endSelectedPart","Math","max","min","fixMarkerSelections","midSelectedMarker","endSelectedMarker","newSelections","startSelectedMarker","withMarkerSelection","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","onInEditMarkerChange","restProps","innerRef","e","textarea","target","prevSelection","newSelectionStart","newSelectionEnd","newSelection","oldInEditMarkerIndex","blockPartUpdates","block","blockMarkerUpdates","partBlock","DEFAULT_END","newLines","spaces","createMarker","version","anchor","type","partsConfig","partsText","partsIds","partsData","round","random","Date","now","parseMarkers","options","anchors","j","partStart","partStartChar","key","startChar","endChars","partTextStart","partTextEnd","substring","isPartEnd","partEndChar","partEnd","push","endChar","anchorChar","wrapMarkerParser","markerOffset","map","prevValue","insertedText","markerParser","newMarkers","slice","updateMarkerParts","markerWithEndTouched","lengthChange","nextMarkers","newValue","inEditMarker","startParse","endParse","lastPossibleEndParse","newlyParsedInEditMarker","newParsedMarkers","oldInEditMarkerParts","oldInEditMarkerpartsIds","oldInEditMarkerPartsData","newInEditMarkerParts","oldPart","newPart","shouldLockPart","Boolean","newInEditMarker","splice","parsedMarkers","preProcessMarkerParserOptions","markerParserOptions","types","forEach","anchorConfig","getPartDelimitedText","partConfig","text","getPartTextLengthChange","initMarker","isMarkerLocked","undefined","withMarkerParser","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","disabled","imperativeRef","props","filter","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","deleteMarker","setCursor","findIndex","m","oldValue","oldMarkers","updateMarkerPart","partKey","partIndex","updateFunction","cursor","data","id","isLastPossiblePart","isLastPart","nextPartConfig","appendText","hasNewText","newParts","newMarker","join","childImperativeRef","useEffect","prevSelectionEnd","minSelectionEnd","blockResult","blockTimer","clearTimeout","setTimeout","err","preventDefault","parsedValue","newCursorPosition","properties","getCoordinatesAtPositions","positions","debug","el","document","querySelector","parentNode","removeChild","div","createElement","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","tipsZIndex","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","mouseEnter","timer","visible","showTip","hideTip","mouseLeave","focus","whereToFocus","delta","focusEnd","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onMouseEnter","onMouseLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","zIndex","constraints","to","renderTarget","renderElement","focusParent","onHide","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultBackgroundColor","baseClassNameGetters","classNameGetters","params","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","addEventListener","onKeyUpListener","removeEventListener","SKIP_HIDE","DEFAULT_HIDE","TOGGLE_VISIBLITY","withHideTipOnEscape","listener","wrapHideAction","baseHideAction","visiblityStack","requestedHideType","hideOrNewVisiblityStack","Array","isArray","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","hideAction","find","oldDataStack","newCurrMarkerDataStack","lastTipData","newTipsData","newDataStack","newTipsDataStack","oldInEditMarker","withFocusTipOnDown","tipData","stopPropagation","prevInEditMarker","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","clickListener","onTextArea","onTip","onMarker","dataset","tipForTextarea","tipAnchorForTextarea","anchorMarkerUuid","tipAnchorForMarker","tipForMarker","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","withBaseTextArea","React","fortifyGetCache","getCache","cache","getItem","cacheKey","error","setItem","defaultGetCache","mapAndKeyBy","array","mapFunction","keyFunction","item","keyed","searchArray","searchText","searchTextLowerCased","toLowerCase","includes","val","doesItemMatchSearch","ensureLoaderIsAsync","loader","ret","Promise","resolve","then","withId","getId","withStyle","defaultLineHeight","defaultWidth","buildDetailsDataLoaderHook","getLoadData","getCacheKey","loadData","shouldReloadData","isAbortError","currPartKey","loading","retry","setResultData","retryFunction","resultData","cachedData","abortCtrl","AbortController","signal","result","catch","abort","buildDetailsComponent","markerType","Component","NotFoundComponent","LoaderComponent","ErrorComponent","useDetailDataLoader","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","buildSearchDataLoaderHook","getSearchData","searchData","filterResults","debounceDuration","debouncedCacheKey","noSearch","results","resultsCacheKey","setResultsData","isResultForCurrentSearch","resultsData","cachedResults","buildAutoSelectHook","autoSelect","Error","hide","buildSearchComponent","detailsComponents","ZeroSearchResultsComponent","NoSearchComponent","ResultsComponent","useSearchDataLoader","useAutoSelect","negativeSupportingModulo","num","mod","buildSearchResultsPickerComponent","ItemComponent","ContainerComponent","ResultListComponent","onSelect","focusedIndex","setFocusedIndex","index","select","selectedItem","focused","focusedRef","getAttribute","removeAttribute","onKeyDown","next","tabIndex","buildMarkerTipComponent","tipOptions","details","searchComponents","search","ResultItemComponent","onItemSelect","baseAutoSelect","lastPartConfig","DetailsComponent","firstUnresolvedPartIndex","firstUnresolvedPartConfig","SearchComponent","buildTipComponent","tipsOptionsByType","ComponentsByType","withSmartTextArea","baseAnchors","hideTipOnEscape","aborted","message","anchorGetCache","anchorLoaderComponent","anchorErrorComponent","anchorDebounceDuration","searchLoader","detailsLoader","searchConfig","detailsConfig","searchOptions","detailsOptions","filterData","bind","searchFunction","findInSearchData","loadDetails","loadDetail","DisplayComponent","DetailComponent","PersonDetails","person","src","imageUrl","alt","PersonSearchResultItem","name","people","personSearch","reject","trim","toLocaleLowerCase","personDetails","ThingDetails","thing","ThingSearchResultItem","things","thingSearch","thingDetails","NotFoundPersonComponent","countDown","setCountDown","setInterval","clearInterval","done","capitalize","str","substr","toUpperCase","SmartTextArea","defaultClassName","NoResultItemComponent","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"8SAceA,EAdG,WAAc,IAAD,uBAATC,EAAS,yBAATA,EAAS,gBAC7B,IAAMC,EAAY,SAAAC,GAChB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAKI,OAAQD,IAAK,CACpC,IAAME,EAAML,EAAKG,GACE,oBAARE,EACTA,EAAIH,GACKG,IACTA,EAAIC,QAAUJ,KAIpB,OAAOD,GC6BMM,EA9BgB,SAACC,EAAqBC,EAAMC,GACzD,IAAMC,EAAaC,iBAAO,IACpBX,EAAYW,iBAAO,IACnBC,EAAS,WACb,IAZYR,EAAKS,EAYXC,EAAM,2BACPJ,EAAWL,QAAQU,UACnBL,EAAWL,QAAQA,SAExBL,EAAUK,QAAUS,EAhBHD,EAiBWC,EAhBX,oBADLV,EAiBLG,GAfPH,EAAIS,GACKT,IACTA,EAAIC,QAAUQ,IAwBhB,OARAG,+BACE,SAAAC,GACEP,EAAWL,QAAQA,QAAUY,EAC7BL,MAEFJ,EACAC,GAEK,CACL,SAAAQ,GACEP,EAAWL,QAAQU,SAAWE,EAC9BL,KAEFZ,EACAU,I,wECzBEQ,EAAwB,SAAAC,GAC5B,IAAMC,EATqB,SAAAD,GAAS,OACpCA,EAAUE,wBAA0B,EAChCF,EAAUE,uBACVF,EAAUG,wBAA0B,EACpCH,EAAUG,uBACVH,EAAUI,2BAA6B,EACvCJ,EAAUI,2BACT,EAEqBC,CAAqBL,GAE/C,OADAA,EAAUC,kBAAoBA,EACvBD,GAGIM,EAAgB,SAAC,GA2B5B,IAvBK,IAODC,EACAC,EAXJC,EAGI,EAHJA,eACAC,EAEI,EAFJA,eACAC,EACI,EADJA,aAEMC,EAAgB,CAACC,YAAa,EAAGC,UAAW,GAC9CC,GAAsB,EACtBC,GAAoB,EACpBC,GAAoB,EACpBC,GAAqB,EACrBC,GAAmB,EAGnBpC,EAAI,EAEFqC,EAAY,yBAAO,CACvBR,gBACAG,qBACAC,mBACAC,mBACAC,oBACAC,kBACAZ,YACAC,WACE,UAACA,SAAD,SAAe,IAAMC,EAAezB,QAAU,EAA9C,UAAkDwB,SAAlD,SAAgE,IAKlEzB,EAAI0B,EAAezB,QAAUyB,EAAe1B,GAAGsC,IAAMX,EACrD3B,KAGFwB,EAAYxB,EAAI,EAEhB,IAAIuC,EAAOb,EAAe1B,GAC1B,IAAKuC,EACH,OAAOF,IAGT,GAAIE,EAAKD,MAAQX,IACfS,EAAkBZ,EAAYxB,EAC9BA,MACAuC,EAAOb,EAAe1B,KAEpB,OAAOqC,IAIX,GAAIE,EAAKC,OAASZ,EAKhB,OAJAH,EAAYzB,EACRuC,EAAKC,QAAUZ,IACjBO,EAAoBnC,GAEfqC,IAGT,IAAII,EACFd,GAAkBY,EAAKC,OAASD,EAAKC,MAAQZ,EAC3Cc,EACFf,EAAiBY,EAAKD,KAAOC,EAAKD,KAAOV,EACvCe,EAAiBF,GAAwBC,EAG7C,IAFqBD,IAAyBC,EAK5C,OAFAR,EAAmBlC,EACnByB,EAAYzB,EAAI,EACTqC,IAET,IAAKM,EAAgB,CACnB,GAAIF,EAGF,OAFAT,EAAqBhC,EACrByB,EAAYzB,EAAI,EACTqC,IAMT,GAHAJ,EAAmBjC,EACnBA,MACAuC,EAAOb,EAAe1B,IAEpB,OAAOqC,IAQT,GALAI,EACEd,GAAkBY,EAAKC,OAASD,EAAKC,MAAQZ,EAC/Cc,EAAqBf,EAAiBY,EAAKD,KAAOC,EAAKD,KAAOV,IAC9De,EAAiBF,GAAwBC,GAYvC,OATID,GACFhB,EAAYzB,EAAI,EAChBgC,EAAqBhC,IAErByB,EAAYzB,EACRuC,EAAKC,QAAUZ,IACjBO,EAAoBnC,IAGjBqC,IAMX,IAHAR,EAAcC,WAAa9B,EAE3BA,IACOA,EAAI0B,EAAezB,OAAQD,IAQhC,GALAyC,EACEd,IAHFY,EAAOb,EAAe1B,IAGGwC,OAASD,EAAKC,MAAQZ,EAC/Cc,EAAqBf,EAAiBY,EAAKD,KAAOC,EAAKD,KAAOV,IAC9De,EAAiBF,GAAwBC,GAEpB,CACfD,GACFhB,EAAYzB,EAAI,EAChBgC,EAAqBhC,IAErByB,EAAYzB,EACRuC,EAAKC,QAAUZ,IACjBO,EAAoBnC,IAGxB,MAIJ,OADA6B,EAAcE,SAAW/B,EAClBqC,KAGIO,EAAsB,SAAC,GAI7B,IAHLC,EAGI,EAHJA,QACAlB,EAEI,EAFJA,eACAC,EACI,EADJA,aAEA,EASIL,EAAc,CAChBG,eAAgBmB,EAChBlB,iBACAC,iBAXekB,EADjB,EACEjB,cACoBkB,EAFtB,EAEEf,mBACkBZ,EAHpB,EAGEa,iBACkBd,EAJpB,EAIEe,iBACmBc,EALrB,EAKEb,kBACiBd,EANnB,EAMEe,gBACWa,EAPb,EAOEzB,UACW0B,EARb,EAQEzB,UAMF,OAAOT,EAAsB,CAC3B6B,UACAC,uBACAC,2BACA3B,yBACAD,yBACA6B,8BACA3B,4BACA4B,kBACAC,qBAISC,EAA2B,SAAC,GAIlC,IAHLC,EAGI,EAHJA,OACAzB,EAEI,EAFJA,eACAC,EACI,EADJA,aAEMyB,EAAQD,EAAOC,MAErB,EASI9B,EAAc,CAChBG,eAAgB2B,EAChB1B,iBACAC,iBAXe0B,EADjB,EACEzB,cACoB0B,EAFtB,EAEEvB,mBACkBwB,EAHpB,EAGEvB,iBACkBwB,EAJpB,EAIEvB,iBACmBwB,EALrB,EAKEvB,kBACiBwB,EANnB,EAMEvB,gBACWwB,EAPb,EAOEpC,UACWqC,EARb,EAQEpC,UAOIqC,EAAcT,EAAM,GAAGb,MAAQ,EAC/BuB,EACJpC,GAAkBmC,GAAelC,EAAekC,EAElD,MAAO,CACLE,WAAYZ,EAAOa,KACnBZ,MAAOD,EAAOC,MACdC,oBACAC,yBACAC,uBACAC,uBACAC,4BACAC,0BACAC,gBACAC,gBACAE,mBAIEG,EAAoB,SAAC,GAOpB,IANLd,EAMI,EANJA,OACAzB,EAKI,EALJA,eACAC,EAII,EAJJA,aACAuC,EAGI,EAHJA,kBACAC,EAEI,EAFJA,iBACAC,EACI,EADJA,eAEA,EAKIlB,EAAyB,CAC3BC,SACAzB,iBACAC,iBAPA6B,EADF,EACEA,qBACAD,EAFF,EAEEA,qBACAD,EAHF,EAGEA,uBACAD,EAJF,EAIEA,kBAMID,EAAQD,EAAOC,MACfiB,EAAwBlB,EAAOkB,sBACrC,GAAIb,GAAwB,EAAG,CAC7B,IAAMc,EAAkBlB,EAAMI,GAE9B,GAAIc,EAAgBC,SAAU,CAC5B,GAAIL,EACF,OAAIC,EAAmB,EACd,CACLzC,eAAgB4C,EAAgB/B,MAChCZ,aAAc2C,EAAgB/B,OAG3B,CACLb,eAAgB4C,EAAgBjC,IAChCV,aAAc2C,EAAgBjC,KAGlC,IAAMmC,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL3C,eAAgB4C,EAAgB/B,MAChCZ,aAAc6C,EAAiBnC,MAIrC,GAAIkB,GAAwB,EAAG,CAC7B,IAAMkB,EAAkBrB,EAAMG,GAE9B,GAAIkB,EAAgBF,SAAU,CAC5B,IAAMC,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL3C,eACEyC,EAAmB,EAAIM,EAAgBpC,IAAMoC,EAAgBlC,MAC/DZ,aAAc+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,OAK5D,GAAIiB,GAA0B,GACFF,EAAME,GAEViB,SAAU,CAC9B,IAAMC,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL3C,eAAgBgD,KAAKE,IAAIlD,EAAgB0B,EAAM,GAAGb,OAClDZ,aACEyC,EAAiB,EAAIhB,EAAM,GAAGb,MAAQiC,EAAiBnC,KAK/D,GACEgB,EAAkBvB,UAAY,GAC9BuB,EAAkBvB,SAAWuC,EAAwB,EACrD,CACA,IAAMG,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL3C,iBACAC,aAAc+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,MAI1D,MAAO,CACLX,iBACAC,iBAIEkD,EAAsB,SAAC,GAOtB,IANLjC,EAMI,EANJA,QACAlB,EAKI,EALJA,eACAC,EAII,EAJJA,aACAuC,EAGI,EAHJA,kBACAC,EAEI,EAFJA,iBACAC,EACI,EADJA,eAEA,EAIIzB,EAAoB,CACtBC,UACAlB,iBACAC,iBANAT,EADF,EACEA,uBACAC,EAFF,EAEEA,uBACA2B,EAHF,EAGEA,yBAOF,GAAI5B,GAA0B,EAAG,CAC/B,IAAM4D,EAAoBlC,EAAQ1B,GAClC,GAAI4D,EAAkBP,SAAU,CAC9B,GAAIL,EAAmB,CACrB,IAAMlD,EACJmD,EAAmB,EACfW,EAAkBvC,MAClBuC,EAAkBzC,IACxB,MAAO,CACLX,eAAgBV,EAChBW,aAAcX,GAGlB,MAAO,CACLU,eAAgBoD,EAAkBvC,MAClCZ,aAAcmD,EAAkBzC,KAGpC,OAAO4B,EAAkB,CACvBd,OAAQ2B,EACRpD,iBACAC,eACAuC,oBACAC,mBACAC,mBAGJ,GAAIjD,GAA0B,EAAG,CAC/B,IAAM4D,EAAoBnC,EAAQzB,GAClC,GAAI4D,EAAkBR,SAElB7C,EADEyC,EAAmB,EACJY,EAAkBxC,MAElBwC,EAAkB1C,QAEhC,CACL,IAAM2C,EAAgBf,EAAkB,CACtCd,OAAQ4B,EACRrD,iBACAC,eACAuC,oBACAC,mBACAC,mBAEF1C,EAAiBsD,EAActD,eAC/BC,EAAeqD,EAAcrD,cAGjC,GAAImB,GAA4B,EAAG,CACjC,IAAMmC,EAAsBrC,EAAQE,GACpC,GAAImC,EAAoBV,SAEpB5C,EADEyC,EAAiB,EACJa,EAAoB5C,IAEpB4C,EAAoB1C,UAEhC,CACL,IAAMyC,EAAgBf,EAAkB,CACtCd,OAAQ8B,EACRvD,iBACAC,eACAuC,oBACAC,mBACAC,mBAEF1C,EAAiBsD,EAActD,eAC/BC,EAAeqD,EAAcrD,cAGjC,MAAO,CACLD,iBACAC,iBAqGWuD,EAjGa,eAACC,EAAD,uDAAY,WAAZ,OAC1BC,sBACE,WAQEnF,GACI,IAPiBoF,EAOlB,EAPDC,kBACA5E,EAMC,EANDA,MACAkC,EAKC,EALDA,QACA2C,EAIC,EAJDA,qBACGC,EAGF,iBACGjF,EAAaC,iBAAO,IAEpBiF,EAAWjF,mBAuEjB,OACE,cAAC2E,EAAD,yBACElF,IAAKN,EAAUM,EAAKwF,IAChBD,GAFN,IAGE9E,MAAOA,EACPkC,QAASA,EACT0C,kBA3EsB,SAAAI,GAExB,IAAMC,EAAWD,EAAEE,OAEblE,EAAiBiE,EAASjE,eAC1BC,EAAegE,EAAShE,aAExBuC,EAAoBxC,IAAmBC,EAEvCkE,EAAgBtF,EAAWL,QAAQc,UACnCmD,EACH0B,IAA8B,OAAbA,QAAa,IAAbA,OAAA,EAAAA,EAAenE,kBAAmBA,EAEhDA,EAAiBmE,EAAcnE,eAD/B,EAEA0C,EACHyB,IAA8B,OAAbA,QAAa,IAAbA,OAAA,EAAAA,EAAelE,gBAAiBA,EAE9CA,EAAekE,EAAclE,aAD7B,EAGN,EAGIkD,EAAoB,CACtBjC,UACAlB,iBACAC,eACAuC,oBACAC,mBACAC,mBARgB0B,EADlB,EACEpE,eACcqE,EAFhB,EAEEpE,aAUEA,IAAiBoE,IACnBJ,EAAShE,aAAeoE,GAEtBrE,IAAmBoE,IACrBH,EAASjE,eAAiBoE,GAG5B,IAAME,EAAejF,EAAsB,aACzC6B,UAEAlB,eAAgBoE,EAChBnE,aAAcoE,GAEXpD,EAAoB,CACrBC,UACAlB,eAAgBoE,EAChBnE,aAAcoE,MAIlBxF,EAAWL,QAAQc,UAAYgF,EAE/BT,GACEA,EAAqB,CACnBK,OAAQD,EACRjF,QACAkC,UACA3B,kBAAmB+E,EAAa/E,kBAChCgF,qBAAoB,OAAEJ,QAAF,IAAEA,OAAF,EAAEA,EAAe5E,oBAGzCoE,GACEA,EAA4B,2BACvBK,GACAM,YC7dTE,EAAmB,SAAC,GAA4C,IAA3C/C,EAA0C,EAA1CA,OAAQzB,EAAkC,EAAlCA,eAAgBC,EAAkB,EAAlBA,aACjD,EAMIuB,EAAyB,CAC3BC,SACAzB,iBACAC,iBARA6B,EADF,EACEA,qBACAD,EAFF,EAEEA,qBACAD,EAHF,EAGEA,uBACAD,EAJF,EAIEA,kBACAS,EALF,EAKEA,eAMIV,EAAQD,EAAOC,MACfiB,EAAwBlB,EAAOkB,sBACrC,GAAIb,GAAwB,EAAG,CAC7B,IAAMc,EAAkBlB,EAAMI,GAE9B,GAAIc,EAAgBC,SAAU,CAC5B,IAAMC,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL8B,OAAO,EACPzE,eAAgB4C,EAAgB/B,MAChCZ,aAAc6C,EAAiBnC,MAIrC,GAAIkB,GAAwB,EAAG,CAC7B,IAAMkB,EAAkBrB,EAAMG,GAE9B,GAAIkB,EAAgBF,SAAU,CAC5B,IAAMC,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL8B,OAAO,EACPzE,eAAgB+C,EAAgBlC,MAChCZ,aAAc+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,OAK5D,GACEgB,EAAkBvB,UAAY,GAC9BuB,EAAkBvB,SAAWuC,EAAwB,EACrD,CACA,IAAMG,EAAmBpB,EAAMiB,GAC/B,MAAO,CACL8B,OAAO,EACPzE,iBACAC,aAAc+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,MAI1D,IAAKyB,GAAkBR,GAA0B,GACrBF,EAAME,GAEViB,SAEpB,MAAO,CACL4B,OAAO,EACPzE,iBACAC,aAJuByB,EAAMiB,GAIEhC,KAKrC,MAAO,CAAC8D,OAAO,IAGJC,EAAqB,SAAApF,GAChC,IACE4B,EAIE5B,EAJF4B,QACA1B,EAGEF,EAHFE,uBACAC,EAEEH,EAFFG,uBACA2B,EACE9B,EADF8B,yBAGGpB,EAAgCV,EAAhCU,eAAgBC,EAAgBX,EAAhBW,aAEfmD,EAAoBlC,EAAQ1B,GAC5B6D,EAAoBnC,EAAQzB,GAC5B8D,EAAsBrC,EAAQE,GAEpC,GAAIgC,EACF,OAAIA,EAAkBP,SACb,CACL4B,OAAO,EACPzE,eAAgBoD,EAAkBvC,MAClCZ,aAAcmD,EAAkBzC,KAG7B6D,EAAiB,CACtB/C,OAAQ2B,EACRpD,iBACAC,iBAGJ,IAAIwE,GAAQ,EACZ,GAAIpB,EACF,GAAIA,EAAkBR,SACpB4B,GAAQ,EACRzE,EAAiBqD,EAAkBxC,MACnCZ,EAAeoD,EAAkB1C,QAC5B,CACL,IAAMgE,EAAYH,EAAiB,CACjC/C,OAAQ4B,EACRrD,iBACAC,iBAEE0E,EAAUF,QACZA,GAAQ,EACRzE,EAAiB2E,EAAU3E,eAC3BC,EAAe0E,EAAU1E,cAI/B,GAAIsD,EACF,GAAIA,EAAoBV,SACtB4B,GAAQ,EACRzE,EAAiBuD,EAAoB1C,MACrCZ,EAAesD,EAAoB5C,QAC9B,CACL,IAAMgE,EAAYH,EAAiB,CACjC/C,OAAQ8B,EACRvD,iBACAC,iBAEE0E,EAAUF,QACZA,GAAQ,EACRzE,EAAiB2E,EAAU3E,eAC3BC,EAAe0E,EAAU1E,cAI/B,OAAKwE,EAKE,CACLA,OAAO,EACPzE,iBACAC,gBAPO,CACLwE,OAAO,I,gGC/HPG,GAAc,EAIdC,EAAW,CACf,KAAMD,EACN,KAAMA,GAGFE,EAAM,aACV,IAAKF,EACL,KAAMA,EACN,KAAMA,EACN,KAAMA,GACHC,GAICE,EAAe,SAAC,GAAD,IACnBzC,EADmB,EACnBA,KACA0C,EAFmB,EAEnBA,QACAC,EAHmB,EAGnBA,OACAC,EAJmB,EAInBA,KACArE,EALmB,EAKnBA,MACAF,EANmB,EAMnBA,IACAwE,EAPmB,EAOnBA,YACAzD,EARmB,EAQnBA,MACA0D,EATmB,EASnBA,UATmB,IAUnBC,gBAVmB,MAUR,GAVQ,MAWnBC,iBAXmB,MAWP,GAXO,MAYnB3C,6BAZmB,OAYM,EAZN,MAanBE,gBAbmB,eAcd,CACLP,KAAI,OAAEA,QAAF,IAAEA,IAhBQ,UAASU,KAAKuC,MAAsB,OAAhBvC,KAAKwC,UAAzB,YAA+CC,KAAKC,OAiBlEV,UACAC,SACAC,OACArE,QACAF,MACAwE,cACAzD,QACA0D,YACAC,WACAC,YACA3C,wBACAE,aAEI8C,EAAe,SAAC3G,EAAO4G,GAI3B,IAHA,IAAIvH,EAAI,EACFwH,EAAUD,EAAQC,QAClB3E,EAAU,GACT7C,EAAIW,EAAMV,QAAQ,CAEvB,IADA,IAAI2G,OAAM,EACH5G,EAAIW,EAAMV,QAAQ,CACvB,IAAW,IAAND,GAAWyG,EAAO9F,EAAMX,EAAI,MAAQwH,EAAQ7G,EAAMX,IAAK,CAC1D4G,EAASY,EAAQ7G,EAAMX,IACvB,MAEFA,IAEF,IAAK4G,EACH,MAGF,IAAMpE,EAAQxC,EACdA,EAAIwC,EAAQ,EAMZ,IAJA,IAAMuE,EAAY,GACZ1D,EAAQ,GACRyD,EAAcF,EAAOvD,MAElBoE,EAAI,EAAGA,EAAIX,EAAY7G,OAAQwH,IAAK,CAC3C,IAAMC,EAAY1H,EACd2H,EAAgB,GACpB,EAAmCb,EAAYW,GAAxCG,EAAP,EAAOA,IAAKC,EAAZ,EAAYA,UAAWC,EAAvB,EAAuBA,SACvB,GAAID,EAAW,CACb,GAAIlH,EAAMX,KAAO6H,EAIf,MAHAF,EAAgBE,EAChB7H,IAMJ,IADA,IAAM+H,EAAgB/H,EACfA,EAAIW,EAAMV,SACX6H,EAASnH,EAAMX,KAGnBA,IAEF,IAAMgI,EAAchI,EACpB+G,EAAUa,GAAOjH,EAAMsH,UAAUF,EAAeC,GAChD,IAAME,EA3FQ,IA2FIJ,EAASnH,EAAMX,IAC3BmI,EAAcD,EAAYvH,EAAMX,GAAK,GACvCkI,GACFlI,IAEF,IAAMoI,EAAUpI,EAQhB,GAPAqD,EAAMgF,KAAK,CACTT,MACApF,MAAOkF,EACPpF,IAAK8F,EACLP,UAAWF,EACXW,QAASH,IAEPnI,GAAKW,EAAMV,SAAWiI,EACxB,MAEF,GAAIJ,EAASnH,EAAMX,MAAQuG,EACzB,MAIJ1D,EAAQwF,KAAK,CACXzB,OAAQA,EAAO2B,WACf1B,KAAMD,EAAOC,KACbF,QAASY,EAAQZ,QACjBnE,QACAF,IAAKtC,EACL8G,cACAzD,QACA0D,cAGJ,OAAOlE,GAGH2F,EAAmB,SAAClB,EAAcC,GAAf,OAA2B,SAAC5G,EAAO8H,GAAR,OAClDnB,EAAa3G,EAAO4G,GAASmB,KAAI,SAAAtF,GAAM,OACrCsD,EAAa,yBACXlC,UAAU,EACVwC,SAAU,GACVC,UAAW,GACX3C,uBAAwB,GACrBlB,GALO,IAMVC,MAAOD,EAAOC,MAAMqF,KAAI,SAAAnG,GAAI,gCAC1BiC,UAAU,GACPjC,GAFuB,IAG1BC,MAAOD,EAAKC,MAAQiG,EACpBnG,IAAKC,EAAKD,IAAMmG,OAElBjG,MAAOY,EAAOZ,MAAQiG,EACtBnG,IAAKc,EAAOd,IAAMmG,UAIlB/H,EAAS,SAAC,GAaT,IAZLmC,EAYI,EAZJA,QACA8F,EAWI,EAXJA,UACAhH,EAUI,EAVJA,eACAC,EASI,EATJA,aACAgH,EAQI,EARJA,aAEA3F,EAMI,EANJA,gBACA9B,EAKI,EALJA,uBACAE,EAII,EAJJA,0BACAD,EAGI,EAHJA,uBACA8B,EAEI,EAFJA,gBACA2F,EACI,EADJA,aAEI3H,GAAqB,EAEnB4H,EAAa,GAEnB,GAAI3H,GAA0B,EAAG,CAC/B,IAAM4D,EAAoBlC,EAAQ1B,GAClC,GAAK4D,EAAkBP,SAoBrB7C,EAAiBC,EAAemD,EAAkBzC,IAElDwG,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM,EAAG5H,EAAyB,SAtB9B,CAC/BD,EAAoBC,EAEpB,IAAM8D,EAAgB+D,EAAkB,CACtC5F,OAAQ2B,EACRpD,iBACAC,iBAEFD,EAAiBsD,EAActD,eAC/BC,EAAeqD,EAAcrD,aAE7BkH,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM,EAAG5H,KACpC2H,EAAWT,KAAX,2BACKtD,GADL,IAEEzC,IACEyC,EAAkBzC,IAClBsG,EAAa3I,QACZ2B,EAAeD,WAOjB,CACL,GAAIN,GAA6B,EAAG,CAClC,IAAM4H,EAAuBpG,EAAQxB,GAErCyH,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM,EAAG1H,KAE/B4H,EAAqBzE,SAQxBsE,EAAWT,KAAKY,IAPhB/H,EAAoBG,EAEpByH,EAAWT,KAAX,2BACKY,GADL,IAEE3G,IAAK2G,EAAqB3G,IAAMsG,EAAa3I,gBAK5C,GAAImB,GAA0B,EAAG,CACtC,IAAM4D,EAAoBnC,EAAQzB,GAIlC,GAFA0H,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM,EAAG3H,KAE/B4D,EAAkBR,SAgBrB7C,EAAiBqD,EAAkB1C,IACnCwG,EAAWT,KAAKrD,OAjBe,CAC/B9D,EAAoBE,EAEpB,IAAM6D,EAAgB+D,EAAkB,CACtC5F,OAAQ4B,EACRrD,iBACAC,iBAEFD,EAAiBsD,EAActD,eAC/BC,EAAeqD,EAAcrD,aAE7BkH,EAAWT,KAAX,2BACKrD,GADL,IAEE1C,IAAKX,EAAiBiH,EAAa3I,gBAM9BgD,GAAmB,GAC5B6F,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM,EAAG9F,EAAkB,KAGxD,IAAMiG,EAAeN,EAAa3I,QAAU2B,EAAeD,GAI3D,GAAIuB,GAAmB,EAAG,CACxB,IAAMiG,EAActG,EAAQkG,MAAM7F,GAAiBwF,KAAI,SAAAtF,GAAM,wCACxDA,GADwD,IAE3DC,MAAK,UAAED,EAAOC,aAAT,aAAE,EAAcqF,KAAI,SAAAnG,GAAI,kCACxBA,GADwB,IAE3BC,MAAOD,EAAKC,MAAQ0G,EACpB5G,IAAKC,EAAKD,IAAM4G,OAElB1G,MAAOY,EAAOZ,MAAQ0G,EACtB5G,IAAKc,EAAOd,IAAM4G,OAGpBhG,EAAkB4F,EAAW7I,OAC7B6I,EAAWT,KAAX,MAAAS,EAAU,YAASK,IAEnBjG,EACEA,GAAmB4F,EAAW7I,QAAU,EAAIiD,GAIlD,IAAMkG,EACJT,EAAUV,UAAU,EAAGtG,GACvBiH,EACAD,EAAUV,UAAUrG,GAEhByH,EAAeP,EAAW5H,GAChC,GAAImI,EAAc,CAMhB,IANiB,IAAD,IACVC,EAAaD,EAAa7G,MAC5B+G,EAAWF,EAAa/G,IAEtBkH,EAAoB,oBACxBV,EAAW5F,UADa,aACxB,EAA6BV,aADL,QACc4G,EAASnJ,OAG/CsJ,EAAWC,IAAyB/C,EAAO2C,EAASG,IACpDA,KAkBF,IAfA,IAEA,EAAuDV,EAFvCO,EAASnB,UAAUqB,EAAYC,GAI7CD,GAFF,iBAAOG,EAAP,KAAmCC,EAAnC,WAKIpF,GAAyB,EACvB0C,EAAW,GACXC,EAAY,GACZ5D,EAAQ,GACRsG,EAAuBN,EAAahG,MACpCuG,EAA0BP,EAAarC,SACvC6C,EAA2BR,EAAapC,UACxC6C,EAAuBL,EAAwBpG,MAC5CrD,EAAI,EAAGA,EAAI8J,EAAqB7J,OAAQD,IAAK,CACpD,IAAM+J,EAAUJ,EAAqB3J,GAC/BgK,EAAUF,EAAqB9J,GAC/B4H,EAAMoC,EAAQpC,IAEdqC,EAAiBC,SACd,OAAPH,QAAO,IAAPA,OAAA,EAAAA,EAASvF,WACPwF,EAAQ1H,MAAQ0H,EAAQxH,OACxBmG,EAAUV,UAAU8B,EAAQvH,MAAOuH,EAAQzH,OACzC8G,EAASnB,UAAU+B,EAAQxH,MAAOwH,EAAQ1H,MAEhDe,EAAMgF,KAAN,2BACK2B,GADL,IAEExF,SAAUyF,KAGRA,IACF3F,EAAwBtE,EACxBgH,EAASY,GAAOgC,EAAwBhC,GACxCX,EAAUW,GAAOiC,EAAyBjC,IAI9C,IAAMuC,EAAe,2BAChBV,GADgB,IAEnBnF,wBACAL,KAAMoF,EAAapF,KACnB+C,WACAC,YACA5D,UAGFyF,EAAWsB,OAAX,MAAAtB,EAAU,CAER5H,EACA,EACAiJ,GAJQ,mBAKLT,SAEA,CAML,IANM,IAAD,IACCJ,EAAa3H,EACf4H,GAAW5H,EAAiBiH,EAAa3I,OAEvCuJ,GAAoB,oBACxBV,EAAW5F,UADa,aACxB,EAA6BV,aADL,QACc4G,EAASnJ,OAG/CsJ,GAAWC,KAAyB/C,EAAO2C,EAASG,KACpDA,MAGF,IAEMc,GAAgBxB,EAFNO,EAASnB,UAAUqB,EAAYC,IAEHD,GAE5CR,EAAWsB,OAAX,MAAAtB,EAAU,CAER7F,EAAkB,EAClB,GAHQ,mBAILoH,MAIP,MAAO,CACLjB,WACAN,aACAnH,iBACAC,iBAIEoH,EAAoB,SAAC,GAA4C,IAA3C5F,EAA0C,EAA1CA,OAAQzB,EAAkC,EAAlCA,eAAgBC,EAAkB,EAAlBA,aAC5C0C,EAAwBlB,EAAOkB,sBAC/BjB,EAAQD,EAAOC,MAErB,EAKIF,EAAyB,CAC3BC,SACAzB,iBACAC,iBAPA6B,EADF,EACEA,qBACAD,EAFF,EAEEA,qBACAD,EAHF,EAGEA,uBACAD,EAJF,EAIEA,kBAOF,GAAIG,GAAwB,EAAG,CAG7B,GAFwBJ,EAAMI,GAEVe,SAElB7C,EAAiBC,EADQyB,EAAMiB,GACkBhC,IAEnD,MAAO,CACLX,iBACAC,gBAGJ,GAAI4B,GAAwB,EAAG,CAG7B,GAFwBH,EAAMG,GAEVgB,SAAU,CAC5B,IAAMC,EAAmBpB,EAAMiB,GAC/B3C,EAAiB8C,EAAiBnC,IAClCV,EAAe+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,KAEzD,MAAO,CACLX,iBACAC,gBAGJ,GAAI2B,GAA0B,EAAG,CAG/B,GAF0BF,EAAME,GAEViB,SAAU,CAC9B,IAAMC,EAAmBpB,EAAMiB,GAC/B3C,EAAiB8C,EAAiBnC,IAClCV,EAAe+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,KAEzD,MAAO,CACLX,iBACAC,gBAGJ,GACE0B,EAAkBvB,UAAY,GAC9BuB,EAAkBvB,SAAWuC,EAAwB,EACrD,CACA,IAAMG,EAAmBpB,EAAMiB,GAG/B,MAAO,CACL3C,eAHFA,EAAiB8C,EAAiBnC,IAIhCV,aAHFA,EAAe+C,KAAKC,IAAIhD,EAAc6C,EAAiBnC,MAOzD,MAAO,CACLX,iBACAC,iBAIE0I,EAAgC,SAAAC,GACpC,IAAM/C,EAAU,GACVgD,EAAQ,GAuBd,OAtBAD,EAAoB/C,QAAQiD,SAAQ,SAAA7D,GAClC,IAAMvD,EAAQuD,EAAOvD,MAAMqF,KAAI,WAA4B1I,EAAGqD,GAA/B,MAAEwE,EAAF,EAAEA,UAAWS,EAAb,EAAaA,QAAb,MAA0C,CACvEV,IAD6B,EAAsBA,IAEnDC,UAAWA,GAAa,GACxBS,QAASA,GAAW,GACpBR,SAAS,wCACH,UAAAzE,EAAMrD,EAAI,UAAV,eAAc6H,WAAd,eAEGxE,EAAMrD,EAAI,GAAG6H,UA3bT,GA6bP,MACAS,EAAO,eAAKA,EA/bJ,GA+b6B,MACtC9B,OAGDkE,EAAY,2BACb9D,GADa,IAEhBvD,UAEFmH,EAAM5D,EAAOC,MAAQ6D,EACrBlD,EAAQZ,EAAO2B,YAAcmC,KAExB,2BAAIH,GAAX,IAAgC/C,UAASgD,WAGrCG,EAAuB,SAACnG,EAAUjC,EAAMqI,EAAYC,GAA7B,OAC1BrG,EAAWoG,EAAW/C,UAAYtF,EAAKsF,WACxCgD,GACCrG,EAAWoG,EAAWtC,QAAU/F,EAAK+F,UAClCwC,EAA0B,SAACtG,EAAUjC,EAAMqI,EAAYC,GAA7B,OAC7BrG,EAAWoG,EAAW/C,UAAYtF,EAAKsF,WAAW5H,OACnD4K,EAAK5K,QACJuE,EAAWoG,EAAWtC,QAAU/F,EAAK+F,SAASrI,QAC9CsC,EAAKD,IAAMC,EAAKC,QAEbuI,EAAa,SAAC3H,EAAQmH,GAM1B,IALA,IAIIjG,EAJEoG,EACJH,EAAoBC,MAAMpH,EAAOyD,OACjC0D,EAAoB/C,QAAQpE,EAAOwD,QAC/BE,EAAc4D,EAAarH,MAExBrD,EAAI,EAAGA,EAAI8G,EAAY7G,OAAQD,IAClCoD,EAAO4D,SAASF,EAAY9G,GAAG4H,OACjCtD,EAAwBtE,GAG5B,IAAMgL,EAAiB1G,IAA0BwC,EAAY7G,OAAS,EAChEoD,EAAQ2H,OACVC,GACC7H,EAAOC,OAAS,IAAIqF,KAAI,SAACnG,EAAMvC,GAAP,mBAAC,eACrBuC,GADoB,IAEvBiC,SAAUxE,GAAKsE,OAEfyC,EAAYiE,OAAiBC,EAAY7H,EAAO2D,UACtD,OAAOL,EAAa,2BACftD,GADc,IAEjByD,KAAM6D,EAAa7D,KACnBD,OAAQ8D,EAAa9D,OACrBvD,QACA0D,YACAD,cACAtC,SAAUwG,EACV1G,4BA6fW4G,EAzfU,WAAiC,IAAD,yDAAP,GAAvBX,EAA8B,EAA9BA,oBACzBA,EAAsBD,EAA8BC,GACpD,IAAM1B,EAAeL,EAAiBlB,EAAciD,GAEpD,OAAO,eAACnF,EAAD,uDAAY,WAAZ,OACLC,sBACE,WAWEnF,GACI,IAAD,EAVDiL,EAUC,EAVDA,UACAC,EASC,EATDA,YACSC,EAQR,EARDC,QACUC,EAOT,EAPDC,SACAC,EAMC,EANDA,gBACAC,EAKC,EALDA,SACAC,EAIC,EAJDA,cACGC,EAGF,iBACGpL,EAAaC,mBACnBD,EAAWL,QAAUK,EAAWL,SAAW,CACzCQ,MAAK,OAAEwK,QAAF,IAAEA,IAAa,GACpBtI,QAAO,iBACLuI,QADK,IACLA,OADK,EACLA,EACIS,QACA,gBAAEjF,EAAF,EAAEA,OAAQC,EAAV,EAAUA,KAAV,OACE0D,EAAoBC,MAAM3D,IAC1B0D,EAAoB/C,QAAQZ,MAE/B8B,KAAI,SAAAtF,GAAM,OAAI2H,EAAW3H,EAAQmH,aAP/B,QAOwD,IAGjE/J,EAAWL,QAAQsL,gBAAkBA,EACrCjL,EAAWL,QAAQuL,SAAWA,EAE9B,IAAMhG,EAAWjF,oBAEbmL,EAAMjL,OAASiL,EAAM/I,WACvBiJ,QAAQC,KAAR,4FAGOH,EAAM/I,eACN+I,EAAMjL,OAGf,MAAkCqL,mBAASxL,EAAWL,QAAQQ,OAA9D,mBAAOA,EAAP,KAAcsL,EAAd,KACA,EAAsCD,mBACpCxL,EAAWL,QAAQ0C,SADrB,mBAAOA,EAAP,KAAgBqJ,EAAhB,KAGMC,EAAW,SAAAxL,GACfH,EAAWL,QAAQQ,MAAQA,EAC3BsL,EAAiBtL,IAEbyL,EAAa,SAAAvJ,GACjBrC,EAAWL,QAAQ0C,QAAUA,EAC7BqJ,EAAmBrJ,IAGrB,EAA6BzC,EAC3BuL,GACA,WAuPE,MAAO,CACLU,aAvPmB,SAACjJ,EAAQkJ,GAC5B,IAAMzJ,EAAUrC,EAAWL,QAAQ0C,QAC7BlC,EAAQH,EAAWL,QAAQQ,MAC3BX,EAAI6C,EAAQ0J,WAAU,SAAAC,GAAC,OAAIA,EAAEvI,OAASb,EAAOa,QACnD,KAAIjE,EAAI,GAAR,CAKA,MAFAoD,EAASP,EAAQ7C,GAEH2B,EAAd,EAAOa,MACD0G,EADN,EAA8B5G,IACMX,EAE9ByH,EACJzI,EAAMsH,UAAU,EAAG7E,EAAOZ,OAAS7B,EAAMsH,UAAU7E,EAAOd,KAEtDwG,EAAU,sBACXjG,EAAQkG,MAAM,EAAG/I,IADN,YAEX6C,EAAQkG,MAAM/I,EAAI,GAAG0I,KAAI,SAAAtF,GAAM,kCAC7BA,GAD6B,IAEhCZ,MAAOY,EAAOZ,MAAQ0G,EACtB5G,IAAKc,EAAOd,IAAM4G,SAOtB,GAHAiD,EAAS/C,GACTgD,EAAWtD,GAEPwD,EAAW,CACb,IAAM1G,EAAWF,EAASvF,QAC1BuF,EAASvF,QAAQQ,MAAQyI,EACzBxD,EAASjE,eAAiBiE,EAAShE,aAAewB,EAAOZ,MAG3DiJ,GACEA,EAAgB,CACd5F,OAAQH,EAASvF,QACjBG,MAAM,EACNK,MAAOyI,EACPqD,SAAU9L,EACVkC,QAASiG,EACT4D,WAAY7J,IAGhB0I,GACEA,EAAmB,CACjB1F,OAAQH,EAASvF,QACjBQ,MAAOyI,EACPvG,QAASiG,MAyMb6D,iBAAkB,WAAoBjM,GAApB,IAAE0C,EAAF,EAAEA,OAAQwJ,EAAV,EAAUA,QAAV,OAtMK,SAAC,EAAmBlM,GAAY,IAA9B0C,EAA6B,EAA7BA,OAAQwJ,EAAqB,EAArBA,QAC3B5I,EAAaZ,EAAOa,MAAQb,EAC5BP,EAAUrC,EAAWL,QAAQ0C,QAC7BlC,EAAQH,EAAWL,QAAQQ,MAC3BX,EAAI6C,EAAQ0J,WAAU,SAAAC,GAAC,OAAIA,EAAEvI,OAASD,KAC5C,GAAIhE,EAAI,EACN,OAAO,EAGT,IAAM6M,GADNzJ,EAASP,EAAQ7C,IACQ8G,YAAYyF,WACnC,qBAAE3E,MAAiBgF,KAErB,GAAIC,EAAY,EACd,OAAO,EAET,IAAM/F,EAAc1D,EAAO0D,YACrB8D,EAAa9D,EAAY+F,GAEzBC,EAAiB,SAAApM,GAAW,IAAD,EAC/B,IAAKA,EACH,OAAO0C,EAGT,IAAOyH,EAA0BnK,EAA1BmK,KAAMkC,EAAoBrM,EAApBqM,OAAQC,EAAYtM,EAAZsM,KAAMC,EAAMvM,EAANuM,GAE3B,EAA8C7J,EAAzC4D,EAAL,EAAKA,SAAUC,EAAf,EAAeA,UAAW5D,EAA1B,EAA0BA,MAAO0D,EAAjC,EAAiCA,UAE3BxE,EAAI,UAAGc,SAAH,aAAG,EAAQwJ,GAEfrI,EAAW0F,QAAQ+C,EAAIjG,EAAS4F,IAChCtI,EAAwBE,EAC1BG,KAAKC,IAAIiI,EAAWzJ,EAAOkB,uBAC3BlB,EAAOkB,sBAEL4I,EAAqBL,IAAc/F,EAAY7G,OAAS,EAExD+K,EACJ5H,EAAOoB,UAAaA,GAAY0I,EAE5BC,EAAa9J,GAASwJ,IAAcxJ,EAAMpD,OAAS,EACnDmN,EAAiBF,EACnB,KACApG,EAAY+F,EAAY,GAEtBQ,EAAarC,GACftK,EAAO2M,YACP,GAEEC,EAAqB,MAARzC,EACb3B,EAAeoE,EACjBtC,EACEH,EAAK5K,OACLoN,EAAWpN,QACVmD,EAAOd,IAAMc,EAAOZ,OACrBsI,EAAwBtG,EAAUjC,EAAMqI,EAAYC,GACtD,EAQJ,GANIoC,IACFjG,EAAQ,2BAAOA,GAAP,kBAAkB4F,EAAUK,MAElCD,GAAiB,OAATA,KACV/F,EAAS,2BAAOA,GAAP,kBAAmB2F,EAAUI,KAEpChC,EACF3H,OAAQ4H,OACH,GAAIzG,IAAajC,EAAKiC,UAAY8I,EAAY,CACnD,IAAMC,EAAWlK,EAAM0F,MAAM,EAAG8D,GAC1B7C,EAAO,2BACR3G,EAAMwJ,IADE,IAEXrI,WACAlC,IAAKe,EAAMwJ,GAAWvK,IAAM4G,GACxB1E,EACA,CACEqD,UAAW+C,EAAW/C,UACtBS,QAASsC,EAAWtC,SAEtB,MAENiF,EAASlF,KAAK2B,GACVmD,EACGD,GACHK,EAASlF,KAAK,CACZ7F,MAAOwH,EAAQ1H,IACfA,IAAK0H,EAAQ1H,IACbsF,IAAKwF,EAAexF,IACpBU,QAAS,GACTT,UAAW,KAGNqB,EACTqE,EAASlF,KAAT,MAAAkF,EAAQ,YACHlK,EAAM0F,MAAM8D,EAAY,GAAGnE,KAAI,SAAAnG,GAAI,kCACjCA,GADiC,IAEpCC,MAAOD,EAAKC,MAAQ0G,EACpB5G,IAAKC,EAAKD,IAAM4G,SAIpBqE,EAASlF,KAAT,MAAAkF,EAAQ,YAASlK,EAAM0F,MAAM8D,EAAY,KAE3CxJ,EAAQkK,EAENvC,EACFjE,OAAYkE,EACHqC,IACTvG,EAAS,2BAAOA,GAAP,kBAAmB6F,EAAU/B,IAClCsC,IAAeD,IACjBnG,EAAUqG,EAAexF,KAAO,KAIpC,IAAMkB,EAAU,YAAOjG,EAAQkG,MAAM,EAAG/I,IAClCwN,EAAS,2BACVpK,GADU,IAEbd,IAAKc,EAAOd,IAAM4G,EAClB7F,QACA2D,WACAC,YACAF,YACAzC,wBACAE,SAAUwG,IAEZlC,EAAWT,KAAKmF,GACZtE,EACFJ,EAAWT,KAAX,MAAAS,EAAU,YACLjG,EAAQkG,MAAM/I,EAAI,GAAG0I,KAAI,SAAAtF,GAAM,wCAC7BA,GAD6B,IAEhCC,MAAK,UAAED,EAAOC,aAAT,aAAE,EAAcqF,KAAI,SAAAnG,GAAI,kCACxBA,GADwB,IAE3BC,MAAOD,EAAKC,MAAQ0G,EACpB5G,IAAKC,EAAKD,IAAM4G,OAElB1G,MAAOY,EAAOZ,MAAQ0G,EACtB5G,IAAKc,EAAOd,IAAM4G,SAItBJ,EAAWT,KAAX,MAAAS,EAAU,YAASjG,EAAQkG,MAAM/I,EAAI,KAGvC,IAAIoJ,EAAWzI,EAgBf,GAfI2M,IACFlE,EAAW,CACTzI,EAAMsH,UACJ,EACA+C,EAAiB5H,EAAOZ,MAAQD,EAAKC,OAEvCwI,EACIH,EAAOwC,EACP1C,EAAqBnG,EAAUjC,EAAMqI,EAAYC,GACrDlK,EAAMsH,UAAU+C,EAAiB5H,EAAOd,IAAMC,EAAKD,MACnDmL,KAAK,IAEPtB,EAAS/C,IAEXgD,EAAWtD,GACPiE,EAAQ,CAAC,IAAD,EACJnH,EAAWF,EAASvF,QAC1BuF,EAASvF,QAAQQ,MAAQyI,EACzB,IAAMhG,EAAS0F,EAAW9I,GACpBuC,EAAI,UAAGa,EAAOC,aAAV,aAAG,EAAewJ,GACb,UAAXE,EACFnH,EAASjE,eAAiBiE,EAAShE,aACjCoJ,EAAiB5H,EAAOZ,MAAQD,EAAKC,MACnB,QAAXuK,IACTnH,EAASjE,eAAiBiE,EAAShE,aACjCoJ,EACI5H,EAAOd,IAAM+K,EAAWpN,OACxBsC,EAAKD,KAqBf,OAjBAmJ,GACEA,EAAgB,CACd5F,OAAQH,EAASvF,QACjBG,MAAM,EACNK,MAAOyI,EACPqD,SAAU9L,EACVkC,QAASiG,EACT4D,WAAY7J,IAGhB0I,GACEA,EAAmB,CACjB1F,OAAQH,EAASvF,QACjBQ,MAAOyI,EACPvG,QAASiG,IAGN0E,GAET,OACSV,EADa,oBAAXpM,EACaA,EAAO,CAAC0C,SAAQwH,aAAYiC,cAE9BnM,GAKpBiM,CACE,CAACvJ,SAAQwJ,YACT,YAAsC,IAexB,EAfZxJ,EAAmC,EAAnCA,OAAQwH,EAA2B,EAA3BA,WAAYiC,EAAe,EAAfA,UASpB,MARsB,oBAAXnM,IACTA,EAASA,EAAO,CACd0C,SACAwJ,UACAhC,aACAiC,eAGArM,EAAWL,QAAQuL,UAAYhL,EAE1B,CACLsM,KAAMtM,EAAOsM,MAGbtM,EACK,aACLsM,UACkB/B,IAAhBvK,EAAOsM,KACH5J,EAAO6D,UAAU2F,GACjBlM,EAAOsM,KACbC,GAAE,UAAEvM,EAAOuM,UAAT,QAAe7J,EAAO4D,SAAS4F,IAC9BlM,GAGAA,SAKjB,IA5RKgN,EAAP,oBA+aA,OAdAC,qBAAU,WACR,IAAM/H,EAAWF,EAASvF,QACpBsL,EAAkBjL,EAAWL,QAAQsL,gBAC3CA,GACEA,EAAgB,CACd5F,OAAQD,EACRtF,MAAM,EACNK,MAAOH,EAAWL,QAAQQ,MAC1B8L,SAAU,GACV5J,QAASrC,EAAWL,QAAQ0C,QAC5B6J,WAAY,OAEf,IAGD,cAACtH,EAAD,2BACMwG,GADN,IAEE1L,IAAKN,EAAUM,EAAKwF,GACpBiG,cAAe+B,EACfhC,SAAUA,EACV/K,MAAOA,EACPkC,QAASA,EACTyI,QAxJY,SAAA3F,GACd,IAAMC,EAAWD,EAAEE,OACbuD,EAAWxD,EAASjF,MACpBgI,EAAYhI,EAClB,GAAIgI,IAAcS,EAChB,OAAO,EAGT,IAKIzH,EALEC,EAAegE,EAAShE,aACxBgM,EACJjF,EAAU1I,QAAUmJ,EAASnJ,OAAS2B,GAClCiM,EAAkBlJ,KAAKE,IAAI+I,EAAkBhM,GAGnD,IACED,EAAiB,EACjBA,EAAiBkM,GACjBlF,EAAUhH,KAAoByH,EAASzH,GACvCA,KAGF,IAAIV,EAAY2B,EAAoB,CAClCC,UACAlB,iBACAC,aAAcgM,IAGVE,EAAczH,EAAmB,2BAClCpF,GADiC,IAEpCU,iBACAC,aAAcgM,KAOhB,GAJIpN,EAAWL,QAAQ4N,aACrBC,aAAaxN,EAAWL,QAAQ4N,YAChCvN,EAAWL,QAAQ4N,WAAa,MAE9BD,EAAY1H,MAYd,OAXAR,EAASjE,eAAiBmM,EAAYnM,eACtCiE,EAAShE,aAAekM,EAAYlM,aACpCpB,EAAWL,QAAQ4N,WAAaE,YAAW,WACzCzN,EAAWL,QAAQ4N,WAAa,KAChC,IACEnI,EAASjE,eAAiBmM,EAAYnM,eACtCiE,EAAShE,aAAekM,EAAYlM,aAEpC,MAAOsM,QAEXvI,EAAEwI,kBACK,EAGT,IAAMvF,EAAeQ,EAASnB,UAAUtG,EAAgBC,GAExD,EAMIX,EALFgC,EADF,EACEA,gBACA9B,EAFF,EAEEA,uBACAE,EAHF,EAGEA,0BACAD,EAJF,EAIEA,uBACA8B,EALF,EAKEA,gBAGF,EAIIxC,EAAO,CACTmC,UACA8F,YACAhH,iBACAC,aAAcgM,EACdhF,eAEA3F,kBACA9B,yBACAE,4BACAD,yBACA8B,kBAEA2F,iBAhBUuF,EADZ,EACEhF,SACYiB,EAFd,EAEEvB,WACc9C,EAHhB,EAGEpE,aAiBFuK,EAASiC,GACThC,EAAW/B,GAEX,IAAMgE,EACJD,IAAgBhF,EAAWpD,EAAkBpE,EAgC/C,OA/BAgE,EAASjF,MAAQyN,EACjBxI,EAAShE,aAAeyM,EACxBzI,EAASjE,eAAiB0M,EAE1BpN,EAAS,aACPU,eAAgB0M,EAChBzM,aAAcyM,GACXzL,EAAoB,CACrBC,QAASwH,EACT1I,eAAgB0M,EAChBzM,aAAcyM,KAIlB5C,GACEA,EAAgB,CACd5F,OAAQD,EACRtF,MAAM,EACNK,MAAOyN,EACP3B,SAAU9L,EACVkC,QAASwH,EACTqC,WAAY7J,IAGhBwI,GACEA,EAAkB,CAChBxF,OAAQD,EACRjF,MAAOyN,EACPvL,QAASwH,KAGN,GAmCLmB,SAhCa,SAAA7F,GACf4F,GACEA,EAAmB,CACjB1F,OAAQF,EAAEE,OACVlF,MAAOH,EAAWL,QAAQQ,MAC1BkC,QAASrC,EAAWL,QAAQ0C,mB,6QCz8BpCyL,EAAa,CACjB,YACA,YACA,QACA,SACA,YACA,YAEA,iBACA,mBACA,oBACA,kBACA,cAEA,aACA,eACA,gBACA,cAGA,YACA,cACA,aACA,cACA,WACA,iBACA,aACA,aAEA,YACA,gBACA,aACA,iBAEA,gBACA,cAEA,UACA,cAGF,SAASC,EAA0BxO,EAASyO,EAAWjH,GACrD,IAAMkH,EAASlH,GAAWA,EAAQkH,QAAU,EAC5C,GAAIA,EAAO,CACT,IAAMC,EAAKC,SAASC,cAClB,6CAEEF,GAAIA,EAAGG,WAAWC,YAAYJ,GAIpC,IAAMK,EAAMJ,SAASK,cAAc,OACnCD,EAAI9B,GAAK,2CACT0B,SAASM,KAAKC,YAAYH,GAE1B,IAAMI,EAAQJ,EAAII,MACZC,EAAWC,OAAOC,iBACpBD,OAAOC,iBAAiBvP,GACxBA,EAAQwP,aACNC,EAA+B,UAArBzP,EAAQ0P,SAGxBN,EAAMO,WAAa,WACdF,IAASL,EAAMQ,SAAW,cAG/BR,EAAMS,SAAW,WACZnB,IAAOU,EAAMU,WAAa,UAG/BvB,EAAW7D,SAAQ,SAAAqF,GACjB,GAAIN,GAAoB,eAATM,EAEb,GAA2B,eAAvBV,EAASW,UAA4B,CACvC,IAAMC,EAASC,SAASb,EAASY,OAAQ,IACnCE,EACJD,SAASb,EAASe,WAAY,IAC9BF,SAASb,EAASgB,cAAe,IACjCH,SAASb,EAASiB,eAAgB,IAClCJ,SAASb,EAASkB,kBAAmB,IACjCC,EAAeL,EAAcD,SAASb,EAASoB,WAAY,IAE/DrB,EAAMqB,WADJR,EAASO,EACX,UAAsBP,EAASE,EAA/B,MACSF,IAAWO,EACDnB,EAASoB,WAET,OAGrBrB,EAAMqB,WAAapB,EAASY,YAG9Bb,EAAMW,GAAQV,EAASU,OAMtBN,GAAWzP,EAAQ0Q,aAAe1Q,EAAQ2Q,aAC7CvB,EAAMwB,UAAY,SAElBxB,EAAMwB,UAAY,UAEfnB,GAAWzP,EAAQ6Q,YAAc7Q,EAAQ8Q,YAC5C1B,EAAM2B,UAAY,SAElB3B,EAAM2B,UAAY,SAMpB,IAHA,IAAMnQ,EAAQZ,EAAQY,MAChBoQ,EAAiB,CAACpQ,EAAMsH,UAAU,EAAGuG,EAAU,KAC/CwC,EAAOrQ,EAAMV,OACVD,EAAI,EAAGA,EAAIwO,EAAUvO,OAAQD,IAAK,CACzC,GAAIwO,EAAUxO,IAAMgR,EAAM,CACxBD,EAAe1I,KAAK,MACpB,MAIEmH,GACFuB,EAAe1I,KAAK1H,EAAM6N,EAAUxO,IAAIiR,QAAQ,MAAO,SACvDF,EAAe1I,KACb1H,EACGsH,UAAUuG,EAAUxO,GAAK,EAAGwO,EAAUxO,EAAI,IAC1CiR,QAAQ,MAAO,WAGpBF,EAAe1I,KAAK1H,EAAM6N,EAAUxO,KACpC+Q,EAAe1I,KAAK1H,EAAMsH,UAAUuG,EAAUxO,GAAK,EAAGwO,EAAUxO,EAAI,MAKxE,IADA,IAAMkR,EAAQ,GACLlR,EAAI,EAAGA,EAAI+Q,EAAe9Q,OAAQD,IAAK,CAC9C,IAAMmR,EAAOxC,SAASK,cAAc,QACV,OAAtB+B,EAAe/Q,GACjBmR,EAAKC,YAAc,IAEnBD,EAAKC,YAAcL,EAAe/Q,GAEhCA,EAAI,IACNkR,EAAM7I,KAAK8I,GACP1C,IACF0C,EAAKhC,MAAMkC,gBAAkB,SAGjCtC,EAAIG,YAAYiC,GAclB,IAXA,IAAMG,EAAc,GAEdC,EACJtB,SAASb,EAASiB,eAAgB,IAClCJ,SAASb,EAASoC,UAAW,IAC7BzR,EAAQ0R,UACJC,EACJzB,SAASb,EAASuC,gBAAiB,IACnC1B,SAASb,EAASwC,WAAY,IAC9B7R,EAAQ8R,WACJ7B,EAASC,SAASb,EAASoB,WAAY,IACpCxQ,EAAI,EAAGA,EAAIkR,EAAMjR,OAAQD,IAChCsR,EAAYjJ,KAAK,CACfyJ,IAAKZ,EAAMlR,GAAG+R,UAAYR,EAC1BS,KAAMd,EAAMlR,GAAGiS,WAAaP,EAC5B1B,WAWJ,OAPIvB,GACFU,EAAM2C,IAAM,IACZ3C,EAAM+C,MAAQ,KAEdvD,SAASM,KAAKH,YAAYC,GAGrBuC,EAGT,IAAMa,EAAiB,SAACvM,EAAU/C,GAA2B,IAAD,yDAAP,GAAT4L,EAAgB,EAAhBA,MAC1C,IAAK7I,EACH,MAAO,GAIT,IAFA,IAAM4I,EAAY,GAETxO,EAAI,EAAGA,EAAI6C,EAAQ5C,OAAQD,IAClCwO,EAAUnG,KAAKxF,EAAQ7C,GAAGwC,MAAOK,EAAQ7C,GAAGsC,KAI9C,IADA,IAAM8P,EAA4B,GACzBpS,EAAI,EAAGA,EAAIwO,EAAUvO,OAAQD,IAChCwO,EAAUxO,KAAOwO,EAAUxO,EAAI,IACjCoS,EAA0B/J,KAAKmG,EAAUxO,IAW7C,IAPA,IAAMqS,EAA8B9D,EAClC3I,EACAwM,EACA,CAAC3D,UAEG6C,EAAc,GAEXtR,EAAI,EAAGyH,EAAI,EAAGzH,EAAIwO,EAAUvO,OAAQD,IAC3CsR,EAAYjJ,KAAKgK,EAA4B5K,IACzC+G,EAAUxO,KAAOwO,EAAUxO,EAAI,IACjCyH,IAMJ,IAFA,IAAM6K,EAAS,GACT1B,EAAchL,EAASgL,YACpB5Q,EAAI,EAAGA,EAAIsR,EAAYrR,OAAQD,GAAK,EAAG,CAC9C,MAAqCsR,EAAYtR,GAApCuS,EAAb,EAAOP,KAAcQ,EAArB,EAAgBV,IAAgBW,EAAhC,EAAwBzC,OACxB,EAA4BsB,EAAYtR,EAAI,GAA/B0S,EAAb,EAAOV,KAAeW,EAAtB,EAAiBb,IACjB,GAAIU,IAAMG,EAAI,CAGZ,IAFA,IAAMtP,EAAQ,CAAC,CAACkP,IAAGC,IAAGI,EAAGhC,EAAc2B,EAAGE,MACpCI,EAAQlO,KAAKuC,OAAOyL,EAAKH,GAAKC,GAAK,EAChChL,EAAI,EAAGA,EAAIoL,EAAOpL,IACzBpE,EAAMgF,KAAK,CAACkK,EAAG,EAAGC,EAAGA,GAAK/K,EAAI,GAAKgL,EAAGG,EAAGhC,EAAa6B,MAExDpP,EAAMgF,KAAK,CAACkK,EAAG,EAAGC,EAAGA,GAAKK,EAAQ,GAAKJ,EAAGG,EAAGF,EAAID,MACjDH,EAAOjK,KAAKhF,QAEZiP,EAAOjK,KAAK,CAAC,CAACkK,IAAGC,IAAGI,EAAGF,EAAKH,EAAGE,OAGnC,OAAOH,GAGHQ,EAAwB,SAAC,GAAD,IAAEP,EAAF,EAAEA,EAAGC,EAAL,EAAKA,EAAGI,EAAR,EAAQA,EAAGH,EAAX,EAAWA,EAAX,MAAmB,CAC/CT,KAAK,GAAD,OAAKO,EAAL,MACJT,IAAI,GAAD,OAAKU,EAAL,MACHxC,OAAO,GAAD,OAAKyC,EAAL,MACNM,MAAM,GAAD,OAAKH,EAAL,QAGDI,EAAY3N,sBAAW,WAA4BnF,GAA5B,IAAE+S,EAAF,EAAEA,UAAcxN,EAAhB,wBAC3B,6CAAKvF,IAAKA,GAASuF,GAAnB,IAA8B0J,MAAO2D,EAAsBG,SAGvDC,EAAY7N,sBAChB,WAA4CnF,GAA5C,IAAEiT,EAAF,EAAEA,YAAaC,EAAf,EAAeA,aAAiB3N,EAAhC,wBACE,6CAAKvF,IAAKA,GAASiT,GAAnB,aACE,cAACC,EAAD,eAAkB3N,UAKlB4N,EAAkB,SAAC,GAclB,IAbLjQ,EAaI,EAbJA,OACAP,EAYI,EAZJA,QACAyQ,EAWI,EAXJA,WACAC,EAUI,EAVJA,aACAC,EASI,EATJA,aACAC,EAQI,EARJA,eACAL,EAOI,EAPJA,aACgBM,EAMZ,EANJC,eACAC,EAKI,EALJA,oBACAC,EAII,EAJJA,uBACAC,EAGI,EAHJA,gBACAC,EAEI,EAFJA,WACAC,EACI,EADJA,WAEA,EAAgEhI,oBAAU,GAA1E,mBAAOiI,EAAP,KAAiCC,EAAjC,KACIC,EAC0B,MAA5BT,EACIO,EACAP,EAAyBU,gBAEP,IAApBD,IACFA,EAAkBb,EAAWrT,OAAS,GAGxC,IAAMO,EAAaC,iBAAO,IAcpB4T,EAAa,SAAAD,GACjBpG,aAAaxN,EAAWL,QAAQmU,OAblB,SAACzN,EAAMuN,GACW,MAA5BV,EACFQ,EAA4BE,GAE5BR,EAAoB,CAClBxQ,SACAmR,SAAS,EACTH,iBACAvN,SAMJ2N,CAAQ,YAAaJ,IAGjBK,EAAU,SAAA5N,GACmB,OAA5B6M,EACHQ,GAA6B,GAE7BN,EAAoB,CAClBxQ,SACAmR,SAAS,EACT1N,UAIA6N,EAAa,WACjBlU,EAAWL,QAAQmU,MAAQrG,YAAW,WACpCwG,EAAQ,eACP,MAGL9G,qBAAU,kBAAM,kBAAMK,aAAaxN,EAAWL,QAAQmU,UAAQ,IAE9D,IAAMK,EAAQ,WAAwB,IAAD,EAAtBC,EAAsB,uDAAP,GACrBpS,EAAcoS,EAAdpS,MAAOF,EAAOsS,EAAPtS,IACRuS,EAAK,UAAGD,EAAaC,aAAhB,QAAyB,EAChCrS,EACFsR,EAAgBa,MAAMvR,EAAOZ,MAAQqS,GAC5BvS,EACTwR,EAAgBa,MAAMvR,EAAOd,IAAMuS,GAEnCf,EAAgBa,SAGdG,EAAW,kBAAMH,EAAM,CAACrS,KAAK,KAE7B0B,EAAaZ,EAAOa,KACpB8Q,EAAqBC,uBACzB,SAAAC,GACEpB,EAAuB,CAACzQ,OAAQY,EAAY2Q,MAAK,OAAEM,QAAF,IAAEA,OAAF,EAAEA,EAAKN,UAE1D,CAACd,EAAwB7P,IAGrBkR,EAAgBf,GAAmB,EACnCnD,EAAOsC,EAAWrT,OAAS,EACjC,OAAOqT,EAAW5K,KAAI,SAACuK,EAAWjT,GAChC,IAAMmV,EAAoB,IAANnV,EACdoV,EAAapV,IAAMgR,EACnBqE,EAAY,UAAMjS,EAAOa,KAAb,YAAqBjE,EAArB,YACZsV,EAAU,UAAMlS,EAAOa,KAAb,YAAqBjE,EAArB,UACVuV,EAAenC,GAAgBe,IAAoBnU,EACnDwV,EAAkB,SAAAtV,GAAG,OACzB,cAAC8S,EAAD,CACE9S,IAAKA,EAGL+M,GAAIoI,EACJI,KAAK,SACL,gBAAc,OACd,gBAAeH,EACf,gBAAeC,EACftC,UAAWA,EACXyC,aAAc,kBAAMrB,EAAWrU,IAC/B2V,aAAcjB,EACdkB,cAAed,EACfe,YAAaf,EACbgB,QAAShB,EACT,+BAA8Bf,EAC9B,6BAA4B3Q,EAAOa,KACnC8R,UAAWxC,EAAa,CACtB4B,cACAC,aACAG,aAAcL,IApBlB,SAsBGzB,EACC,cAACA,EAAD,CACErQ,OAAQA,EACR0Q,gBAAiBA,EACjBb,UAAWA,EACXmB,eAAgBpU,EAChBsT,WAAYA,IAEZ,MA3BCtT,IA8BT,OAAOuV,EACL,cAAC,IAAD,CAEES,WAAW,WACXC,iBAAiB,cACjB9G,MAAO,CAAC+G,OAAQlC,GAChBmC,YAAa,CACX,CACEC,GAAI,eACJJ,WAAY,YAEd,CACEI,GAAI,SACJJ,WAAY,aAGhBK,aAAcb,EACdc,cAAe,SAAApW,GAAG,OAChB,cAACgT,EAAD,CACEhT,IAAKA,EACL6U,mBAAoBA,EACpB3B,aAAcA,EACdkC,WAAYA,EACZD,aAAcA,EACdjS,OAAQA,EACRP,QAASA,EACTiR,gBAAiBA,EACjByC,YAAa5B,EACb6B,OAAQ,SAAA5B,GACNH,KACqB,IAAjBG,GACFD,EAAMC,IAGVzB,YAAa,CACX4C,UAAWvC,EACXkC,aAAc,kBAAMrB,EAAWrU,IAC/B2V,aAAcjB,EACd,wBAAyBX,EACzB,sBAAuB3Q,EAAOa,UArChC,eA2CNuR,QAKAiB,GAAa,SAAC,GAAD,IAAErT,EAAF,EAAEA,OAAF,OAAc,8BAAMsT,KAAKC,UAAUvT,EAAQ,KAAM,MAE9DwT,GAAe,SAAC,GAAD,IACnB/T,EADmB,EACnBA,QACAwG,EAFmB,EAEnBA,aACAiJ,EAHmB,EAGnBA,OACAiB,EAJmB,EAInBA,aACAsD,EALmB,EAKnBA,gBACApD,EANmB,EAMnBA,eANmB,IAOnBL,oBAPmB,MAOJqD,GAPI,EAQnBK,EARmB,EAQnBA,gBACAlD,EATmB,EASnBA,oBACAC,EAVmB,EAUnBA,uBACAC,EAXmB,EAWnBA,gBACAC,EAZmB,EAYnBA,WACAC,EAbmB,EAanBA,WAbmB,OAenBnR,EAAQ6F,KAAI,SAACtF,EAAQpD,GACnB,IAAMsT,EAAahB,EAAOtS,GAC1B,OAAKsT,EAIH,cAAC,EAAD,CAEElQ,OAAQA,EACRP,QAASA,EACTyQ,WAAYA,EACZC,aAAc,SAAAwD,GAAuB,OACnCxD,EAAa,2BACRwD,GADO,IAEVC,SAAU5T,EAAOa,QAAP,OAAgBoF,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAcpF,MACxCb,aAGJoQ,aAAcqD,EAAgB,CAC5BzT,SACA4T,SAAU5T,EAAOa,QAAP,OAAgBoF,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAcpF,QAE1CwP,eAAgBA,EAChBL,aAAcA,EACdO,eACEmD,EACoC,MAAhCA,EAAgB1T,EAAOa,OACrB6S,EAAgB1T,EAAOa,MAEzB,KAEN2P,oBAAqBA,EACrBC,uBAAwBA,EACxBC,gBAAiBA,EACjBC,WAAYA,EACZC,WAAYA,GA5BP5Q,EAAOa,MAJP,SAqCPgT,GAAiB,SAAC,GAAgC,IAA/B3D,EAA8B,EAA9BA,WAAYC,EAAkB,EAAlBA,aAC7BvC,EAAOsC,EAAWrT,OAAS,EACjC,OAAOqT,EAAW5K,KAAI,SAACuK,EAAWjT,GAChC,IAAMmV,EAAoB,IAANnV,EACdoV,EAAapV,IAAMgR,EACzB,OACE,cAACgC,EAAD,CAGEC,UAAWA,EACX8C,UAAWxC,EAAa,CAAC4B,cAAaC,gBAFjCpV,OAQPkX,GAAc,SAAC,GAAD,IAClBrU,EADkB,EAClBA,QACAyP,EAFkB,EAElBA,OACAjJ,EAHkB,EAGlBA,aACAyN,EAJkB,EAIlBA,gBACAvD,EALkB,EAKlBA,aALkB,OAOlB1Q,EAAQ6F,KAAI,SAACtF,EAAQpD,GACnB,IAAMsT,EAAahB,EAAOtS,GAC1B,OAAKsT,EAIH,cAAC,GAAD,CAEEA,WAAYA,EACZC,aAAc,SAAA4D,GAAW,OACvB5D,EAAa,2BACR4D,GADO,IAEVH,SAAU5T,EAAOa,QAAP,OAAgBoF,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAcpF,MACxCsR,aAAcrL,QAAQ4M,EAAgB1T,EAAOa,OAC7Cb,cAPCA,EAAOa,MAJP,SAkBPmT,GAA0B,CAC9BC,KAAM,gBAAElC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,WAAY4B,EAA3B,EAA2BA,SAAUzB,EAArC,EAAqCA,aAAcnS,EAAnD,EAAmDA,OAAnD,kDACiCA,EAAOyD,KADxC,iBAEFsO,EAAc,kCAAoC,IAFhD,OAGDC,EAAa,iCAAmC,IAH/C,OAIF4B,EAAW,8BAAgC,IAJzC,OAKDzB,EAAe,iCAAmC,KACvD+B,MAAO,gBAAEnC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,WAAY4B,EAA3B,EAA2BA,SAAUzB,EAArC,EAAqCA,aAAcnS,EAAnD,EAAmDA,OAAnD,oDACkCA,EAAOyD,KADzC,iBAEHsO,EAAc,mCAAqC,IAFhD,OAGFC,EAAa,kCAAoC,IAH/C,OAIH4B,EAAW,+BAAiC,IAJzC,OAKFzB,EAAe,kCAAoC,KACxDgC,IAAK,gBAAEnU,EAAF,EAAEA,OAAF,oDACoCA,EAAOyD,KAD3C,gBAsIQ2Q,GAlIc,WAIjB,IAAD,yDAAP,GAAO,IAHTC,8BAGS,MAHgB,QAGhB,MAFTzD,kBAES,MAFI,SAEJ,EADS0D,EACT,EADTC,iBAEMA,EAAmB,CACvBL,OAA2B,OAApBI,QAAoB,IAApBA,OAAA,EAAAA,EAAsBJ,OACzB,SAAAM,GAAM,uBACJF,EAAqBJ,MACnBM,EACAR,GAAwBE,MAAMM,WAH5B,QAICR,GAAwBE,MAAMM,IACrCR,GAAwBE,MAC5BD,MAA0B,OAApBK,QAAoB,IAApBA,OAAA,EAAAA,EAAsBL,MACxB,SAAAO,GAAM,uBACJF,EAAqBL,KACnBO,EACAR,GAAwBC,KAAKO,WAH3B,QAICR,GAAwBC,KAAKO,IACpCR,GAAwBC,KAC5BE,KAAyB,OAApBG,QAAoB,IAApBA,OAAA,EAAAA,EAAsBH,KACvB,SAAAK,GAAM,uBACJF,EAAqBH,IACnBK,EACAR,GAAwBG,IAAIK,WAH1B,QAICR,GAAwBG,IAAIK,IACnCR,GAAwBG,KAE9B,OAAO,eAACnS,EAAD,uDAAY,WAAZ,OACLC,sBACE,WAgBEnF,GACI,IAAD,MAfDmR,uBAeC,MAfiBoG,EAejB,EAdDhE,EAcC,EAdDA,eACAL,EAaC,EAbDA,aACA0D,EAYC,EAZDA,gBACAlD,EAWC,EAXDA,oBACAC,EAUC,EAVDA,uBACUgE,EAST,EATDC,SACUC,EAQT,EARDC,SACiBC,EAOhB,EAPDxM,gBACsByM,EAMrB,EAND1S,qBACe2S,EAKd,EALDxM,cACAsB,EAIC,EAJDA,GACGxH,EAGF,iBACGjF,EAAaC,iBAAO,CAACoC,QAAS,KAC9B8I,EAAgBlL,mBAEhBiF,EAAWjF,mBAEjB,EAA4BuL,mBAAS,IAArC,mBAAOsG,EAAP,KAAe8F,EAAf,KACA,EAA8BpM,mBAASxL,EAAWL,QAAQ0C,SAA1D,mBAAOA,EAAP,KAAgBuJ,EAAhB,KACA,EAAwCJ,mBAAS,MAAjD,mBAAO3C,EAAP,KAAqBgP,EAArB,KA4BA,OANA1K,qBAAU,WACR,IAAM/H,EAAWF,EAASvF,QAC1BK,EAAWL,QAAQ0C,QAAUA,EAC7BuV,EAAUjG,EAAevM,EAAU/C,MAClC,CAACA,IAGF,sBACEoK,GAAIA,EACJ8I,UAAU,qBACV5G,MAAO,CAACkC,kBAAiB0B,MAAK,UAAEtN,EAAU0J,aAAZ,aAAE,EAAiB4D,OAHnD,UAIE,qBAAKgD,UAAU,gBAAf,SACE,cAAC,GAAD,CACElT,QAASrC,EAAWL,QAAQ0C,QAC5BwG,aAAcA,EACdiJ,OAAQA,EACRwE,gBAAiBA,EACjBvD,aAAcoE,EAAiBN,SAGnC,cAACjS,EAAD,yBACElF,IAAKN,EAAUM,EAAKwF,IAChBD,GAFN,IAGEwH,GAAIA,EACJtB,cAAe/L,EAAU+L,EAAewM,GACxCH,SAxCW,SAAArS,GACf,IAAMC,EAAWF,EAASvF,QAC1BiY,EAAUjG,EAAevM,EAAU/C,IACnCkV,GAAsBA,EAAmBpS,IAsCrCmS,SA9CW,SAAAnS,GACf,IAAMC,EAAWF,EAASvF,QAC1BiY,EAAUjG,EAAevM,EAAU/C,IACnCgV,GAAsBA,EAAmBlS,IA4CrC8F,gBArCkB,SAAA9F,GACtB,IAAM9C,EAAU8C,EAAE9C,QAClBuJ,EAAWvJ,GACXoV,GAA6BA,EAA0BtS,IAmCnDH,qBAjCuB,SAAAG,GAC3B,IAAM0D,EAAe1D,EAAE9C,QAAQ8C,EAAEzE,mBACjCmX,EAAgBhP,GAChB6O,GAAkCA,EAA+BvS,OAgC/D,qBAAKoQ,UAAU,iBAAf,SACE,cAAC,GAAD,CACElT,QAASrC,EAAWL,QAAQ0C,QAC5BwG,aAAcA,EACdiJ,OAAQA,EACRiB,aAAcoE,EAAiBL,MAC/BT,gBAAiBc,EAAiBJ,IAClC9D,eAAgBA,EAChBL,aAAcA,EACd0D,gBAAiBA,EACjBlD,oBAAqBA,EACrBC,uBAAwBA,EACxBC,gBAAiBnI,EAAcxL,QAC/B4T,WAAY9G,EACZ+G,WAAYA,c,gBCroBbsE,GA9BI,eAAClT,EAAD,uDAAY,WAAZ,OACjBC,sBAAW,WAA2BnF,GAAS,IAAD,EAAjC4X,EAAiC,EAAjCA,SAAarS,EAAoB,kBACtCjF,EAAaC,iBAAO,IAC1BD,EAAWL,QAAQ2X,SAAWA,EAE9B,IAAMS,EAAY9X,mBAelB,OAbAkN,qBAAU,WACR,IACM6K,EADaD,EAAUpY,QACGsY,cAOhC,OADAD,EAAaE,SALY,SAAA/S,GACnBnF,EAAWL,QAAQ2X,UACrBtX,EAAWL,QAAQ2X,SAASnS,IAIzB,WACL6S,EAAaE,SAAW,QAEzB,IAED,sBACE3C,UAAU,iCACV5G,MAAO,CAAC4D,MAAK,UAAEtN,EAAU0J,aAAZ,aAAE,EAAiB4D,OAFlC,UAGE,wBAAQ7S,IAAKqY,EAAWI,MAAM,iBAC9B,cAACvT,EAAD,aAAUlF,IAAKA,GAASuF,W,yBCcjBmT,GAtCa,eAACxT,EAAD,uDAAY,WAAZ,OAC1BC,sBAAW,WAAoCnF,GAAS,IAA3CqF,EAA0C,EAA1CA,kBAAsBE,EAAoB,kBAC/CjF,EAAaC,iBAAO,IAC1BD,EAAWL,QAAQoF,kBAAoBA,EAEvC,IAAMG,EAAWjF,mBA8BjB,OA5BAkN,qBAAU,WACR,IAAM/H,EAAWF,EAASvF,QACpB0Y,EAA4B,SAAAlT,GAChC,IAAMC,EAAWF,EAASvF,QAExByF,IAAa+I,SAASmK,eACtBtY,EAAWL,QAAQoF,mBAEnB/E,EAAWL,QAAQoF,kBAAkB,CAACM,OAAQD,KAGlD+I,SAASoK,iBAAiB,kBAAmBF,GAC7C,IAAMG,EAAkB,SAAArT,GAEtB,IAAMC,EAAWF,EAASvF,QACZ,WAAVwF,EAAEiC,KAA8B,cAAVjC,EAAEiC,KAC1BpH,EAAWL,QAAQoF,kBAAkB,CAACM,OAAQD,KAIlD,OADAA,EAASmT,iBAAiB,QAASC,GAC5B,WACLrK,SAASsK,oBACP,kBACAJ,GAEFjT,EAASqT,oBAAoB,QAASD,MAEvC,IACI,cAAC5T,EAAD,aAAUlF,IAAKN,EAAUM,EAAKwF,IAAeD,Q,0DC5B3CyT,IAAY,EACZC,IAAe,EAIfC,GAAmB,SAE1BC,GACJ,SAAAjG,GAAY,OACZ,YAA6B,IAA3BoD,EAA0B,EAA1BA,OAAW/Q,EAAe,kBACpBjF,EAAaC,iBAAO,IAa1B,OAXAD,EAAWL,QAAQqW,OAASA,EAE5B7I,qBAAU,WACR,IAAM2L,EAAW,SAAA3T,GACD,WAAVA,EAAEiC,KACJpH,EAAWL,QAAQqW,UAIvB,OADA7H,SAASoK,iBAAiB,QAASO,GAC5B,kBAAM3K,SAASsK,oBAAoB,QAASK,MAClD,IACI,cAAClG,EAAD,aAAcoD,OAAQA,GAAY/Q,MAGvC8T,GACJ,eAACC,EAAD,uDAAkB,kBAAML,IAAxB,OACA,YAAsD,IAApDnV,EAAmD,EAAnDA,WAAYyV,EAAuC,EAAvCA,eAAgBC,EAAuB,EAAvBA,kBACtBC,EAA0BH,EAAe,CAC7CxV,aACAyV,iBACAC,sBAEF,OAAIE,MAAMC,QAAQF,GACTA,EAELA,IAA4BT,GACvBO,EAvCa,IAyClBE,GAA2CD,EAGxCD,EAAe5N,QAAO,qBAAEhF,OAAmB6S,KAFzC,KAqNEI,GAhNE,WAA+C,IAAD,yDAAP,GAArC1G,EAA4C,EAA5CA,aAA4C,IAA9B2G,oBAA8B,SAI7D,OAHIA,IACF3G,EAAeiG,GAAoBjG,IAE9B,eAAChO,EAAD,uDAAY,WAAZ,OACLC,sBACE,WAMEnF,GACI,IALFyL,EAKC,EALDA,cACsBuM,EAIrB,EAJD1S,qBACGC,EAGF,kBACGjF,EAAaC,iBAAO,IAC1B,EAA0DuL,mBAAS,CACjEgB,KAAM,GACNgN,UAAW,KAFb,mBAAclD,EAAd,KAAQ9J,KAAwBiN,EAAhC,KAKMpG,EAAyBmB,uBAAY,YAAsB,IAApB5R,EAAmB,EAAnBA,OAAQuR,EAAW,EAAXA,MAC7C3Q,GAAmB,OAANZ,QAAM,IAANA,OAAA,EAAAA,EAAQa,OAAQb,EACnC6W,GAAuB,SAAAC,GACrB,IAAaC,EACXD,EADKlN,KAA2BoN,EAChCF,EADqBF,UAGvB,OAAKG,EAASnW,GAIP,CACLgJ,KAAK,2BACAmN,GADD,kBAEDnW,EAFC,2BAGGmW,EAASnW,IAHZ,IAIA2Q,YAGJqF,UAAWI,GAXJF,OAcV,IACGtG,EAAsBoB,uBAC1B,YAA0D,IAAxD5R,EAAuD,EAAvDA,OAAQyD,EAA+C,EAA/CA,KAAM0N,EAAyC,EAAzCA,QAASH,EAAgC,EAAhCA,eAAgBiG,EAAgB,EAAhBA,WACvCA,EAAad,GAAec,GAC5B,IAAMrW,GAAmB,OAANZ,QAAM,IAANA,OAAA,EAAAA,EAAQa,OAAQb,EAuCnC6W,EAtCK1F,GAAYvQ,EAsCM,SAAAkW,GAAwB,IAAD,IAC/BC,EACXD,EADKlN,KAA2BoN,EAChCF,EADqBF,UAQvB,KALAzF,EACEA,IAAY6E,KACR,UAACgB,EAAcpW,UAAf,aAAC,EAA2BsW,MAAK,SAAAtN,GAAI,OAAIA,EAAKnG,OAASA,MACvDqD,QAAQqK,IAEA,CACZ,IAAMgG,EAAeH,EAAcpW,GACnC,IAAKuW,EACH,OAAOL,EAET,IAAMM,EAAyBH,EAAW,CACxCrW,aACAyV,eAAgBc,EAChBb,kBAAmB7S,IAGrB,GAAI2T,EAAuBva,OAAQ,CACjC,IAAMwa,EACJD,EAAuBA,EAAuBva,OAAS,GACzD,MAAO,CACL+M,KAAK,2BACAmN,GADD,kBAEDnW,EAAa,CACZ6C,KAAM4T,EAAY5T,KAClBuN,eAAgBqG,EAAYrG,eAC5BO,MAAOwF,EAASnW,GAAY2Q,SAGhCqF,UAAU,2BACLI,GADI,kBAENpW,EAAawW,KAKpB,IAAME,EAAW,eAAOP,UACjBO,EAAY1W,GAEnB,IAAM2W,EAAY,eAAOP,GAGzB,cAFOO,EAAa3W,GAEb,CACLgJ,KAAM0N,EACNV,UAAWW,GAIf,OADA9T,EAAOA,GAAQ,gBACR,CACLmG,KAAK,2BACAmN,GADD,kBAEDnW,EAAa,CACZ6C,OACAuN,eAAc,OAAEA,QAAF,IAAEA,KAChBO,MAAK,UAAEwF,EAASnW,UAAX,aAAE,EAAsB2Q,SAGjCqF,UAAU,2BACLI,GADI,kBAENpW,EAFM,uBAGDoW,EAAcpW,IAAe,IAAI6H,QACnC,SAAAmB,GAAI,OAAIA,EAAKnG,OAASA,MAJnB,CAML,CAACA,OAAMuN,eAAc,OAAEA,QAAF,IAAEA,YAvGN,SAAA8F,GACrB,IAAaC,EACXD,EADKlN,KAA2BoN,EAChCF,EADqBF,UAEjBU,EAAW,eAAOP,GAClBS,EAAgB,eAAOR,GAE7B,IAAK,IAAMpW,KAAc4W,EAAkB,CACzC,IAAMJ,EAAyBH,EAAW,CACxCrW,aACAyV,eAAgBW,EAAcpW,GAC9B0V,kBAAmB7S,IAErB,GAAI2T,EAAuBva,OAAQ,CACjC2a,EAAiB5W,GAAcwW,EAE/B,IAAM7F,EAAQ+F,EAAY1W,GAAY2Q,MAChC8F,EACJG,EAAiB5W,GACf4W,EAAiB5W,GAAY/D,OAAS,GAE1Cya,EAAY1W,GAAc,CACxB6C,KAAM4T,EAAY5T,KAClBuN,eAAgBqG,EAAYrG,eAC5BO,qBAGKiG,EAAiB5W,UACjB0W,EAAY1W,GAGvB,MAAO,CACLgJ,KAAM0N,EACNV,UAAWY,OA6EnB,IAGF,EAA6Bxa,EAC3BuL,GACA,iBAAO,CACLiI,yBAEF,CAACA,IALIlG,EAAP,oBAQA,OACE,cAACtI,EAAD,yBACElF,IAAKA,GACDuF,GAFN,IAGEkG,cAAe+B,EACf0F,aAAcA,EACd0D,gBAAiBA,EACjBlD,oBAAqBA,EACrBC,uBAAwBA,EACxBrO,qBAAsB,SAAAG,GACpB,IACM0D,EAD+B1D,EAA9B9C,QAA8B8C,EAArBzE,mBAEV2Z,EAAkBra,EAAWL,QAAQkJ,aAC3C7I,EAAWL,QAAQkJ,aAAeA,EAEhCwR,GACAA,EAAgB5W,QAAhB,OAAyBoF,QAAzB,IAAyBA,OAAzB,EAAyBA,EAAcpF,OAEvC2P,EAAoB,CAClBxQ,OAAQyX,EACRtG,SAAS,EACT1N,KAAM,WAGNwC,GAAgBA,IAAiBwR,GAEnCjH,EAAoB,CAClBxQ,OAAQiG,EACRkL,SAAS,EACT1N,KAAM,WAGVqR,GACEA,EAA+BvS,Y,oECpLhCmV,GAzEY,SAAA1V,GAAQ,OACjCC,sBACE,WAOEnF,GACI,IANF4W,EAMC,EANDA,gBACAlD,EAKC,EALDA,oBACsBsE,EAIrB,EAJD1S,qBACGC,EAGF,kBACGC,EAAWjF,mBACXD,EAAaC,iBAAO,IAC1BD,EAAWL,QAAQ2W,gBAAkBA,EACrCtW,EAAWL,QAAQyT,oBAAsBA,EAEzCjG,qBAAU,WACR,IAAM/H,EAAWF,EAASvF,QACpBmZ,EAAW,SAAA3T,GACf,IAAM0D,EAAe7I,EAAWL,QAAQkJ,aACxC,GAAe,cAAV1D,EAAEiC,KAAiC,YAAVjC,EAAEiC,MAAsByB,EAkBpD7I,EAAWL,QAAQyT,oBAAoB,CACrCW,SAAS,EACT1N,KAAM,iBApB0D,CAClErG,EAAWL,QAAQyT,oBAAoB,CACrCxQ,OAAQiG,EACRkL,SAAS,EACT1N,KAAM,aAER,IAAM7C,EAAaqF,EAAapF,KAChCgK,YAAW,WACT,IAAM8M,EAAUva,EAAWL,QAAQ2W,gBAAgB9S,IACnD,OAAI+W,QAAJ,IAAIA,OAAJ,EAAIA,EAASpG,QACXoG,EAAQpG,MAAM,CACZE,MAAiB,cAAVlP,EAAEiC,IAAsB,GAAK,OAI1CjC,EAAEwI,iBACFxI,EAAEqV,oBASN,OADApV,EAASmT,iBAAiB,UAAWO,GAC9B,kBAAM1T,EAASqT,oBAAoB,SAAUK,MACnD,IAeH,OACE,cAAClU,EAAD,aACElF,IAAKN,EAAUM,EAAKwF,GACpBF,qBAhByB,SAAAG,GAC3B,IAAM0D,EAAe1D,EAAE9C,QAAQ8C,EAAEzE,mBAC3B+Z,EAAmBza,EAAWL,QAAQkJ,aACxC4R,GAAoBA,EAAiBhX,QAAjB,OAA0BoF,QAA1B,IAA0BA,OAA1B,EAA0BA,EAAcpF,OAC9DzD,EAAWL,QAAQyT,oBAAoB,CACrCW,SAAS,EACT1N,KAAM,aAGVrG,EAAWL,QAAQkJ,aAAeA,EAClC6O,GAAkCA,EAA+BvS,IAO/DmR,gBAAiBA,EACjBlD,oBAAqBA,GACjBnO,Q,gCCQCyV,GArEwC,SAAA9V,GAAQ,OAC7DC,sBAAW,WAA0CnF,GAAS,IAAjD+M,EAAgD,EAAhDA,GAAI2G,EAA4C,EAA5CA,oBAAwBnO,EAAoB,kBACrDC,EAAWjF,mBACXD,EAAaC,iBAAO,IAwD1B,OAvDAD,EAAWL,QAAQyT,oBAAsBA,EAEzCjG,qBAAU,WACR,IAAMwN,EAAU3a,EAAWL,QACrBib,EAAgB,SAAAzV,GAKpB,IAJA,IAAI5E,EAAO4E,EAAEE,OACTwV,GAAa,EACbC,GAAQ,EACRC,GAAW,EACRxa,GAAM,CAAC,IAAD,IAIX,GAHAsa,EAAata,EAAKkM,KAAOA,EACzBqO,GAAQ,UAAAva,EAAKya,eAAL,eAAcC,kBAAmBxO,EACzCsO,GAAW,UAAAxa,EAAKya,eAAL,eAAcE,wBAAyBzO,EAC9CoO,GAAcC,GAASC,EACzB,MAEFxa,EAAOA,EAAK8N,WAEd,GAAKwM,GAAeC,GAAUC,EAKvB,CACL,IAAMI,EAAmBJ,GAAYxa,EAAKya,QAAQI,mBAClDT,EAAQvH,oBAAoB,CAC1BW,SAAS,EACT1N,KAAM,aACNwT,WAAY,YAAmC,IAAjCrW,EAAgC,EAAhCA,WAAgC,EAApByV,eACxB,OAAIzV,IAAe2X,EACVxC,GAEFD,MAGPqC,EACFJ,EAAQvH,oBAAoB,CAC1BxQ,OAAQuY,EACRpH,QAAS6E,GACTvS,KAAM,aACNwT,WAAY,kBF5CA,KE8CLiB,GACTH,EAAQvH,oBAAoB,CAC1BxQ,OAAQrC,EAAKya,QAAQK,aACrBtH,SAAS,EACT1N,KAAM,oBA3BVsU,EAAQvH,oBAAoB,CAC1BW,SAAS,IAEX5O,EAAEwI,kBA8BN,OADAQ,SAASoK,iBAAiB,QAASqC,GAC5B,kBAAMzM,SAASsK,oBAAoB,QAASmC,MAClD,CAACnO,IAGF,cAAC7H,EAAD,aACE6H,GAAIA,EACJ/M,IAAKN,EAAUM,EAAKwF,GACpBkO,oBAAqBA,GACjBnO,QClCGqW,GApC0B,SAAA1W,GAAQ,OAC/CC,sBAAW,SAACuG,EAAO1L,GACjB,IAAMwF,EAAWjF,mBA+BjB,OA7BAkN,qBAAU,WAER,IAAM/H,EAAWF,EAASvF,QACpB4b,EAAU,SAAApW,GAEd,OADAA,EAAEwI,kBACK,GAEH6N,EAAkB,SAAArW,GACtB,OAAmB,KAAdA,EAAEsW,SAAgC,KAAdtW,EAAEsW,UAAmBtW,EAAEuW,UAE9CvW,EAAEwI,kBACK,IASX,OALAvI,EAASmT,iBAAiB,YAAagD,GACvCnW,EAASmT,iBAAiB,YAAagD,GACvCnW,EAASmT,iBAAiB,WAAYgD,GACtCnW,EAASmT,iBAAiB,UAAWgD,GACrCnW,EAASmT,iBAAiB,UAAWiD,GAC9B,WACLpW,EAASqT,oBAAoB,YAAa8C,GAC1CnW,EAASqT,oBAAoB,YAAa8C,GAC1CnW,EAASqT,oBAAoB,WAAY8C,GACzCnW,EAASqT,oBAAoB,UAAW8C,GACxCnW,EAASqT,oBAAoB,UAAW+C,MAEzC,IAEI,cAAC5W,EAAD,aAAUlF,IAAKN,EAAUM,EAAKwF,IAAekG,Q,oCCFzCuQ,GA/BU,eAAC/W,EAAD,uDAAY,WAAZ,OACvBgX,IAAM/W,YAAW,WAA6CnF,GAAQ,EAAnD2C,QAAoD,IAA3C8I,EAA0C,EAA1CA,cAAesB,EAA2B,EAA3BA,GAAOxH,EAAoB,kBAC9DC,EAAWjF,mBAoBjB,OAnBAK,8BACE6K,GACA,iBAAO,CACLgJ,MAAO,SAAA1T,GACL,IAAM2E,EAAWF,EAASvF,QAC1ByF,EAAS+O,QACL1T,IACuB,kBAAdA,GACT2E,EAASjE,eAAiBV,EAC1B2E,EAAShE,aAAeX,IAExB2E,EAASjE,eAAiBV,EAAUU,eACpCiE,EAAShE,aAAeX,EAAUW,mBAK1C,IAGA,cAACwD,EAAD,aACElF,IAAKN,EAAUM,EAAKwF,GACpBuH,GAAE,UAAKA,EAAL,cACExH,QCRG4W,GArBS,SAAAC,GAAQ,OAAI,SAAA/U,GAClC,IAAMgV,EAAQD,EAAS/U,GACvB,MAAO,CACLiV,QAAS,SAAAC,GACP,IACE,OAAOF,EAAMC,QAAQC,GACrB,MAAOvO,GAEP,YADApC,QAAQ4Q,MAAM,2BAA4BxO,KAI9CyO,QAAS,SAACF,EAAU9b,GAClB,IACE4b,EAAME,GAAY9b,EAClB,MAAOuN,GACPpC,QAAQ4Q,MAAM,2BAA4BxO,QCLnC0O,GAVS,WACtB,IAAML,EAAQ,GACd,MAAO,CACLC,QAAS,SAAAC,GAAQ,OAAIF,EAAME,IAC3BE,QAAS,SAACF,EAAU9b,GAClB4b,EAAME,GAAY9b,KCiCTkc,GAbK,SAACC,EAAOC,EAAaC,GACvC,GAA2B,oBAAhBA,EAA4B,CACrC,IAAMpV,EAAMoV,EACZA,EAAc,SAAAC,GAAI,OAAIA,EAAKrV,IAG7B,IADA,IAAMsV,EAAQ,GACLld,EAAI,EAAGA,EAAI8c,EAAM7c,OAAQD,IAAK,CACrC,IAAMid,EAAOH,EAAM9c,GACnBkd,EAAMF,EAAYC,IAASF,EAAYE,EAAMjd,EAAG8c,GAElD,OAAOI,GCZMC,GAHK,SAACL,EAAOM,GAAR,OAClBN,EAAMjR,QAAO,SAAAoR,GAAI,OArBS,SAACA,EAAMG,GACjC,IAAMC,GAAuB,OAACD,QAAD,IAACA,IAAc,IAAIE,cAChD,GAAoB,kBAATL,EACT,OAAOA,EAAKK,cAAcC,SAASF,GAGrC,IAAK,IAAMrd,KAAKid,EAAM,CACpB,IAAMO,EAAMP,EAAKjd,GACjB,GACO,kBADQwd,GAEPA,EAAIF,cAAcC,SAASF,GAC7B,OAAO,EAOf,OAAO,EAGcI,CAAoBR,EAAMG,OCdlCM,GANb,SAAAC,GAAM,OACN,WACE,IAAMC,EAAMD,EAAM,WAAN,aACZ,OAAOE,QAAQC,UAAUC,MAAK,kBAAMH,O,UCMzBI,GAPb,SAAAC,GAAK,OACL,eAAC7Y,EAAD,uDAAY,WAAZ,OACEC,sBAAW,WAAqBnF,GAAS,IAA5B+M,EAA2B,EAA3BA,GAAOxH,EAAoB,kBAChCsO,EAAatT,iBAAOwM,GAAMgR,KAAS9d,QACzC,OAAO,cAACiF,EAAD,aAAUlF,IAAKA,EAAK+M,GAAI8G,GAAgBtO,S,0BCWtCyY,GAfb,SAAC,GAAD,QAAEC,yBAAF,MAAsB,OAAtB,EAA8BC,EAA9B,EAA8BA,aAA9B,OACA,eAAChZ,EAAD,uDAAY,WAAZ,OACEC,sBAAW,WAAoCnF,GAApC,YAAE6S,EAAF,EAAEA,MAAOvC,EAAT,EAASA,WAAe/K,EAAxB,yBACT,cAACL,EAAD,yBACElF,IAAKA,GACDuF,GAFN,IAGE0J,MAAK,2BACA1J,EAAU0J,OADV,IAEH4D,MAAK,iBAAEA,QAAF,IAAEA,IAAF,UAAWtN,EAAU0J,aAArB,aAAW,EAAiB4D,aAA5B,QAAqCqL,EAC1C5N,WAAU,iBACRA,QADQ,IACRA,IADQ,UACM/K,EAAU0J,aADhB,aACM,EAAiBqB,kBADvB,QACqC2N,Y,oBC6F1CE,GAvGoB,SAAC,GAQ7B,IAPLzR,EAOI,EAPJA,QACA+Q,EAMI,EANJA,OACApB,EAKI,EALJA,MACA+B,EAII,EAJJA,YAII,IAHJC,mBAGI,MAHU,SAAAC,GAAQ,OAAI9H,KAAKC,UAAU6H,IAGrC,MAFJC,wBAEI,MAFe,kBAAM,GAErB,EADJC,EACI,EADJA,aAEAJ,EACEA,GACC,YAIC,IAJc,IAAblb,EAAY,EAAZA,OACK0D,EAAc1D,EAAO0D,YACrBE,EAAW5D,EAAO4D,SAClBwX,EAAW,GACRxe,EAAI,EAAGA,EAAI8G,EAAY7G,OAAQD,IAAK,CAC3C,IAAM2e,EAAc7X,EAAY9G,GAAG4H,IAEnC,GADA4W,EAASG,GAAe3X,EAAS2X,GAC7BA,IAAgB/R,EAClB,OAAO4R,EAGX,OAAOA,GA8EX,OA3E6B,SAAC,GAAwC,IAAvCpb,EAAsC,EAAtCA,OAAQP,EAA8B,EAA9BA,QAASiR,EAAqB,EAArBA,gBACxCtT,EAAaC,iBAAO,IAE1B,EAAiDuL,mBAAS,IAA1D,0BAAQ4S,EAAR,EAAQA,QAASlC,EAAjB,EAAiBA,MAAOmC,EAAxB,EAAwBA,MAAQC,EAAhC,KAEM9R,EAAO5J,EAAO6D,UAAU2F,GAExB4R,OADkBvT,IAAT+B,GAAsByR,EAAiBzR,GAC5BsR,EAAY,CAAC1R,UAASxJ,SAAQP,YAAY,KAC9D4Z,EAAW+B,EAAWD,EAAYC,GAAY,KAEpDhe,EAAWL,QAAQqe,SAAWA,EAC9Bhe,EAAWL,QAAQ2T,gBAAkBA,EACrCtT,EAAWL,QAAQsc,SAAWA,EAC9Bjc,EAAWL,QAAQiD,OAASA,EAE5B,IAAM2b,EAAgB/J,uBACpB,kBACE8J,GAAc,SAAAE,GAAU,wCACnBA,GADmB,IAEtBH,OAAO,UAACG,EAAWH,aAAZ,QAAqB,GAAK,SAErC,IAoDF,OAjDAlR,qBAAU,WACR,MAA2BnN,EAAWL,QAA/Bqe,EAAP,EAAOA,SAAUpb,EAAjB,EAAiBA,OACjB,GAAKob,EAAL,CAGA,IAAMS,EAAa1C,EAAMC,QAAQC,GACjC,GAAIwC,GAA6B,OAAfA,EAWhB,OAVAze,EAAWL,QAAQ2T,gBAAgBnH,iBACjC,CACEC,UACAxJ,UAEF,CACE4J,KAAMiS,SAGVH,EAAc,IAGhB,IAAMI,EAAY,IAAIC,KA2BtB,OA1BAL,EAAc,CAACF,SAAS,IACxBjB,EAAOa,EAAUU,EAAUE,QACxBrB,MAAK,SAAAsB,GAAW,IAAD,EACdA,EAAM,UAAGA,SAAH,QAAa,KACnB9C,EAAMI,QAAQF,EAAU4C,GACpB5C,IAAajc,EAAWL,QAAQsc,WAClCjc,EAAWL,QAAQ2T,gBAAgBnH,iBACjC,CACEC,UACAxJ,UAEF,CACE4J,KAAMqS,IAGVP,EAAc,QAGjBQ,OAAM,SAAA5C,GACDgC,EAAahC,IAGbD,IAAajc,EAAWL,QAAQsc,UAClCqC,EAAc,CAACpC,aAGd,kBAAMwC,EAAUK,YACtB,CAAC9C,EAAUoC,IAEP,CAACD,UAASlC,QAAO8B,WAAUxR,OAAM6R,MAAOE,KCkBpCS,GApHe,SAAC,GAaxB,IAZLC,EAYI,EAZJA,WACA7S,EAWI,EAXJA,QACA8S,EAUI,EAVJA,UACAC,EASI,EATJA,kBACAhC,EAQI,EARJA,OACAc,EAOI,EAPJA,iBACAH,EAMI,EANJA,YACAC,EAKI,EALJA,YACAqB,EAII,EAJJA,gBACAC,EAGI,EAHJA,eACAvD,EAEI,EAFJA,SACAoC,EACI,EADJA,aAEMnC,EAAQD,EAAS,CAACzV,KAAM,UAAW4Y,aAAY7S,YAErD+S,EAAoBA,GAAqBD,EAEzC,IAAMI,EAAsBzB,GAA2B,CACrDzR,UACA+Q,SACApB,QACA+B,cACAC,cACAE,mBACAC,iBAGF,OAAO,YASA,IARLtb,EAQI,EARJA,OACAP,EAOI,EAPJA,QACA0T,EAMI,EANJA,YACAC,EAKI,EALJA,OACA1C,EAII,EAJJA,gBACAiB,EAGI,EAHJA,mBACAO,EAEI,EAFJA,WACAD,EACI,EADJA,aAEA,EAAgDyK,EAAoB,CAClE1c,SACAP,UACAiR,oBAHK8K,EAAP,EAAOA,QAASlC,EAAhB,EAAgBA,MAAO1P,EAAvB,EAAuBA,KAAMwR,EAA7B,EAA6BA,SAAUK,EAAvC,EAAuCA,MAMvC,OAAInC,EAEA,cAACmD,EAAD,CACEnD,MAAOA,EACPmC,MAAOA,EACPjS,QAASA,EACT4R,SAAUA,EACVpb,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAKV,OAAT9G,EAEA,cAAC2S,EAAD,CACE3S,KAAM,KACNJ,QAASA,EACT4R,SAAUA,EACVpb,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAKnB8K,IAAY5R,EAEZ,cAAC4S,EAAD,CACEhT,QAASA,EACT4R,SAAUA,EACVpb,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAMrB,cAAC4L,EAAD,CACE1S,KAAMA,EACNJ,QAASA,EACT4R,SAAUA,EACVpb,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,MClGViM,GAbU,SAACpf,EAAOqf,GAC/B,MAA4ChU,mBAASrL,GAArD,mBAAOsf,EAAP,KAAuBC,EAAvB,KASA,OAPAvS,qBAAU,WACR,IAAMwS,EAAIlS,YAAW,WACnBiS,EAAkBvf,KACjBqf,GACH,OAAO,kBAAMhS,aAAamS,MACzB,CAACxf,EAAOqf,IAEJC,GC+FMG,GAvGmB,SAAC,GAY5B,IAXLxT,EAWI,EAXJA,QACA+Q,EAUI,EAVJA,OACApB,EASI,EATJA,MASI,IARJ8D,qBAQI,MARY,kBAA2B,CACzCjD,WADc,EAAEA,WAEhBpW,SAFc,EAAc5D,OAEX4D,WAMf,MAJJuX,mBAII,MAJU,SAAA+B,GAAU,OAAI5J,KAAKC,UAAU2J,IAIvC,EAHJC,EAGI,EAHJA,cACAC,EAEI,EAFJA,iBACA9B,EACI,EADJA,aAyFA,OAvF4B,SAAC,GAAuB,IAAD,EAArBtb,EAAqB,EAArBA,OAAQP,EAAa,EAAbA,QAC9BrC,EAAaC,iBAAO,IAEpB2c,EAAaha,EAAO2D,UAAU6F,GAE9B0T,EAAU,UACdD,EAAc,CACZjD,aACAxQ,UACAxJ,SACAP,mBALY,QAMR,KAEF4Z,EAAyB,MAAd6D,EAAqB/B,EAAY+B,GAAc,KAC1DG,EAAoBV,GAAiBtD,EAAU+D,GAE/CE,EAAwB,OAAbjE,EAEjB,EACEzQ,mBAAS,IADX,0BAAQ4S,EAAR,EAAQA,QAASlC,EAAjB,EAAiBA,MAAOiE,EAAxB,EAAwBA,QAASC,EAAjC,EAAiCA,gBAAiB/B,EAAlD,EAAkDA,MAAQgC,EAA1D,KAGMC,EAA2BF,IAAoBnE,EAErDjc,EAAWL,QAAQiD,OAASA,EAC5B5C,EAAWL,QAAQ0C,QAAUA,EAC7BrC,EAAWL,QAAQmgB,WAAaA,EAEhC,IAAMvB,EAAgB/J,uBACpB,kBACE6L,GAAe,SAAAE,GAAW,wCACrBA,GADqB,IAExBlC,OAAO,UAACkC,EAAYlC,aAAb,QAAsB,GAAK,SAEtC,IA2CF,OAxCAlR,qBAAU,WAER,GADAnN,EAAWL,QAAQsc,SAAWgE,EACJ,OAAtBA,EAAJ,CAKA,IAAMH,EAAa9f,EAAWL,QAAQmgB,WAEhCU,EAAgBzE,EAAMC,QAAQiE,GACpC,IAAIO,EAAJ,CAOA,IAAM9B,EAAY,IAAIC,KAoBtB,OAnBA0B,EAAe,CAACjC,SAAS,IACzBjB,EAAO2C,EAAYpB,EAAUE,QAC1BrB,MAAK,SAAA4C,GACJpE,EAAMI,QAAQ8D,EAAmBE,GAC7BngB,EAAWL,QAAQsc,WAAagE,GAClCI,EAAe,CACbF,QAASJ,EAAcI,EAASL,GAChCM,gBAAiBH,OAItBnB,OAAM,SAAA5C,GACDgC,EAAahC,IAGblc,EAAWL,QAAQsc,WAAagE,GAClCI,EAAe,CAACnE,aAGf,kBAAMwC,EAAUK,SA1BrBsB,EAAe,CACbF,QAASJ,EAAcS,EAAeV,GACtCM,gBAAiBH,SAVnBI,EAAe,MAmChB,CAACJ,EAAmB5B,IAEhB,CACL6B,WACA9B,UACAlC,MAAOoE,EAA2BpE,EAAQ,KAC1CU,aACAkD,aACAK,QAASG,EAA2BH,EAAU,KAC9C9B,MAAOE,KC7BEkC,GArEa,SAAC,GAA2B,IAA1BrU,EAAyB,EAAzBA,QAASsU,EAAgB,EAAhBA,WAkErC,OAjEsB,SAAC,GAShB,IARL9D,EAQI,EARJA,WACAkD,EAOI,EAPJA,WACAK,EAMI,EANJA,QACAvd,EAKI,EALJA,OACAP,EAII,EAJJA,QACA0T,EAGI,EAHJA,YACAC,EAEI,EAFJA,OACA1C,EACI,EADJA,gBAEMtT,EAAaC,iBAAO,IAC1BD,EAAWL,QAAQmgB,WAAaA,EAChC9f,EAAWL,QAAQiD,OAASA,EAC5B5C,EAAWL,QAAQ0C,QAAUA,EAC7BrC,EAAWL,QAAQoW,YAAcA,EACjC/V,EAAWL,QAAQqW,OAASA,EAC5BhW,EAAWL,QAAQ2T,gBAAkBA,EAErC,IAAM3G,EAAa/J,EAAOC,MAAMD,EAAOC,MAAMpD,OAAS,GAAG2H,MAAQgF,EACjEe,qBAAU,WAAO,IAAD,IACd,GAAKgT,EAAL,CAGA,MAOIngB,EAAWL,QANbmgB,EADF,EACEA,WACAld,EAFF,EAEEA,OACAP,EAHF,EAGEA,QACA0T,EAJF,EAIEA,YACAC,EALF,EAKEA,OACA1C,EANF,EAMEA,gBAEIpT,EAASwgB,EAAW,CACxB9d,SACAP,UACAua,aACAkD,aACAK,UACAxT,eAEF,GAAKzM,EAAL,CAGA,IAAKA,EAAOuM,GACV,MAAM,IAAIkU,MAAJ,uCAC4BvU,EAD5B,uEAIR,IAAMY,EAAYsG,EAAgBnH,iBAChC,CACEvJ,SACAwJ,WAHc,2BAMXlM,GANW,IAOdqM,OAAM,UAAErM,EAAOqM,cAAT,QAAmB,MACzBvI,SAAQ,UAAE9D,EAAO8D,gBAAT,YAGZ+R,KACI7V,EAAO0gB,WAAyBnW,IAAhBvK,EAAO0gB,OAAP,OAA6B5T,QAA7B,IAA6BA,OAA7B,EAA6BA,EAAWhJ,YAC1DyJ,YAAW,kBAAMuI,GAAO,UAEzB,CAACmK,EAASvD,EAAYjQ,MCwGdkU,GApKc,SAAC,GAiBvB,IAhBL5B,EAgBI,EAhBJA,WACA7S,EAeI,EAfJA,QACA0U,EAcI,EAdJA,kBACA3D,EAaI,EAbJA,OACA4C,EAYI,EAZJA,cACAF,EAWI,EAXJA,cACA9B,EAUI,EAVJA,YACAjC,EASI,EATJA,SACAiF,EAQI,EARJA,2BACAC,EAOI,EAPJA,kBACAC,EAMI,EANJA,iBACA7B,EAKI,EALJA,gBACAC,EAII,EAJJA,eACAW,EAGI,EAHJA,iBACAU,EAEI,EAFJA,WACAxC,EACI,EADJA,aAEMnC,EAAQD,EAAS,CAACzV,KAAM,SAAU4Y,aAAY7S,YAE9C8U,EAAsBtB,GAA0B,CACpDxT,UACA+Q,SACApB,QACA8D,gBACA9B,cACAgC,gBACAC,mBACA9B,iBAGIiD,EAAgBV,GAAoB,CACxCrU,UACAsU,eAGF,OAAO,YASA,IARL9d,EAQI,EARJA,OACAP,EAOI,EAPJA,QACA0T,EAMI,EANJA,YACAC,EAKI,EALJA,OACA1C,EAII,EAJJA,gBACAiB,EAGI,EAHJA,mBACAO,EAEI,EAFJA,WACAD,EACI,EADJA,aAEA,EACEqM,EAAoB,CAClBte,SACAP,YAHG6d,EAAP,EAAOA,SAAU9B,EAAjB,EAAiBA,QAASlC,EAA1B,EAA0BA,MAAOU,EAAjC,EAAiCA,WAAYkD,EAA7C,EAA6CA,WAAYK,EAAzD,EAAyDA,QAAS9B,EAAlE,EAAkEA,MAuBlE,OAjBAlR,qBAAU,WACJ+S,IAAac,GACfhL,MAED,CAACkK,EAAUlK,IAEdmL,EAAc,CACZvE,aACAkD,aACAK,UACAvd,SACAP,UACA0T,cACAC,SACA1C,oBAGE4M,GAAYc,EAEZ,cAACA,EAAD,CACEF,kBAAmBA,EACnB1U,QAASA,EACTwQ,WAAYA,EACZkD,WAAYA,EACZld,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAInB4I,EAEA,cAACmD,EAAD,CACEnD,MAAOA,EACPmC,MAAOA,EACPyC,kBAAmBA,EACnB1U,QAASA,EACTwQ,WAAYA,EACZkD,WAAYA,EACZld,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAInB8K,IAAY+B,EAEZ,cAACf,EAAD,CACE0B,kBAAmBA,EACnB1U,QAASA,EACTwQ,WAAYA,EACZkD,WAAYA,EACZld,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IAIlB6M,EAAQ1gB,OAoBX,cAACwhB,EAAD,CACEd,QAASA,EACTW,kBAAmBA,EACnB1U,QAASA,EACTwQ,WAAYA,EACZkD,WAAYA,EACZld,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,IA/BjB,cAACyN,EAAD,CACEZ,QAASA,EACTW,kBAAmBA,EACnB1U,QAASA,EACTwQ,WAAYA,EACZkD,WAAYA,EACZld,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACRzB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,EACdvB,gBAAiBA,MC1IZ8N,GAPkB,SAACC,EAAKC,GACrC,OAAID,EAAM,EACDC,EAAM,IAAOD,EAAM,GAAKC,EAE1BD,EAAMC,G,2BC+KAC,GAhL2B,SAAC,GAOpC,IANLnV,EAMI,EANJA,QACAoV,EAKI,EALJA,cAKI,IAJJC,0BAII,MAJiB,gBAAEC,EAAF,EAAEA,oBAAwBtW,EAA1B,yBACnB,cAACsW,EAAD,eAAyBtW,KAGvB,EADJuW,EACI,EADJA,SAEMD,EAAsB,SAAC,GAUtB,IATLvB,EASI,EATJA,QACAvd,EAQI,EARJA,OACAP,EAOI,EAPJA,QACAiR,EAMI,EANJA,gBACA0C,EAKI,EALJA,OACAD,EAII,EAJJA,YACAxB,EAGI,EAHJA,mBACAO,EAEI,EAFJA,WACAD,EACI,EADJA,aAEA,EAAwCrJ,mBAAS,MAAjD,mBAAOoW,EAAP,KAAqBC,EAArB,KACAvhB,8BACEiU,GACA,iBAAO,CACLJ,MAAO,YAAiC,IAA/BnS,EAA8B,EAA9BA,MAAOF,EAAuB,EAAvBA,IAAKuS,EAAkB,EAAlBA,MAAOyN,EAAW,EAAXA,MAExBD,EADE7f,EACc,EACPF,GACQ,EACC,MAATuS,EACO,SAAAuN,GAAY,OACV,MAAhBA,EACIvN,EAAQ,EACNA,EAAQ,EACRA,EACFuN,EAAevN,GAGLyN,OAItB,IAGF,IAAMC,EAAS,SAAAvV,GAAS,IAAD,IACftM,EAASyhB,EAAS,CACtBvV,UACA4V,aAAcxV,EACd5J,SACAP,YAEF,IAAKnC,EAAOuM,GACV,MAAM,IAAIkU,MAAJ,qCAC0BvU,EAD1B,uEAIR,IAAMY,EAAYsG,EAAgBnH,iBAChC,CACEvJ,SACAwJ,WAHc,yBAMdI,QACGtM,GAPW,IAQdqM,OAAM,UAAErM,EAAOqM,cAAT,QAAmB,MACzBvI,SAAQ,UAAE9D,EAAO8D,gBAAT,YAGZ+R,KACI7V,EAAO0gB,WAAyBnW,IAAhBvK,EAAO0gB,OAAP,OAA6B5T,QAA7B,IAA6BA,OAA7B,EAA6BA,EAAWhJ,YAC1DyJ,YAAW,kBAAMuI,GAAO,OAItBiM,EACY,MAAhBL,EACI,KACAR,GAAyBQ,EAAczB,EAAQ1gB,QAC/CyiB,EAAajiB,mBAEnBkN,qBAAU,WACR,GAAe,MAAX8U,GAAmBC,EAAWviB,QAAS,CACzCuiB,EAAWviB,QAAQwU,QACnB,IAAMwL,EAAIlS,YAAW,WAEjBU,SAASmK,gBAAkB4J,EAAWviB,SACc,OAApDwO,SAASmK,cAAc6J,aAAa,cAEpChU,SAASmK,cAAc8J,gBAAgB,YACvCF,EAAWviB,QAAQwU,YAGvB,OAAO,kBAAM3G,aAAamS,OAG3B,CAACsC,IA0CJ,OACE,oBACEhN,KAAK,OACLxI,GAAIqI,EACJ,kBAAiBD,EACjBU,UAAU,sBACV8M,UA9Cc,SAAAld,GAChB,GAAc,cAAVA,EAAEiC,IAAqB,CACzB,IAAMkb,EAAOL,EAAU,EACnBK,EAAOnC,EAAQ1gB,OACjBoiB,EAAgBS,IAEhBT,EAAgB,MAChB9L,KAEF5Q,EAAEwI,iBACFxI,EAAEqV,uBACG,GAAc,YAAVrV,EAAEiC,IAAmB,CAC9B,IAAMkb,EAAOL,EAAU,EACnBK,GAAQ,EACVT,EAAgBS,IAEhBT,EAAgB,MAChB9L,KAEF5Q,EAAEwI,iBACFxI,EAAEqV,sBACiB,cAAVrV,EAAEiC,KACXya,EAAgB,MAChB7L,EAAO,CAAChU,OAAO,IACfmD,EAAEwI,iBACFxI,EAAEqV,mBACiB,eAAVrV,EAAEiC,KACXya,EAAgB,MAChB9L,IACA5Q,EAAEwI,iBACFxI,EAAEqV,mBACiB,UAAVrV,EAAEiC,KACP+Y,EAAQ8B,KACVF,EAAO5B,EAAQ8B,IACf9c,EAAEwI,iBACFxI,EAAEqV,oBAMN,SAMG2F,EAAQjY,KAAI,SAACuU,EAAMjd,GAAP,OAEX,aADA,CACA,MAAYyV,KAAK,OAAjB,SACE,mBACEvV,IAAK,SAAAa,GACC0hB,IAAYziB,IACd0iB,EAAWviB,QAAUY,IAGzB0U,KAAK,WACLsN,SAAS,KACThN,UAAS,kCACP0M,IAAYziB,EAAI,qCAAuC,IAEzD8V,QAAS,kBAAMyM,EAAOtF,IAXxB,SAYE,cAAC+E,EAAD,CACEpV,QAASA,EACTqQ,KAAMA,EACN7Z,OAAQA,EACRP,QAASA,OAjBN7C,SAyBjB,OAAO,SAAA4L,GAAK,OACV,cAACqW,EAAD,aAAoBC,oBAAqBA,GAAyBtW,MCNvDoX,GAnKiB,SAAC,GAG1B,IAAD,IAFJC,WAAaxD,EAET,EAFSA,WAAYlX,EAErB,EAFqBA,WAAYlF,EAEjC,EAFiCA,MACrCqb,EACI,EADJA,aAEM4C,EAAoBzE,GACxBxZ,GACA,YAAqB,IAAnBuE,EAAkB,EAAlBA,IAAKsb,EAAa,EAAbA,QACL,IAAKA,EACH,OAAO,KAET,IACExD,EASEwD,EATFxD,UACAC,EAQEuD,EARFvD,kBACAhC,EAOEuF,EAPFvF,OACAY,EAME2E,EANF3E,YACAE,EAKEyE,EALFzE,iBACAH,EAIE4E,EAJF5E,YACAsB,EAGEsD,EAHFtD,gBACAC,EAEEqD,EAFFrD,eACAvD,EACE4G,EADF5G,SAEF,OAAOkD,GAAsB,CAC3BC,aACAlX,aACAqE,QAAShF,EACT8X,YACAC,oBACAhC,SACAY,cACAE,mBACAH,cACAsB,kBACAC,iBACAvD,WACAoC,mBAGJ,OAGIyE,EAAmBtG,GACvBxZ,GACA,YAkBO,IAjBLuE,EAiBI,EAjBJA,IAiBI,IAhBJwb,OACE3B,EAeE,EAfFA,iBACA4B,EAcE,EAdFA,oBACAC,EAaE,EAbFA,aAaE,IAZF/B,kCAYE,MAZ2B,iBAAM,6BAYjC,EAXFC,EAWE,EAXFA,kBACA7D,EAUE,EAVFA,OACA4C,EASE,EATFA,cACAF,EAQE,EARFA,cACYkD,EAOV,EAPFrC,WAOE,IANF3C,mBAME,MANY,SAAA+B,GAAU,OAAI5J,KAAKC,UAAU2J,IAMzC,EALFV,EAKE,EALFA,gBACAC,EAIE,EAJFA,eACAW,EAGE,EAHFA,iBACAlE,EAEE,EAFFA,SAGF,GAAIiH,IAAmBD,EACrB,MAAM,IAAInC,MAAM,+CAElB,IAAMD,EAAaqC,EACf,SAAA3L,GACE,IAAOhL,EAA4BgL,EAA5BhL,QAASxJ,EAAmBwU,EAAnBxU,OAAQP,EAAW+U,EAAX/U,QAClB2f,EAAee,EAAe3L,GACpC,GAAK4K,EAAL,CAGA,IAAM9hB,EAAS4iB,EAAa,CAC1B1W,UACA4V,eACApf,SACAP,YAEF,OAAInC,EACK,aACLsM,KAAMwV,GACH9hB,GAGAA,IAET,aACJ,OAAO2gB,GAAqB,CAC1B5B,aACAlX,aACAqE,QAAShF,EACT0Z,oBACA3D,SACA4C,gBACAF,gBACA9B,cACAiD,oBACAD,6BACAE,iBAAkB4B,EACdtB,GAAkC,CAChCnV,QAAShF,EACToa,cAAeqB,EACfpB,mBAAoBR,EACpBU,SAAUmB,IAEZ7B,EACJ7B,kBACAC,iBACAW,mBACAlE,WACA4E,aACAxC,mBAGJ,OAGF,OAAO,YASA,IARLtb,EAQI,EARJA,OACAP,EAOI,EAPJA,QACA0T,EAMI,EANJA,YACAC,EAKI,EALJA,OACA1C,EAII,EAJJA,gBACAiB,EAGI,EAHJA,mBACAO,EAEI,EAFJA,WACAD,EACI,EADJA,aAEA,GAAIjS,EAAOoB,SAAU,CACnB,IAAMgf,EAAiBpgB,EAAO0D,YAAY1D,EAAO0D,YAAY7G,OAAS,GAChEwjB,EAAmBnC,EAAkBkC,EAAe5b,KAC1D,OACE,cAAC6b,EAAD,CACErgB,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACR1C,gBAAiBA,EACjBiB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,IAKpB,IAAMqO,EAA2BtgB,EAAOkB,sBAAwB,EAC1Dqf,EACJvgB,EAAO0D,YAAY4c,GACfE,EAAkBT,EAAiBQ,EAA0B/b,KAEnE,OACE,cAACgc,EAAD,CACExgB,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACR1C,gBAAiBA,EACjBiB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,MChHPwO,GAhDW,SAAC,GAAuC,IAAtCC,EAAqC,EAArCA,kBAAmBpF,EAAkB,EAAlBA,aACvCqF,EAAmB,GAEzB,IAAK,IAAMld,KAAQid,EACjBC,EAAiBld,GAAQmc,GAAwB,CAC/CC,WAAYa,EAAkBjd,GAC9B6X,iBAGJ,OAAO,YASA,IARLtb,EAQI,EARJA,OACAP,EAOI,EAPJA,QACA0T,EAMI,EANJA,YACAC,EAKI,EALJA,OACA1C,EAII,EAJJA,gBACAiB,EAGI,EAHJA,mBACAO,EAEI,EAFJA,WACAD,EACI,EADJA,aAEM7U,EAAaC,iBAAO,IAE1BD,EAAWL,QAAQqW,OAASA,EAE5B,IAAMkJ,EAAYqE,EAAiB3gB,EAAOyD,MAO1C,OANA8G,qBAAU,WACH+R,GACHlf,EAAWL,QAAQqW,WAEpB,CAACkJ,IAEAA,EAEA,cAACA,EAAD,CACEtc,OAAQA,EACRP,QAASA,EACT0T,YAAaA,EACbC,OAAQA,EACR1C,gBAAiBA,EACjBiB,mBAAoBA,EACpBO,WAAYA,EACZD,aAAcA,IAIb,O,sIC7CI2O,GCkBW,SAAC,GAiBpB,IAhBIC,EAgBL,EAhBJzc,QAgBI,IAfJb,eAeI,MAfM,EAeN,EAdJiZ,EAcI,EAdJA,gBACAC,EAaI,EAbJA,eAaI,IAZJqE,uBAYI,aAXJ1D,wBAWI,MAXe,IAWf,MAVJvC,aAUI,MAVI,2BAAStZ,KAAKuC,MAAsB,OAAhBvC,KAAKwC,UAAzB,YAA+CC,KAAKC,QAUxD,EATJsQ,EASI,EATJA,iBACA2E,EAQI,EARJA,SACAjL,EAOI,EAPJA,gBACAb,EAMI,EANJA,WACAuC,EAKI,EALJA,MACA3N,EAII,EAJJA,SACA4O,EAGI,EAHJA,WAGI,IAFJ0K,oBAEI,MAFW,SAAAhC,GAAK,OAClBA,EAAMyH,SAAWzH,EAAM0H,QAAQ9G,cAAcC,SAAS,UACpD,EACJjB,EAAWA,EAAWD,GAAgBC,GAAYM,GAElD,IAAMkH,EAAoBjH,GACxBoH,GACA,SAAArd,GACE,IAAMyd,EAAiBzd,EAAO0V,SAC1BD,GAAgBzV,EAAO0V,UACvBA,EACEgI,EACJ1d,EAAOgZ,iBAAmBA,GAAoB,iBAAM,cAChD2E,EACJ3d,EAAOiZ,gBACPA,GACC,gBAAEnD,EAAF,EAAEA,MAAF,OAAkB,OAALA,QAAK,IAALA,OAAA,EAAAA,EAAO0H,UAAW,QAC5BI,EACJ5d,EAAO4Z,kBAAoBA,EAE7B,MAAO,CACLf,WAAY7Y,EAAOC,KACnBxD,MAAOuD,EAAOvD,MAAMqF,KAClB,WAYE1I,GACI,IAGAykB,EAiBAC,EA/BF9c,EAWC,EAXDA,IACA+c,EAUC,EAVDA,aACAC,EASC,EATDA,cACAC,EAQC,EARDA,cACAC,EAOC,EAPDA,eACAlF,EAMC,EANDA,gBACAC,EAKC,EALDA,eACAW,EAIC,EAJDA,iBACAlE,EAGC,EAHDA,SAkBF,GAbAsI,EAAgBA,GAAiBE,IAG/BL,GAJFE,EAAeA,GAAgBE,GAGd7X,MAEb2X,EAAaI,YACZ,SAAC/X,EAAMsT,GAAP,OAAsBnD,GAAYnQ,EAAMsT,EAAWlD,cACpD4H,KAAK,KAAML,EAAa3X,MAGxB2X,EAAahH,QACbgH,EAAavB,QACbuB,EAAaM,gBAGf,MAAM,IAAI9D,MAAJ,UACDva,EAAOC,KADN,cACgBe,EADhB,4GAKR,GAAIgd,EAAe,CACjB,GAAID,EAAa3X,KAAM,CACrB,IAAK4X,EAAcM,iBACjB,MAAM,IAAI/D,MAAJ,UACDva,EAAOC,KADN,cACgBe,EADhB,6JAIR8c,EAAgBE,EAAcM,iBAAiBF,KAC7C,KACAL,EAAa3X,WAGf0X,EACEE,EAAcjH,QACdiH,EAAcO,aACdP,EAAcQ,WAElB,IAAKV,EACH,MAAM,IAAIvD,MAAJ,UACDva,EAAOC,KADN,cACgBe,EADhB,+HAIH,GAAI5H,IAAM4G,EAAOvD,MAAMrD,GAAGC,OAAS,EACxC,MAAM,IAAIkhB,MAAJ,iDACsCvZ,EADtC,uBACwDhB,EAAOC,KAD/D,8DAKR,MAAO,CACLe,MACAwb,OAAO,yBACLxD,gBAAiBA,GAAmB0E,EACpCzE,eAAgBA,GAAkB0E,EAClC/D,iBAAkBA,GAAoBgE,GACnCG,GAJC,IAKJpE,cACEoE,EAAapE,eAAkB,SAAAI,GAAO,OAAIA,GAC5CrE,SACEqI,EAAarI,UAAYA,EACrBD,GAAgBsI,EAAarI,UAAYA,GACzC+H,EACN1G,OAAQD,GAAoB+G,KAE9BvB,QAAS0B,EAAa,yBAEhBhF,gBAAiBA,GAAmB0E,EACpCzE,eAAgBA,GAAkB0E,GAC/BK,GAJa,IAKhBlF,UACEkF,EAAclF,WACdkF,EAAcS,kBACdT,EAAcnB,kBACdmB,EAAcU,gBAChBhJ,SACEsI,EAActI,UAAYA,EACtBD,GAAgBuI,EAActI,UAAYA,GAC1C+H,EACN1G,OAAQD,GAAoBgH,KAE9B,YAMd,QAEIld,EAAUyc,EAAYvb,KAAI,SAAA9B,GAAM,MAAK,CACzC2B,WAAY3B,EAAO2B,WACnB1B,KAAMD,EAAOC,KACbxD,MAAOuD,EAAOvD,MAAMqF,KAClB,cACEic,aADF,EAEEC,cAFF,EAGEC,cAHF,EAIEC,eAJF,EAKElF,gBALF,EAMEC,eANF,EAOEW,iBAPF,EAQElE,SARF,gCAcJ,OAAO0B,GAAOC,EAAPD,CACLE,GAAU,CACRC,kBAAmB3N,EACnB4N,aAAcrL,GAFhBmL,CAIEpE,GAAS,CACPC,aAAcmK,EACd9Q,aAAcyQ,GAAkB,CAC9BC,oBACApF,kBAJJ5E,CAOEoB,GACEJ,GACEtD,GAAqB,CACnBG,mBACA3D,aACAyD,uBAAwBpG,GAH1BmG,CAKEc,GACEpN,EAAiB,CACfX,oBAAqB,CACnB5D,UACAa,YAHJ0D,CAME/F,EACEyT,GACEkD,GACEK,GAAiB/W,e,mCCnMnCmgB,GAAgB,SAAC,GAAD,IAAQC,EAAR,EAAExY,KAAF,OACpB,qBAAK+I,UAAU,2BAAf,SACE,qBAAK0P,IAAKD,EAAOE,SAAUC,IAAI,cAG7BC,GAAyB,SAAC,GAAD,IAAQJ,EAAR,EAAEvI,KAAF,OAC7B,sBAAKlH,UAAU,cAAf,UACE,qBAAK0P,IAAKD,EAAOE,SAAUC,IAAI,WADjC,OAGGH,EAAOK,SAICC,GAAS,CACpB,CACE7Y,GAAI,KACJ4Y,KAAM,gBACNH,SAAU,qBAEZ,CACEzY,GAAI,OACJ4Y,KAAM,aACNH,SAAU,qBAEZ,CACEzY,GAAI,OACJ4Y,KAAM,WACNH,SAAU,qBAEZ,CACEzY,GAAI,OACJ4Y,KAAM,WACNH,SAAU,qBAEZ,CACEzY,GAAI,OACJ4Y,KAAM,aACNH,SAAU,qBAEZ,CACEzY,GAAI,OACJ4Y,KAAM,aACNH,SAAU,qBAEZ,CACEzY,GAAI,QACJ4Y,KAAM,iBACNH,SAAU,sBAGRK,GAAe,SAACF,EAAMzG,GAAP,OACnB,IAAIvB,SAAQ,SAACC,EAASkI,GACpB,IAAM7F,EAAIlS,YAAW,WACnB6P,EACEgI,GAAOja,QAAO,SAAA2Z,GAAM,uBAClBA,EAAOK,YADW,aAClB,EACII,OACDC,oBACA3I,SAHH,OAGYsI,QAHZ,IAGYA,OAHZ,EAGYA,EAAMI,OAAO3I,qBAG5B,IAAO,IAAO3Y,KAAKwC,UACtBiY,EAAOrG,iBAAiB,SAAS,WAC/B,IAAM2D,EAAQ,IAAIyE,MAAM,WACxBnT,aAAamS,GACb6F,EAAOtJ,UAIPyJ,GAAgB,SAAClZ,EAAImS,GAAL,OACpB,IAAIvB,SAAQ,SAACC,EAASkI,GACpB,IAAM7F,EAAIlS,YAAW,WACnB6P,EAAQgI,GAAOxL,MAAK,SAAAkL,GAAM,OAAIA,EAAOvY,KAAOA,QAC3C,IAAM,IAAOtI,KAAKwC,UACrBiY,EAAOrG,iBAAiB,SAAS,WAC/B,IAAM2D,EAAQ,IAAIyE,MAAM,WACxBnT,aAAamS,GACb6F,EAAOtJ,UAIP0J,GAAe,SAAC,GAAD,IAAQC,EAAR,EAAErZ,KAAF,OACnB,gCACE,6BAAKqZ,EAAMR,OACX,4BAAIQ,EAAMnD,cAGRoD,GAAwB,SAAC,GAAD,IAAQD,EAAR,EAAEpJ,KAAF,OAC5B,qBAAKlH,UAAU,aAAf,SAA6BsQ,EAAMR,QAGxBU,GAAS,CACpB,CACEtZ,GAAI,QACJ4Y,KAAM,QACN3C,QAAS,eAEX,CACEjW,GAAI,OACJ4Y,KAAM,OACN3C,QAAS,gBAEX,CACEjW,GAAI,QACJ4Y,KAAM,QACN3C,QAAS,iBAEX,CACEjW,GAAI,QACJ4Y,KAAM,QACN3C,QAAS,eAEX,CACEjW,GAAI,QACJ4Y,KAAM,QACN3C,QAAS,kBAEX,CACEjW,GAAI,SACJ4Y,KAAM,SACNH,SAAU,mBACVxC,QAAS,uBAEX,CACEjW,GAAI,MACJ4Y,KAAM,MACN3C,QAAS,sBAGPsD,GAAc,SAACX,EAAMzG,GAAP,OAClB,IAAIvB,SAAQ,SAACC,EAASkI,GACpB,IAAM7F,EAAIlS,YAAW,WACnB6P,EACEyI,GAAO1a,QAAO,SAAAwa,GAAK,uBACjBA,EAAMR,YADW,aACjB,EACII,OACDC,oBACA3I,SAHH,OAGYsI,QAHZ,IAGYA,OAHZ,EAGYA,EAAMI,OAAO3I,qBAG5B,IAAO,IAAO3Y,KAAKwC,UACtBiY,EAAOrG,iBAAiB,SAAS,WAC/B,IAAM2D,EAAQ,IAAIyE,MAAM,WACxBnT,aAAamS,GACb6F,EAAOtJ,UAIP+J,GAAe,SAACxZ,EAAImS,GAAL,OACnB,IAAIvB,SAAQ,SAACC,EAASkI,GACpB,IAAM7F,EAAIlS,YAAW,WACnB6P,EAAQyI,GAAOjM,MAAK,SAAA+L,GAAK,OAAIA,EAAMpZ,KAAOA,QACzC,IAAM,IAAOtI,KAAKwC,UACrBiY,EAAOrG,iBAAiB,SAAS,WAC/B,IAAM2D,EAAQ,IAAIyE,MAAM,WACxBnT,aAAamS,GACb6F,EAAOtJ,UAIPgK,GAA0B,SAAC,GAA+B,IAA9BtjB,EAA6B,EAA7BA,OAAQ0Q,EAAqB,EAArBA,gBACxC,EAAkC9H,mBAAS,GAA3C,mBAAO2a,EAAP,KAAkBC,EAAlB,KACMpmB,EAAaC,iBAAO,IAC1BD,EAAWL,QAAQ2T,gBAAkBA,EACrCtT,EAAWL,QAAQiD,OAASA,EAC5BuK,qBAAU,WACR,IAAMwS,EAAI0G,aAAY,WACpBD,GAAa,SAAAD,GAAS,OAAIA,EAAY,OACrC,KACH,OAAO,kBAAMG,cAAc3G,MAC1B,IACH,IAAM4G,EAAqB,IAAdJ,EAQb,OAPAhZ,qBAAU,WACJoZ,GACFvmB,EAAWL,QAAQ2T,gBAAgBzH,aACjC7L,EAAWL,QAAQiD,UAGtB,CAAC2jB,IACG,kEAAqCJ,MAGxCK,GAAa,SAAAC,GAAG,OACpBA,EAAIC,OAAO,EAAG,GAAGC,cAAgBF,EAAIC,OAAO,GAAG5J,eAgNlC8J,GA9MOpD,GAAkB,CACtCrd,QAAS,EACTgR,iBAAkB,CAChBN,KAAM,WAAWgQ,GAAsB,IAA/BjkB,EAA8B,EAA9BA,OACN,GAAoB,aAAhBA,EAAOyD,MAAuBzD,EAAO4D,SAASH,KAChD,MAAM,GAAN,OAAUwgB,EAAV,0BAA4CjkB,EAAO4D,SAASH,KAA5D,YAKNW,QAAS,CACP,CACEe,WAAY,IACZ1B,KAAM,WACNxD,MAAO,CACL,CACEuE,IAAK,OACLU,QAAS,IACTuc,cAAe,CACbxB,oBAAqB,gBAAEpG,EAAF,EAAEA,KAAF,OAAY,8BAAM+J,GAAW/J,MAClDU,OAAQ,iBAAM,CAAC,SAAU,UACzB2F,aAAc,gBAAEd,EAAF,EAAEA,aAAF,MAAqB,CACjC3X,KAAMmc,GAAWxE,GACjBvV,GAAIuV,IAENtB,WAAY,YAAmB,IAAjB9D,EAAgB,EAAhBA,WACZ,cAAQA,QAAR,IAAQA,OAAR,EAAQA,EAAY6I,OAAO3I,eACzB,IAAK,SACH,MAAO,SACT,IAAK,QACH,MAAO,QACT,QACE,SAGNiB,YAAa,iBAAM,KAErBuG,eAAgB,CACdpF,UAAW,gBAAE1S,EAAF,EAAEA,KAAF,OAAY,6BAAKga,GAAWha,MACvC2Q,OAAQ,qBAAE1Q,MAGd,CACErF,IAAK,OACLU,QAAS,IACTuc,cAAe,CACbxB,oBAAqB,SAAAzX,GACnB,OAAQA,EAAMxI,OAAO4D,SAASH,MAC5B,IAAK,SACH,OAAO,cAAC,GAAD,eAA4B+E,IACrC,IAAK,QACH,OAAO,cAAC,GAAD,eAA2BA,IACpC,QACE,MAAO,wBAGb+R,OAAQ,WAAiCyB,GAAY,IAA3ChC,EAA0C,EAA1CA,WACR,OADkD,EAA9BpW,SAAWH,MAE7B,IAAK,SACH,OAAOkf,GAAa3I,EAAYgC,GAClC,IAAK,QACH,OAAOoH,GAAYpJ,EAAYgC,GACjC,QACE,MAAM,IAAI+B,MAAM,yBAGtBmC,aAAc,YAKP,IAJLd,EAII,EAJJA,aAKA,OADI,EAHJpf,OACE4D,SAAWH,MAIX,IAAK,SAKL,IAAK,QACH,MAAO,CACLgE,KAAM2X,EAAaqD,KACnB5Y,GAAIuV,EAAavV,IAErB,QACE,OAAO,IAGbsR,YAAa,gBAAEnB,EAAF,EAAEA,WAAuBvW,EAAzB,EAAcG,SAAWH,KAAzB,gBACRA,EADQ,aACU,OAAVuW,QAAU,IAAVA,OAAA,EAAAA,EAAY6I,OAAO3I,gBAAiB,MAEnDwH,eAAgB,CACdpF,UAAW,SAAA9T,GACT,OAAQA,EAAMxI,OAAO4D,SAASH,MAC5B,IAAK,SACH,OAAO,cAAC,GAAD,eAAmB+E,IAC5B,IAAK,QACH,OAAO,cAAC,GAAD,eAAkBA,IAC3B,QACE,MAAO,wBAGb+T,kBAAmB,SAAA/T,GACjB,IAAM4K,EAAS5K,EAAM4K,OACf3P,EAAO+E,EAAMxI,OAAO4D,SAASH,KAMnC,OALA8G,qBAAU,WACK,UAAT9G,GACF2P,MAED,CAAC3P,EAAM2P,IACF3P,GACN,IAAK,SACH,OAAO,cAAC,GAAD,eAA6B+E,IACtC,IAAK,QACH,OAAO,KACT,QACE,MAAO,wBAGb+R,OAAQ,WAAmByB,GAAY,IAA7BvY,EAA4B,EAA5BA,KAAYoG,EAAgB,EAAtBgQ,KACd,OAAQpW,GACN,IAAK,SACH,OAAOsf,GAAclZ,EAAImS,GAC3B,IAAK,QACH,OAAOqH,GAAaxZ,EAAImS,GAC1B,QACE,MAAM,IAAI+B,MAAM,yBAGtB5C,YAAa,gBAAE1X,EAAF,EAAEA,KAAYoG,EAAd,EAAQgQ,KAAR,gBAAyBpW,EAAzB,YAAiCoG,QAKtD,CACE1E,WAAY,IACZ1B,KAAM,SACNxD,MAAO,CACL,CACEuE,IAAK,SACLU,QAAS,IACTuc,cAAe,CACbxB,oBAAqBuC,GACrB0B,sBAAuB,iBAAM,4BAC7BhE,aAAc,gBAAgBkC,EAAhB,EAAEhD,aAAF,MAA6B,CACzC3X,KAAM2a,EAAOK,KACb5Y,GAAIuY,EAAOvY,KAEb0Q,OAAQ,WAAqByB,GAArB,IAAcyG,EAAd,EAAEzI,WAAF,OAAgC2I,GAAaF,EAAMzG,IAC3Db,YAAa,gBAAcsH,EAAd,EAAEzI,WAAF,OACP,OAAJyI,QAAI,IAAJA,OAAA,EAAAA,EAAMI,OAAO3I,gBAAiB,MAChCkD,iBAAkB,KAEpBsE,eAAgB,CACdpF,UAAW6F,GACX5F,kBAAmB+G,GACnB/I,OAAQ,WAAeyB,GAAf,IAAUnS,EAAV,EAAEuY,OAAF,OAA0BW,GAAclZ,EAAImS,IACpDb,YAAa,qBAAEiH,YAKvB,CACEjd,WAAY,IACZ1B,KAAM,QACNxD,MAAO,CACL,CACEuE,IAAK,QACLU,QAAS,IACTuc,cAAe,CACbpD,iBAAkB,gBAAES,EAAF,EAAEA,oBAAwBtW,EAA1B,yBAChB,8BACE,6DACA,cAACsW,EAAD,eAAyBtW,QAG7B4V,kBAAmB,kBACjB,uEAEE,uBAFF,kEAMF6B,oBAAqBiD,GACrBhD,aAAc,gBAAgB+C,EAAhB,EAAE7D,aAAF,MAA4B,CACxC3X,KAAMwb,EAAMR,KACZ5Y,GAAIoZ,EAAMpZ,KAEZ0Q,OAAQ,WAAqByB,GAArB,IAAcyG,EAAd,EAAEzI,WAAF,OAAgCoJ,GAAYX,EAAMzG,IAC1Db,YAAa,gBAAcsH,EAAd,EAAEzI,WAAF,OACP,OAAJyI,QAAI,IAAJA,OAAA,EAAAA,EAAMI,OAAO3I,gBAAiB,MAChCkD,iBAAkB,KAEpBsE,eAAgB,CACdpF,UAAW0G,GACXzI,OAAQ,WAAcyB,GAAd,IAASnS,EAAT,EAAEoZ,MAAF,OAAyBI,GAAaxZ,EAAImS,IAClDb,YAAa,qBAAE8H,YAMzBxG,eAzYqB,SAAC,GAAD,SAAEnD,MAAiB0H,SA0YxCxE,gBAzYsB,kBACtB,6BACE,8CAwYFsE,iBAAiB,I,mBC3YbqD,GAAezB,GAAOpd,KAAI,SAAA8c,GAAM,OAAIA,EAAOK,QAAMpY,KAAK,MACtD+Z,GAAkBjB,GAAO7d,KAAI,SAAA2d,GAAK,OAAIA,EAAMR,QAAMpY,KAAK,MAkG9Cga,GAjGH,WACV,MAA8Bzb,mBAAS,IAAvC,mBAAOnJ,EAAP,KAAgBuJ,EAAhB,KACA,EAAwCJ,mBAAS,IAAjD,mBAAO3C,EAAP,KAAqBgP,EAArB,KACM1M,EAAgBlL,mBACtB,OACE,sBAAKsV,UAAW2R,IAAQC,UAAxB,UACE,+BACE,sCACM,kCADN,sHAGE,+BACE,mDAEE,uBACCJ,MAEH,mDAEE,uBACCC,MAEH,iMAKA,gIAIA,kHAMJ,sCACM,kCADN,6EAGE,uBAHF,mDAMA,sCACM,kCADN,6EAGE,uBAHF,qDAOF,cAAC,GAAD,CACEzR,UAAU,kBACVpK,cAAeA,EACfR,UACE,mNAEFC,YAAa,CACX,CACE5I,MAAO,EACPF,IAAK,GACLuE,KAAM,WACNG,SAAU,CAACH,KAAM,SAAUoW,KAAM,OAEnC,CAACza,MAAO,GAAIF,IAAK,GAAIuE,KAAM,SAAUG,SAAU,CAACwe,OAAQ,SACxD,CAAChjB,MAAO,GAAIF,IAAK,GAAIuE,KAAM,SAAUG,SAAU,CAACwe,OAAQ,SACxD,CAAChjB,MAAO,IAAKF,IAAK,IAAKuE,KAAM,SAAUG,SAAU,CAACwe,OAAQ,UAC1D,CAAChjB,MAAO,IAAKF,IAAK,IAAKuE,KAAM,QAASG,SAAU,CAACqf,MAAO,SACxD,CACE7jB,MAAO,IACPF,IAAK,IACLuE,KAAM,WACNG,SAAU,CAACH,KAAM,QAASoW,KAAM,UAElC,CAACza,MAAO,IAAKF,IAAK,IAAKuE,KAAM,QAASG,SAAU,CAACqf,MAAO,WAE1D5a,gBAAiB,SAAA9F,GACfyG,EAAWzG,EAAE9C,UAEf2C,qBAAsB,SAAAG,GACpB0S,EAAgB1S,EAAE9C,QAAQ8C,EAAEzE,uBAGhC,0CACA,8BACG2B,EAAQ6F,KAAI,cAAE5B,YAAF,IAAkB1D,EAAlB,yBACX,qBAEE2S,UACE3S,EAAOa,QAAP,OAAgBoF,QAAhB,IAAgBA,OAAhB,EAAgBA,EAAcpF,MAAOyjB,IAAQre,aAAe,GAHhE,SAKGqN,KAAKC,UAAUvT,EAAQ,KAAM,IAJzBA,EAAOa,eCvFxB2jB,IAASC,OAAO,cAAC,GAAD,IAASlZ,SAASmZ,eAAe,W","file":"static/js/main.7bc76127.chunk.js","sourcesContent":["const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","import React, {forwardRef, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst getInEditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\nconst withInEditMarkerIndex = selection => {\n  const inEditMarkerIndex = getInEditMarkerIndex(selection);\n  selection.inEditMarkerIndex = inEditMarkerIndex;\n  return selection;\n};\n\nexport const getSelections = ({\n  partsOrMarkers,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const selectedRange = {startIndex: -1, endIndex: -1};\n  let startSelectedIndex = -1;\n  let endSelectedIndex = -1;\n  let midSelectedIndex = -1;\n  let startTouchedIndex = -1;\n  let endTouchedIndex = -1;\n  let prevIndex;\n  let nextIndex;\n  let i = 0;\n\n  const getReturn = () => ({\n    selectedRange,\n    startSelectedIndex,\n    endSelectedIndex,\n    midSelectedIndex,\n    startTouchedIndex,\n    endTouchedIndex,\n    prevIndex,\n    nextIndex:\n      (nextIndex ?? -1) >= partsOrMarkers.length ? -1 : nextIndex ?? -1,\n  });\n\n  for (\n    ;\n    i < partsOrMarkers.length && partsOrMarkers[i].end < selectionStart;\n    i++\n  );\n\n  prevIndex = i - 1;\n\n  let part = partsOrMarkers[i];\n  if (!part) {\n    return getReturn();\n  }\n\n  if (part.end === selectionStart) {\n    endTouchedIndex = prevIndex = i;\n    i++;\n    part = partsOrMarkers[i];\n    if (!part) {\n      return getReturn();\n    }\n  }\n\n  if (part.start >= selectionEnd) {\n    nextIndex = i;\n    if (part.start === selectionEnd) {\n      startTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected =\n    selectionStart <= part.start && part.start < selectionEnd;\n  let endTotallySelected =\n    selectionStart < part.end && part.end <= selectionEnd;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedIndex = i;\n    nextIndex = i + 1;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedIndex = i;\n      nextIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedIndex = i;\n    i++;\n    part = partsOrMarkers[i];\n    if (!part) {\n      return getReturn();\n    }\n\n    startTotallySelected =\n      selectionStart <= part.start && part.start < selectionEnd;\n    endTotallySelected = selectionStart < part.end && part.end <= selectionEnd;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextIndex = i + 1;\n        startSelectedIndex = i;\n      } else {\n        nextIndex = i;\n        if (part.start === selectionEnd) {\n          startTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedRange.startIndex = i;\n\n  i++;\n  for (; i < partsOrMarkers.length; i++) {\n    part = partsOrMarkers[i];\n\n    startTotallySelected =\n      selectionStart <= part.start && part.start < selectionEnd;\n    endTotallySelected = selectionStart < part.end && part.end <= selectionEnd;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextIndex = i + 1;\n        startSelectedIndex = i;\n      } else {\n        nextIndex = i;\n        if (part.start === selectionEnd) {\n          startTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedRange.endIndex = i;\n  return getReturn();\n};\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const {\n    selectedRange: selectedMarkersRange,\n    startSelectedIndex: startSelectedMarkerIndex,\n    endSelectedIndex: endSelectedMarkerIndex,\n    midSelectedIndex: midSelectedMarkerIndex,\n    startTouchedIndex: markerWithStartTouchedIndex,\n    endTouchedIndex: markerWithEndTouchedIndex,\n    prevIndex: prevMarkerIndex,\n    nextIndex: nextMarkerIndex,\n  } = getSelections({\n    partsOrMarkers: markers,\n    selectionStart,\n    selectionEnd,\n  });\n  return withInEditMarkerIndex({\n    markers,\n    selectedMarkersRange,\n    startSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    midSelectedMarkerIndex,\n    markerWithStartTouchedIndex,\n    markerWithEndTouchedIndex,\n    prevMarkerIndex,\n    nextMarkerIndex,\n  });\n};\n\nexport const getMarkerPartsSelections = ({\n  marker,\n  selectionStart,\n  selectionEnd,\n}) => {\n  const parts = marker.parts;\n\n  const {\n    selectedRange: selectedPartRange,\n    startSelectedIndex: startSelectedPartIndex,\n    endSelectedIndex: endSelectedPartIndex,\n    midSelectedIndex: midSelectedPartIndex,\n    startTouchedIndex: partWithStartTouchedIndex,\n    endTouchedIndex: partWithEndTouchedIndex,\n    prevIndex: prevPartIndex,\n    nextIndex: nextPartIndex,\n  } = getSelections({\n    partsOrMarkers: parts,\n    selectionStart,\n    selectionEnd,\n  });\n\n  const anchorIndex = parts[0].start - 1;\n  const anchorSelected =\n    selectionStart <= anchorIndex && selectionEnd > anchorIndex;\n\n  return {\n    markerUuid: marker.uuid,\n    parts: marker.parts,\n    selectedPartRange,\n    startSelectedPartIndex,\n    endSelectedPartIndex,\n    midSelectedPartIndex,\n    partWithStartTouchedIndex,\n    partWithEndTouchedIndex,\n    prevPartIndex,\n    nextPartIndex,\n    anchorSelected,\n  };\n};\n\nconst fixPartSelections = ({\n  marker,\n  selectionStart,\n  selectionEnd,\n  isSingleSelection,\n  startCursorMoved,\n  endCursorMoved,\n}) => {\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n  const parts = marker.parts;\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      if (isSingleSelection) {\n        if (startCursorMoved < 0) {\n          return {\n            selectionStart: midSelectedPart.start,\n            selectionEnd: midSelectedPart.start,\n          };\n        }\n        return {\n          selectionStart: midSelectedPart.end,\n          selectionEnd: midSelectedPart.end,\n        };\n      }\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart: midSelectedPart.start,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart:\n          startCursorMoved > 0 ? endSelectedPart.end : endSelectedPart.start,\n        selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n      };\n    }\n  }\n\n  if (startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        selectionStart: Math.min(selectionStart, parts[0].start),\n        selectionEnd:\n          endCursorMoved < 0 ? parts[0].start : lastResolvedPart.end,\n      };\n    }\n  }\n\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    return {\n      selectionStart,\n      selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n    };\n  }\n\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst fixMarkerSelections = ({\n  markers,\n  selectionStart,\n  selectionEnd,\n  isSingleSelection,\n  startCursorMoved,\n  endCursorMoved,\n}) => {\n  const {\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = getMarkerSelections({\n    markers,\n    selectionStart,\n    selectionEnd,\n  });\n\n  if (midSelectedMarkerIndex >= 0) {\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (midSelectedMarker.isLocked) {\n      if (isSingleSelection) {\n        const selection =\n          startCursorMoved < 0\n            ? midSelectedMarker.start\n            : midSelectedMarker.end;\n        return {\n          selectionStart: selection,\n          selectionEnd: selection,\n        };\n      }\n      return {\n        selectionStart: midSelectedMarker.start,\n        selectionEnd: midSelectedMarker.end,\n      };\n    }\n    return fixPartSelections({\n      marker: midSelectedMarker,\n      selectionStart,\n      selectionEnd,\n      isSingleSelection,\n      startCursorMoved,\n      endCursorMoved,\n    });\n  }\n  if (endSelectedMarkerIndex >= 0) {\n    const endSelectedMarker = markers[endSelectedMarkerIndex];\n    if (endSelectedMarker.isLocked) {\n      if (startCursorMoved < 0) {\n        selectionStart = endSelectedMarker.start;\n      } else {\n        selectionStart = endSelectedMarker.end;\n      }\n    } else {\n      const newSelections = fixPartSelections({\n        marker: endSelectedMarker,\n        selectionStart,\n        selectionEnd,\n        isSingleSelection,\n        startCursorMoved,\n        endCursorMoved,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n    }\n  }\n  if (startSelectedMarkerIndex >= 0) {\n    const startSelectedMarker = markers[startSelectedMarkerIndex];\n    if (startSelectedMarker.isLocked) {\n      if (endCursorMoved > 0) {\n        selectionEnd = startSelectedMarker.end;\n      } else {\n        selectionEnd = startSelectedMarker.start;\n      }\n    } else {\n      const newSelections = fixPartSelections({\n        marker: startSelectedMarker,\n        selectionStart,\n        selectionEnd,\n        isSingleSelection,\n        startCursorMoved,\n        endCursorMoved,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n    }\n  }\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst withMarkerSelection = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {\n        onSelectionChange: onSelectionChangeFromParent,\n        value,\n        markers,\n        onInEditMarkerChange,\n        ...restProps\n      },\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.selectionStart === selectionStart\n            ? 0\n            : selectionStart - prevSelection.selectionStart;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.selectionEnd === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.selectionEnd;\n\n        const {\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd,\n        } = fixMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n          isSingleSelection,\n          startCursorMoved,\n          endCursorMoved,\n        });\n\n        if (selectionEnd !== newSelectionEnd) {\n          textarea.selectionEnd = newSelectionEnd;\n        }\n        if (selectionStart !== newSelectionStart) {\n          textarea.selectionStart = newSelectionStart;\n        }\n\n        const newSelection = withInEditMarkerIndex({\n          markers,\n\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd,\n\n          ...getMarkerSelections({\n            markers,\n            selectionStart: newSelectionStart,\n            selectionEnd: newSelectionEnd,\n          }),\n        });\n\n        mutableRef.current.selection = newSelection;\n\n        onInEditMarkerChange &&\n          onInEditMarkerChange({\n            target: textarea,\n            value,\n            markers,\n            inEditMarkerIndex: newSelection.inEditMarkerIndex,\n            oldInEditMarkerIndex: prevSelection?.inEditMarkerIndex,\n          });\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            ...newSelection,\n          });\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          {...restProps}\n          value={value}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelection;\n","import {getMarkerPartsSelections} from 'lib/hocs/withMarkerSelection';\n\nconst blockPartUpdates = ({marker, selectionStart, selectionEnd}) => {\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n    anchorSelected,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n  const parts = marker.parts;\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart: midSelectedPart.start,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart: endSelectedPart.start,\n        selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n      };\n    }\n  }\n\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    return {\n      block: true,\n      selectionStart,\n      selectionEnd: Math.max(selectionEnd, lastResolvedPart.end),\n    };\n  }\n\n  if (!anchorSelected && startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      return {\n        block: true,\n        selectionStart,\n        selectionEnd: lastResolvedPart.end,\n      };\n    }\n  }\n\n  return {block: false};\n};\n\nexport const blockMarkerUpdates = selection => {\n  const {\n    markers,\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = selection;\n\n  let {selectionStart, selectionEnd} = selection;\n\n  const midSelectedMarker = markers[midSelectedMarkerIndex];\n  const endSelectedMarker = markers[endSelectedMarkerIndex];\n  const startSelectedMarker = markers[startSelectedMarkerIndex];\n\n  if (midSelectedMarker) {\n    if (midSelectedMarker.isLocked) {\n      return {\n        block: true,\n        selectionStart: midSelectedMarker.start,\n        selectionEnd: midSelectedMarker.end,\n      };\n    }\n    return blockPartUpdates({\n      marker: midSelectedMarker,\n      selectionStart,\n      selectionEnd,\n    });\n  }\n  let block = false;\n  if (endSelectedMarker) {\n    if (endSelectedMarker.isLocked) {\n      block = true;\n      selectionStart = endSelectedMarker.start;\n      selectionEnd = endSelectedMarker.end;\n    } else {\n      const partBlock = blockPartUpdates({\n        marker: endSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      if (partBlock.block) {\n        block = true;\n        selectionStart = partBlock.selectionStart;\n        selectionEnd = partBlock.selectionEnd;\n      }\n    }\n  }\n  if (startSelectedMarker) {\n    if (startSelectedMarker.isLocked) {\n      block = true;\n      selectionStart = startSelectedMarker.start;\n      selectionEnd = startSelectedMarker.end;\n    } else {\n      const partBlock = blockPartUpdates({\n        marker: startSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      if (partBlock.block) {\n        block = true;\n        selectionStart = partBlock.selectionStart;\n        selectionEnd = partBlock.selectionEnd;\n      }\n    }\n  }\n  if (!block) {\n    return {\n      block: false,\n    };\n  }\n  return {\n    block: true,\n    selectionStart,\n    selectionEnd,\n  };\n};\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {\n  getMarkerPartsSelections,\n  getMarkerSelections,\n} from './withMarkerSelection';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst newLines = {\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n};\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n  ...newLines,\n};\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  partsConfig,\n  parts,\n  partsText,\n  partsIds = {},\n  partsData = {},\n  lastResolvedPartIndex = -1,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  partsConfig,\n  parts,\n  partsText,\n  partsIds,\n  partsData,\n  lastResolvedPartIndex,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if ((i === 0 || spaces[value[i - 1]]) && anchors[value[i]]) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const partsText = {};\n    const parts = [];\n    const partsConfig = anchor.parts;\n\n    for (let j = 0; j < partsConfig.length; j++) {\n      const partStart = i;\n      let partStartChar = '';\n      const {key, startChar, endChars} = partsConfig[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          partStartChar = startChar;\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partTextStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      const partTextEnd = i;\n      partsText[key] = value.substring(partTextStart, partTextEnd);\n      const isPartEnd = endChars[value[i]] === CURRENT_END;\n      const partEndChar = isPartEnd ? value[i] : '';\n      if (isPartEnd) {\n        i++;\n      }\n      const partEnd = i;\n      parts.push({\n        key,\n        start: partStart,\n        end: partEnd,\n        startChar: partStartChar,\n        endChar: partEndChar,\n      });\n      if (i >= value.length && !isPartEnd) {\n        break;\n      }\n      if (endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      partsConfig,\n      parts,\n      partsText,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser = (parseMarkers, options) => (value, markerOffset) =>\n  parseMarkers(value, options).map(marker =>\n    createMarker({\n      isLocked: false,\n      partsIds: {},\n      partsData: {},\n      lastResolvedPartIndex: -1,\n      ...marker,\n      parts: marker.parts.map(part => ({\n        isLocked: false,\n        ...part,\n        start: part.start + markerOffset,\n        end: part.end + markerOffset,\n      })),\n      start: marker.start + markerOffset,\n      end: marker.end + markerOffset,\n    })\n  );\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let inEditMarkerIndex = -1;\n\n  const newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      inEditMarkerIndex = midSelectedMarkerIndex;\n\n      const newSelections = updateMarkerParts({\n        marker: midSelectedMarker,\n        selectionStart,\n        selectionEnd,\n      });\n      selectionStart = newSelections.selectionStart;\n      selectionEnd = newSelections.selectionEnd;\n\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end:\n          midSelectedMarker.end +\n          insertedText.length -\n          (selectionEnd - selectionStart),\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n    }\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      const markerWithEndTouched = markers[markerWithEndTouchedIndex];\n\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex));\n\n      if (!markerWithEndTouched.isLocked) {\n        inEditMarkerIndex = markerWithEndTouchedIndex;\n\n        newMarkers.push({\n          ...markerWithEndTouched,\n          end: markerWithEndTouched.end + insertedText.length,\n        });\n      } else {\n        newMarkers.push(markerWithEndTouched);\n      }\n    } else if (endSelectedMarkerIndex >= 0) {\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n\n      newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n\n      if (!endSelectedMarker.isLocked) {\n        inEditMarkerIndex = endSelectedMarkerIndex;\n\n        const newSelections = updateMarkerParts({\n          marker: endSelectedMarker,\n          selectionStart,\n          selectionEnd,\n        });\n        selectionStart = newSelections.selectionStart;\n        selectionEnd = newSelections.selectionEnd;\n\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart + insertedText.length,\n        });\n      } else {\n        selectionStart = endSelectedMarker.end;\n        newMarkers.push(endSelectedMarker);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    const lengthChange = insertedText.length - (selectionEnd - selectionStart);\n\n    // here is where the selected markers whether fully selected or start selected are effectively deleted\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        parts: marker.parts?.map(part => ({\n          ...part,\n          start: part.start + lengthChange,\n          end: part.end + lengthChange,\n        })),\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker) {\n    const startParse = inEditMarker.start;\n    let endParse = inEditMarker.end;\n\n    const lastPossibleEndParse =\n      newMarkers[nextMarkerIndex]?.start ?? newValue.length;\n    for (\n      ;\n      endParse < lastPossibleEndParse && !spaces[newValue[endParse]];\n      endParse++\n    );\n\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [newlyParsedInEditMarker, ...newParsedMarkers] = markerParser(\n      toParse,\n      startParse\n    );\n\n    let lastResolvedPartIndex = -1;\n    const partsIds = {};\n    const partsData = {};\n    const parts = [];\n    const oldInEditMarkerParts = inEditMarker.parts;\n    const oldInEditMarkerpartsIds = inEditMarker.partsIds;\n    const oldInEditMarkerPartsData = inEditMarker.partsData;\n    const newInEditMarkerParts = newlyParsedInEditMarker.parts;\n    for (let i = 0; i < newInEditMarkerParts.length; i++) {\n      const oldPart = oldInEditMarkerParts[i];\n      const newPart = newInEditMarkerParts[i];\n      const key = newPart.key;\n\n      const shouldLockPart = Boolean(\n        oldPart?.isLocked &&\n          newPart.end !== newPart.start &&\n          prevValue.substring(oldPart.start, oldPart.end) ===\n            newValue.substring(newPart.start, newPart.end)\n      );\n      parts.push({\n        ...newPart,\n        isLocked: shouldLockPart,\n      });\n\n      if (shouldLockPart) {\n        lastResolvedPartIndex = i;\n        partsIds[key] = oldInEditMarkerpartsIds[key];\n        partsData[key] = oldInEditMarkerPartsData[key];\n      }\n    }\n\n    const newInEditMarker = {\n      ...newlyParsedInEditMarker,\n      lastResolvedPartIndex,\n      uuid: inEditMarker.uuid,\n      partsIds,\n      partsData,\n      parts,\n    };\n\n    newMarkers.splice(\n      // remove the old inEditMarker and insert in place of it the new one and the newParsedMarkers\n      inEditMarkerIndex,\n      1,\n      newInEditMarker,\n      ...newParsedMarkers\n    );\n  } else {\n    const startParse = selectionStart;\n    let endParse = selectionStart + insertedText.length;\n\n    const lastPossibleEndParse =\n      newMarkers[nextMarkerIndex]?.start ?? newValue.length;\n    for (\n      ;\n      endParse < lastPossibleEndParse && !spaces[newValue[endParse]];\n      endParse++\n    );\n\n    const toParse = newValue.substring(startParse, endParse);\n\n    const parsedMarkers = markerParser(toParse, startParse);\n\n    newMarkers.splice(\n      // remove the old inEditMarker and insert in place of it the new one and the newParsedMarkers\n      prevMarkerIndex + 1, // still correct even when prevMarkerIndex = -1\n      0,\n      ...parsedMarkers\n    );\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst updateMarkerParts = ({marker, selectionStart, selectionEnd}) => {\n  const lastResolvedPartIndex = marker.lastResolvedPartIndex;\n  const parts = marker.parts;\n\n  const {\n    midSelectedPartIndex,\n    endSelectedPartIndex,\n    startSelectedPartIndex,\n    selectedPartRange,\n  } = getMarkerPartsSelections({\n    marker,\n    selectionStart,\n    selectionEnd,\n  });\n\n  if (midSelectedPartIndex >= 0) {\n    const midSelectedPart = parts[midSelectedPartIndex];\n\n    if (midSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = selectionEnd = lastResolvedPart.end;\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (endSelectedPartIndex >= 0) {\n    const endSelectedPart = parts[endSelectedPartIndex];\n\n    if (endSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = lastResolvedPart.end;\n      selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (startSelectedPartIndex >= 0) {\n    const startSelectedPart = parts[startSelectedPartIndex];\n\n    if (startSelectedPart.isLocked) {\n      const lastResolvedPart = parts[lastResolvedPartIndex];\n      selectionStart = lastResolvedPart.end;\n      selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    }\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n  if (\n    selectedPartRange.endIndex >= 0 &&\n    selectedPartRange.endIndex < lastResolvedPartIndex + 1\n  ) {\n    const lastResolvedPart = parts[lastResolvedPartIndex];\n    selectionStart = lastResolvedPart.end;\n    selectionEnd = Math.max(selectionEnd, lastResolvedPart.end);\n    return {\n      selectionStart,\n      selectionEnd,\n    };\n  }\n\n  return {\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst preProcessMarkerParserOptions = markerParserOptions => {\n  const anchors = {};\n  const types = {};\n  markerParserOptions.anchors.forEach(anchor => {\n    const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n      key,\n      startChar: startChar || '',\n      endChar: endChar || '',\n      endChars: {\n        ...(parts[i + 1]?.startChar\n          ? {\n              [parts[i + 1].startChar]: NEXT_START,\n            }\n          : null),\n        ...(endChar ? {[endChar]: CURRENT_END} : null),\n        ...newLines,\n      },\n    }));\n    const anchorConfig = {\n      ...anchor,\n      parts,\n    };\n    types[anchor.type] = anchorConfig;\n    anchors[anchor.anchorChar] = anchorConfig;\n  });\n  return {...markerParserOptions, anchors, types};\n};\n\nconst getPartDelimitedText = (isLocked, part, partConfig, text) =>\n  (isLocked ? partConfig.startChar : part.startChar) +\n  text +\n  (isLocked ? partConfig.endChar : part.endChar);\nconst getPartTextLengthChange = (isLocked, part, partConfig, text) =>\n  (isLocked ? partConfig.startChar : part.startChar).length +\n  text.length +\n  (isLocked ? partConfig.endChar : part.endChar).length -\n  (part.end - part.start);\n\nconst initMarker = (marker, markerParserOptions) => {\n  const anchorConfig =\n    markerParserOptions.types[marker.type] ||\n    markerParserOptions.anchors[marker.anchor];\n  const partsConfig = anchorConfig.parts;\n  let lastResolvedPartIndex;\n  for (let i = 0; i < partsConfig.length; i++) {\n    if (marker.partsIds[partsConfig[i].key]) {\n      lastResolvedPartIndex = i;\n    }\n  }\n  const isMarkerLocked = lastResolvedPartIndex === partsConfig.length - 1;\n  const parts = isMarkerLocked\n    ? undefined\n    : (marker.parts || []).map((part, i) => ({\n        ...part,\n        isLocked: i <= lastResolvedPartIndex,\n      }));\n  const partsText = isMarkerLocked ? undefined : marker.partsText;\n  return createMarker({\n    ...marker,\n    type: anchorConfig.type,\n    anchor: anchorConfig.anchor,\n    parts,\n    partsText,\n    partsConfig,\n    isLocked: isMarkerLocked,\n    lastResolvedPartIndex,\n  });\n};\n\nconst withMarkerParser = ({markerParserOptions} = {}) => {\n  markerParserOptions = preProcessMarkerParserOptions(markerParserOptions);\n  const markerParser = wrapMarkerParser(parseMarkers, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onMarkersChange,\n          disabled,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers:\n            initMarkers\n              ?.filter(\n                ({anchor, type}) =>\n                  markerParserOptions.types[type] ||\n                  markerParserOptions.anchors[anchor]\n              )\n              .map(marker => initMarker(marker, markerParserOptions)) ?? [],\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n        mutableRef.current.disabled = disabled;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const deleteMarker = (marker, setCursor) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return;\n              }\n              marker = markers[i];\n\n              const {start: selectionStart, end: selectionEnd} = marker;\n              const lengthChange = selectionEnd - selectionStart;\n\n              const newValue =\n                value.substring(0, marker.start) + value.substring(marker.end);\n\n              const newMarkers = [\n                ...markers.slice(0, i),\n                ...markers.slice(i + 1).map(marker => ({\n                  ...marker,\n                  start: marker.start - lengthChange,\n                  end: marker.end - lengthChange,\n                })),\n              ];\n\n              setValue(newValue);\n              setMarkers(newMarkers);\n\n              if (setCursor) {\n                const textarea = innerRef.current;\n                innerRef.current.value = newValue;\n                textarea.selectionStart = textarea.selectionEnd = marker.start;\n              }\n\n              onMarkersChange &&\n                onMarkersChange({\n                  target: innerRef.current,\n                  init: false,\n                  value: newValue,\n                  oldValue: value,\n                  markers: newMarkers,\n                  oldMarkers: markers,\n                });\n\n              onChangeFromParent &&\n                onChangeFromParent({\n                  target: innerRef.current,\n                  value: newValue,\n                  markers: newMarkers,\n                });\n            };\n            const updateMarkerPart = ({marker, partKey}, update) => {\n              const markerUuid = marker.uuid || marker;\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === markerUuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const partIndex = marker.partsConfig.findIndex(\n                ({key}) => key === partKey\n              );\n              if (partIndex < 0) {\n                return false;\n              }\n              const partsConfig = marker.partsConfig;\n              const partConfig = partsConfig[partIndex];\n\n              const updateFunction = update => {\n                if (!update) {\n                  return marker;\n                }\n\n                const {text, cursor, data, id} = update;\n\n                let {partsIds, partsData, parts, partsText} = marker;\n\n                const part = parts?.[partIndex];\n\n                const isLocked = Boolean(id, partsIds[partKey]);\n                const lastResolvedPartIndex = isLocked\n                  ? Math.max(partIndex, marker.lastResolvedPartIndex)\n                  : marker.lastResolvedPartIndex;\n\n                const isLastPossiblePart = partIndex === partsConfig.length - 1;\n\n                const isMarkerLocked =\n                  marker.isLocked || (isLocked && isLastPossiblePart);\n\n                const isLastPart = parts && partIndex === parts.length - 1;\n                const nextPartConfig = isLastPossiblePart\n                  ? null\n                  : partsConfig[partIndex + 1];\n\n                const appendText = isMarkerLocked\n                  ? update.appendText || ''\n                  : '';\n\n                const hasNewText = text != null;\n                const lengthChange = hasNewText\n                  ? isMarkerLocked\n                    ? text.length +\n                      appendText.length -\n                      (marker.end - marker.start)\n                    : getPartTextLengthChange(isLocked, part, partConfig, text)\n                  : 0;\n\n                if (id) {\n                  partsIds = {...partsIds, [partKey]: id};\n                }\n                if (data || data === null) {\n                  partsData = {...partsData, [partKey]: data};\n                }\n                if (isMarkerLocked) {\n                  parts = undefined;\n                } else if (isLocked !== part.isLocked || hasNewText) {\n                  const newParts = parts.slice(0, partIndex);\n                  const newPart = {\n                    ...parts[partIndex],\n                    isLocked,\n                    end: parts[partIndex].end + lengthChange,\n                    ...(isLocked\n                      ? {\n                          startChar: partConfig.startChar,\n                          endChar: partConfig.endChar,\n                        }\n                      : null),\n                  };\n                  newParts.push(newPart);\n                  if (isLastPart) {\n                    if (!isLastPossiblePart) {\n                      newParts.push({\n                        start: newPart.end,\n                        end: newPart.end,\n                        key: nextPartConfig.key,\n                        endChar: '',\n                        startChar: '',\n                      });\n                    }\n                  } else if (lengthChange) {\n                    newParts.push(\n                      ...parts.slice(partIndex + 1).map(part => ({\n                        ...part,\n                        start: part.start + lengthChange,\n                        end: part.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newParts.push(...parts.slice(partIndex + 1));\n                  }\n                  parts = newParts;\n                }\n                if (isMarkerLocked) {\n                  partsText = undefined;\n                } else if (hasNewText) {\n                  partsText = {...partsText, [partKey]: text};\n                  if (isLastPart && !isLastPossiblePart) {\n                    partsText[nextPartConfig.key] = '';\n                  }\n                }\n\n                const newMarkers = [...markers.slice(0, i)];\n                const newMarker = {\n                  ...marker,\n                  end: marker.end + lengthChange,\n                  parts,\n                  partsIds,\n                  partsData,\n                  partsText,\n                  lastResolvedPartIndex,\n                  isLocked: isMarkerLocked,\n                };\n                newMarkers.push(newMarker);\n                if (lengthChange) {\n                  newMarkers.push(\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      parts: marker.parts?.map(part => ({\n                        ...part,\n                        start: part.start + lengthChange,\n                        end: part.end + lengthChange,\n                      })),\n                      start: marker.start + lengthChange,\n                      end: marker.end + lengthChange,\n                    }))\n                  );\n                } else {\n                  newMarkers.push(...markers.slice(i + 1));\n                }\n\n                let newValue = value;\n                if (hasNewText) {\n                  newValue = [\n                    value.substring(\n                      0,\n                      isMarkerLocked ? marker.start : part.start\n                    ),\n                    isMarkerLocked\n                      ? text + appendText\n                      : getPartDelimitedText(isLocked, part, partConfig, text),\n                    value.substring(isMarkerLocked ? marker.end : part.end),\n                  ].join('');\n\n                  setValue(newValue);\n                }\n                setMarkers(newMarkers);\n                if (cursor) {\n                  const textarea = innerRef.current;\n                  innerRef.current.value = newValue;\n                  const marker = newMarkers[i];\n                  const part = marker.parts?.[partIndex];\n                  if (cursor === 'start') {\n                    textarea.selectionStart = textarea.selectionEnd =\n                      isMarkerLocked ? marker.start : part.start;\n                  } else if (cursor === 'end') {\n                    textarea.selectionStart = textarea.selectionEnd =\n                      isMarkerLocked\n                        ? marker.end + appendText.length\n                        : part.end;\n                  }\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update({marker, partConfig, partIndex}));\n              }\n              return updateFunction(update);\n            };\n            return {\n              deleteMarker,\n              updateMarkerPart: ({marker, partKey}, update) =>\n                updateMarkerPart(\n                  {marker, partKey},\n                  ({marker, partConfig, partIndex}) => {\n                    if (typeof update === 'function') {\n                      update = update({\n                        marker,\n                        partKey,\n                        partConfig,\n                        partIndex,\n                      });\n                    }\n                    if (mutableRef.current.disabled && update) {\n                      // if disabled you can only update the data\n                      return {\n                        data: update.data,\n                      };\n                    }\n                    if (update) {\n                      return {\n                        data:\n                          update.data === undefined\n                            ? marker.partsData[partKey]\n                            : update.data,\n                        id: update.id ?? marker.partsIds[partKey],\n                        ...update,\n                      };\n                    }\n                    return update;\n                  }\n                ),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          const selectionEnd = textarea.selectionEnd;\n          const prevSelectionEnd =\n            prevValue.length - (newValue.length - selectionEnd);\n          const minSelectionEnd = Math.min(prevSelectionEnd, selectionEnd);\n\n          let selectionStart;\n          for (\n            selectionStart = 0;\n            selectionStart < minSelectionEnd &&\n            prevValue[selectionStart] === newValue[selectionStart];\n            selectionStart++\n          );\n\n          let selection = getMarkerSelections({\n            markers,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          const blockResult = blockMarkerUpdates({\n            ...selection,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          if (mutableRef.current.blockTimer) {\n            clearTimeout(mutableRef.current.blockTimer);\n            mutableRef.current.blockTimer = null;\n          }\n          if (blockResult.block) {\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            mutableRef.current.blockTimer = setTimeout(() => {\n              mutableRef.current.blockTimer = null;\n              try {\n                textarea.selectionStart = blockResult.selectionStart;\n                textarea.selectionEnd = blockResult.selectionEnd;\n                // eslint-disable-next-line no-empty\n              } catch (err) {}\n            });\n            e.preventDefault();\n            return false;\n          }\n\n          const insertedText = newValue.substring(selectionStart, selectionEnd);\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {\n            newValue: parsedValue,\n            newMarkers: parsedMarkers,\n            selectionEnd: newSelectionEnd,\n          } = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const newCursorPosition =\n            parsedValue !== newValue ? newSelectionEnd : selectionEnd; // might need to be refined!!!\n          textarea.value = parsedValue;\n          textarea.selectionEnd = newCursorPosition;\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs(ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            disabled={disabled}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  markers,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visible: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const mouseEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('mouseOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visible: false,\n        type,\n      });\n    }\n  };\n  const mouseLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('mouseOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = (whereToFocus = {}) => {\n    const {start, end} = whereToFocus;\n    const delta = whereToFocus.delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else if (end) {\n      markersHandlers.focus(marker.end + delta);\n    } else {\n      markersHandlers.focus();\n    }\n  };\n  const focusEnd = () => focus({end: true});\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onMouseEnter={() => mouseEnter(i)}\n        onMouseLeave={mouseLeave}\n        onPointerDown={focusEnd}\n        onPointerUp={focusEnd}\n        onClick={focusEnd}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        style={{zIndex: tipsZIndex}}\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markers={markers}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onMouseEnter: () => mouseEnter(i),\n              onMouseLeave: mouseLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        markers={markers}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({\n          marker,\n          isInEdit: marker.uuid === inEditMarker?.uuid,\n        })}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n        tipsZIndex={tipsZIndex}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultBackgroundColor = 'white',\n  tipsZIndex = 99999999,\n  classNameGetters: baseClassNameGetters,\n} = {}) => {\n  const classNameGetters = {\n    front: baseClassNameGetters?.front\n      ? params =>\n          baseClassNameGetters.front(\n            params,\n            defaultClassNameGetters.front(params)\n          ) ?? defaultClassNameGetters.front(params)\n      : defaultClassNameGetters.front,\n    back: baseClassNameGetters?.back\n      ? params =>\n          baseClassNameGetters.back(\n            params,\n            defaultClassNameGetters.back(params)\n          ) ?? defaultClassNameGetters.back(params)\n      : defaultClassNameGetters.back,\n    tip: baseClassNameGetters?.tip\n      ? params =>\n          baseClassNameGetters.tip(\n            params,\n            defaultClassNameGetters.tip(params)\n          ) ?? defaultClassNameGetters.tip(params)\n      : defaultClassNameGetters.tip,\n  };\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.markers[e.inEditMarkerIndex];\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div\n            id={id}\n            className=\"textarea-container\"\n            style={{backgroundColor, width: restProps.style?.width}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n                tipsZIndex={tipsZIndex}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div\n        className=\"textarea-with-resize-container\"\n        style={{width: restProps.style?.width}}>\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nexport const TOTAL_HIDE = 1;\nexport const SKIP_HIDE = false;\nexport const DEFAULT_HIDE = true;\n\nexport const VISIBLE = true;\nexport const NOT_VISIBLE = false;\nexport const TOGGLE_VISIBLITY = 'toggle';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst wrapHideAction =\n  (baseHideAction = () => DEFAULT_HIDE) =>\n  ({markerUuid, visiblityStack, requestedHideType}) => {\n    const hideOrNewVisiblityStack = baseHideAction({\n      markerUuid,\n      visiblityStack,\n      requestedHideType,\n    });\n    if (Array.isArray(hideOrNewVisiblityStack)) {\n      return hideOrNewVisiblityStack;\n    }\n    if (hideOrNewVisiblityStack === SKIP_HIDE) {\n      return visiblityStack;\n    }\n    if (hideOrNewVisiblityStack === TOTAL_HIDE || !requestedHideType) {\n      return [];\n    }\n    return visiblityStack.filter(({type}) => type !== requestedHideType);\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({});\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visible, labelLineIndex, hideAction}) => {\n            hideAction = wrapHideAction(hideAction);\n            const markerUuid = marker?.uuid || marker;\n            if (!visible && !markerUuid) {\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  const newCurrMarkerDataStack = hideAction({\n                    markerUuid,\n                    visiblityStack: tipsDataStack[markerUuid],\n                    requestedHideType: type,\n                  });\n                  if (newCurrMarkerDataStack.length) {\n                    newTipsDataStack[markerUuid] = newCurrMarkerDataStack;\n\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              visible =\n                visible === TOGGLE_VISIBLITY\n                  ? !tipsDataStack[markerUuid]?.find(data => data.type === type)\n                  : Boolean(visible);\n\n              if (!visible) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (!oldDataStack) {\n                  return visibleTipsSettings;\n                }\n                const newCurrMarkerDataStack = hideAction({\n                  markerUuid,\n                  visiblityStack: oldDataStack,\n                  requestedHideType: type,\n                });\n\n                if (newCurrMarkerDataStack.length) {\n                  const lastTipData =\n                    newCurrMarkerDataStack[newCurrMarkerDataStack.length - 1];\n                  return {\n                    data: {\n                      ...tipsData,\n                      [markerUuid]: {\n                        type: lastTipData.type,\n                        labelLineIndex: lastTipData.labelLineIndex,\n                        focus: tipsData[markerUuid].focus,\n                      },\n                    },\n                    dataStack: {\n                      ...tipsDataStack,\n                      [markerUuid]: newCurrMarkerDataStack,\n                    },\n                  };\n                }\n\n                const newTipsData = {...tipsData};\n                delete newTipsData[markerUuid];\n\n                const newDataStack = {...tipsDataStack};\n                delete newDataStack[markerUuid];\n\n                return {\n                  data: newTipsData,\n                  dataStack: newDataStack,\n                };\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {markers, inEditMarkerIndex} = e;\n              const inEditMarker = markers[inEditMarkerIndex];\n              const oldInEditMarker = mutableRef.current.inEditMarker;\n              mutableRef.current.inEditMarker = inEditMarker;\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visible: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker && inEditMarker !== oldInEditMarker) {\n                // whether a different marker or same marker but updated\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visible: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visible: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n            e.stopPropagation();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visible: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      const onInEditMarkerChange = e => {\n        const inEditMarker = e.markers[e.inEditMarkerIndex];\n        const prevInEditMarker = mutableRef.current.inEditMarker;\n        if (prevInEditMarker && prevInEditMarker.uuid !== inEditMarker?.uuid) {\n          mutableRef.current.updateTipVisibility({\n            visible: false,\n            type: 'keyboard',\n          });\n        }\n        mutableRef.current.inEditMarker = inEditMarker;\n        onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={onInEditMarkerChange}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport {\n  DEFAULT_HIDE,\n  SKIP_HIDE,\n  TOGGLE_VISIBLITY,\n  TOTAL_HIDE,\n} from './withTips';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const clickListener = e => {\n        let elem = e.target;\n        let onTextArea = false;\n        let onTip = false;\n        let onMarker = false;\n        while (elem) {\n          onTextArea = elem.id === id;\n          onTip = elem.dataset?.tipForTextarea === id;\n          onMarker = elem.dataset?.tipAnchorForTextarea === id;\n          if (onTextArea || onTip || onMarker) {\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!onTextArea && !onTip && !onMarker) {\n          mutable.updateTipVisibility({\n            visible: false,\n          });\n          e.preventDefault();\n        } else {\n          const anchorMarkerUuid = onMarker && elem.dataset.tipAnchorForMarker;\n          mutable.updateTipVisibility({\n            visible: false,\n            type: 'clickOnTip',\n            hideAction: ({markerUuid, visiblityStack}) => {\n              if (markerUuid !== anchorMarkerUuid) {\n                return DEFAULT_HIDE;\n              }\n              return SKIP_HIDE;\n            },\n          });\n          if (onMarker) {\n            mutable.updateTipVisibility({\n              marker: anchorMarkerUuid,\n              visible: TOGGLE_VISIBLITY,\n              type: 'clickOnTip',\n              hideAction: () => TOTAL_HIDE,\n            });\n          } else if (onTip) {\n            mutable.updateTipVisibility({\n              marker: elem.dataset.tipForMarker,\n              visible: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', clickListener);\n      return () => document.removeEventListener('click', clickListener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBaseTextArea = (TextArea = 'textarea') =>\n  React.forwardRef(({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <TextArea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBaseTextArea;\n","const fortifyGetCache = getCache => options => {\n  const cache = getCache(options);\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nexport default fortifyGetCache;\n","const defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nexport default defaultGetCache;\n","/**\n * @template I\n * @template O\n * @callback MapFunction\n * @param {I} item\n * @param {number} index\n * @param {I[]} array\n * @returns {O}\n */\n\n/**\n * @template I\n * @callback KeyFunction\n * @param {I} item\n * @returns {string}\n */\n\n/**\n * @template I\n * @template O\n * @param {I[]} array\n * @param {MapFunction<I,O>} mapFunction\n * @param {KeyFunction<I> | string} keyFunction\n * @returns {Object<string, O>}\n */\nconst mapAndKeyBy = (array, mapFunction, keyFunction) => {\n  if (typeof keyFunction !== 'function') {\n    const key = keyFunction;\n    keyFunction = item => item[key];\n  }\n  const keyed = {};\n  for (let i = 0; i < array.length; i++) {\n    const item = array[i];\n    keyed[keyFunction(item)] = mapFunction(item, i, array);\n  }\n  return keyed;\n};\n\nexport default mapAndKeyBy;\n","const doesItemMatchSearch = (item, searchText) => {\n  const searchTextLowerCased = (searchText ?? '').toLowerCase();\n  if (typeof item === 'string') {\n    return item.toLowerCase().includes(searchTextLowerCased);\n  }\n  // eslint-disable-next-line guard-for-in\n  for (const i in item) {\n    const val = item[i];\n    switch (typeof val) {\n      case 'string':\n        if (val.toLowerCase().includes(searchTextLowerCased)) {\n          return true;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return false;\n};\nconst searchArray = (array, searchText) =>\n  array.filter(item => doesItemMatchSearch(item, searchText));\n\nexport default searchArray;\n","const ensureLoaderIsAsync =\n  loader =>\n  (...args) => {\n    const ret = loader(...args);\n    return Promise.resolve().then(() => ret);\n  };\n\nexport default ensureLoaderIsAsync;\n","import React, {forwardRef, useRef} from 'react';\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nexport default withId;\n","import React, {forwardRef} from 'react';\n\nconst withStyle =\n  ({defaultLineHeight = '135%', defaultWidth}) =>\n  (TextArea = 'textarea') =>\n    forwardRef(({width, lineHeight, ...restProps}, ref) => (\n      <TextArea\n        ref={ref}\n        {...restProps}\n        style={{\n          ...restProps.style,\n          width: width ?? restProps.style?.width ?? defaultWidth,\n          lineHeight:\n            lineHeight ?? restProps.style?.lineHeight ?? defaultLineHeight,\n        }}\n      />\n    ));\n\nexport default withStyle;\n","import {useRef, useState, useCallback, useEffect} from 'react';\nimport AbortController from 'abort-controller';\n\nconst buildDetailsDataLoaderHook = ({\n  partKey,\n  loader,\n  cache,\n  getLoadData,\n  getCacheKey = loadData => JSON.stringify(loadData),\n  shouldReloadData = () => false,\n  isAbortError,\n}) => {\n  getLoadData =\n    getLoadData ||\n    (({marker}) => {\n      const partsConfig = marker.partsConfig;\n      const partsIds = marker.partsIds;\n      const loadData = {};\n      for (let i = 0; i < partsConfig.length; i++) {\n        const currPartKey = partsConfig[i].key;\n        loadData[currPartKey] = partsIds[currPartKey];\n        if (currPartKey === partKey) {\n          return loadData;\n        }\n      }\n      return loadData;\n    });\n\n  const useDetailsDataLoader = ({marker, markers, markersHandlers}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error, retry}, setResultData] = useState({});\n\n    const data = marker.partsData[partKey];\n    const doLoad = data === undefined || shouldReloadData(data);\n    const loadData = doLoad ? getLoadData({partKey, marker, markers}) : null;\n    const cacheKey = loadData ? getCacheKey(loadData) : null;\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.markersHandlers = markersHandlers;\n    mutableRef.current.cacheKey = cacheKey;\n    mutableRef.current.marker = marker;\n\n    const retryFunction = useCallback(\n      () =>\n        setResultData(resultData => ({\n          ...resultData,\n          retry: (resultData.retry ?? 0) + 1,\n        })),\n      []\n    );\n\n    useEffect(() => {\n      const {loadData, marker} = mutableRef.current;\n      if (!loadData) {\n        return undefined;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.markersHandlers.updateMarkerPart(\n          {\n            partKey,\n            marker,\n          },\n          {\n            data: cachedData,\n          }\n        );\n        setResultData({});\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResultData({loading: true});\n      loader(loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.markersHandlers.updateMarkerPart(\n              {\n                partKey,\n                marker,\n              },\n              {\n                data: result,\n              }\n            );\n            setResultData({});\n          }\n        })\n        .catch(error => {\n          if (isAbortError(error)) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResultData({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, retry]);\n\n    return {loading, error, loadData, data, retry: retryFunction};\n  };\n  return useDetailsDataLoader;\n};\n\nexport default buildDetailsDataLoaderHook;\n","import React from 'react';\nimport buildDetailsDataLoaderHook from '../hook/buildDetailsDataLoaderHook';\n\nconst buildDetailsComponent = ({\n  markerType,\n  partKey,\n  Component,\n  NotFoundComponent,\n  loader,\n  shouldReloadData,\n  getLoadData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n  isAbortError,\n}) => {\n  const cache = getCache({type: 'details', markerType, partKey});\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  const useDetailDataLoader = buildDetailsDataLoaderHook({\n    partKey,\n    loader,\n    cache,\n    getLoadData,\n    getCacheKey,\n    shouldReloadData,\n    isAbortError,\n  });\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const {loading, error, data, loadData, retry} = useDetailDataLoader({\n      marker,\n      markers,\n      markersHandlers,\n    });\n\n    if (error) {\n      return (\n        <ErrorComponent\n          error={error}\n          retry={retry}\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    if (loading || !data) {\n      return (\n        <LoaderComponent\n          partKey={partKey}\n          loadData={loadData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n\n    return (\n      <Component\n        data={data}\n        partKey={partKey}\n        loadData={loadData}\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        markersHandlers={markersHandlers}\n      />\n    );\n  };\n};\n\nexport default buildDetailsComponent;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import useDebounceValue from 'lib/hooks/useDebounceValue';\nimport {useCallback, useEffect, useRef, useState} from 'react';\nimport AbortController from 'abort-controller';\n\nconst buildSearchDataLoaderHook = ({\n  partKey,\n  loader,\n  cache,\n  getSearchData = ({searchText, marker}) => ({\n    searchText,\n    partsIds: marker.partsIds,\n  }),\n  getCacheKey = searchData => JSON.stringify(searchData),\n  filterResults,\n  debounceDuration,\n  isAbortError,\n}) => {\n  const useSearchDataLoader = ({marker, markers}) => {\n    const mutableRef = useRef({});\n\n    const searchText = marker.partsText[partKey];\n\n    const searchData =\n      getSearchData({\n        searchText,\n        partKey,\n        marker,\n        markers,\n      }) ?? null;\n\n    const cacheKey = searchData != null ? getCacheKey(searchData) : null;\n    const debouncedCacheKey = useDebounceValue(cacheKey, debounceDuration);\n\n    const noSearch = cacheKey === null;\n\n    const [{loading, error, results, resultsCacheKey, retry}, setResultsData] =\n      useState({});\n\n    const isResultForCurrentSearch = resultsCacheKey === cacheKey;\n\n    mutableRef.current.marker = marker;\n    mutableRef.current.markers = markers;\n    mutableRef.current.searchData = searchData;\n\n    const retryFunction = useCallback(\n      () =>\n        setResultsData(resultsData => ({\n          ...resultsData,\n          retry: (resultsData.retry ?? 0) + 1,\n        })),\n      []\n    );\n\n    useEffect(() => {\n      mutableRef.current.cacheKey = debouncedCacheKey;\n      if (debouncedCacheKey === null) {\n        setResultsData({});\n        return undefined;\n      }\n\n      const searchData = mutableRef.current.searchData;\n\n      const cachedResults = cache.getItem(debouncedCacheKey);\n      if (cachedResults) {\n        setResultsData({\n          results: filterResults(cachedResults, searchData),\n          resultsCacheKey: debouncedCacheKey,\n        });\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResultsData({loading: true});\n      loader(searchData, abortCtrl.signal)\n        .then(results => {\n          cache.setItem(debouncedCacheKey, results);\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResultsData({\n              results: filterResults(results, searchData),\n              resultsCacheKey: debouncedCacheKey,\n            });\n          }\n        })\n        .catch(error => {\n          if (isAbortError(error)) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResultsData({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [debouncedCacheKey, retry]);\n\n    return {\n      noSearch,\n      loading,\n      error: isResultForCurrentSearch ? error : null,\n      searchText,\n      searchData,\n      results: isResultForCurrentSearch ? results : null,\n      retry: retryFunction,\n    };\n  };\n\n  return useSearchDataLoader;\n};\n\nexport default buildSearchDataLoaderHook;\n","import {useEffect, useRef} from 'react';\n\nconst buildAutoSelectHook = ({partKey, autoSelect}) => {\n  const useAutoSelect = ({\n    searchText,\n    searchData,\n    results,\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n  }) => {\n    const mutableRef = useRef({});\n    mutableRef.current.searchData = searchData;\n    mutableRef.current.marker = marker;\n    mutableRef.current.markers = markers;\n    mutableRef.current.focusParent = focusParent;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.markersHandlers = markersHandlers;\n\n    const isLastPart = marker.parts[marker.parts.length - 1].key === partKey;\n    useEffect(() => {\n      if (!results) {\n        return;\n      }\n      const {\n        searchData,\n        marker,\n        markers,\n        focusParent,\n        onHide,\n        markersHandlers,\n      } = mutableRef.current;\n      const update = autoSelect({\n        marker,\n        markers,\n        searchText,\n        searchData,\n        results,\n        isLastPart,\n      });\n      if (!update) {\n        return;\n      }\n      if (!update.id) {\n        throw new Error(\n          `autoSelect function in part \"${partKey}\"'s search options did not return an \"id\" field which is required`\n        );\n      }\n      const newMarker = markersHandlers.updateMarkerPart(\n        {\n          marker,\n          partKey,\n        },\n        {\n          ...update,\n          cursor: update.cursor ?? 'end',\n          isLocked: update.isLocked ?? true,\n        }\n      );\n      focusParent();\n      if (update.hide || (update.hide === undefined && newMarker?.isLocked)) {\n        setTimeout(() => onHide(false));\n      }\n    }, [results, searchText, isLastPart]);\n  };\n\n  return useAutoSelect;\n};\n\nexport default buildAutoSelectHook;\n","import React, {useEffect} from 'react';\n\nimport buildSearchDataLoaderHook from '../hook/buildSearchDataLoaderHook';\nimport buildAutoSelectHook from '../hook/buildAutoSelectHook';\n\nconst buildSearchComponent = ({\n  markerType,\n  partKey,\n  detailsComponents,\n  loader,\n  filterResults,\n  getSearchData,\n  getCacheKey,\n  getCache,\n  ZeroSearchResultsComponent,\n  NoSearchComponent,\n  ResultsComponent,\n  LoaderComponent,\n  ErrorComponent,\n  debounceDuration,\n  autoSelect,\n  isAbortError,\n}) => {\n  const cache = getCache({type: 'search', markerType, partKey});\n\n  const useSearchDataLoader = buildSearchDataLoaderHook({\n    partKey,\n    loader,\n    cache,\n    getSearchData,\n    getCacheKey,\n    filterResults,\n    debounceDuration,\n    isAbortError,\n  });\n\n  const useAutoSelect = buildAutoSelectHook({\n    partKey,\n    autoSelect,\n  });\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const {noSearch, loading, error, searchText, searchData, results, retry} =\n      useSearchDataLoader({\n        marker,\n        markers,\n      });\n\n    useEffect(() => {\n      if (noSearch && !NoSearchComponent) {\n        onHide();\n      }\n    }, [noSearch, onHide]);\n\n    useAutoSelect({\n      searchText,\n      searchData,\n      results,\n      marker,\n      markers,\n      focusParent,\n      onHide,\n      markersHandlers,\n    });\n\n    if (noSearch && NoSearchComponent) {\n      return (\n        <NoSearchComponent\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (error) {\n      return (\n        <ErrorComponent\n          error={error}\n          retry={retry}\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (loading || !results) {\n      return (\n        <LoaderComponent\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    if (!results.length) {\n      return (\n        <ZeroSearchResultsComponent\n          results={results}\n          detailsComponents={detailsComponents}\n          partKey={partKey}\n          searchText={searchText}\n          searchData={searchData}\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          markersHandlers={markersHandlers}\n        />\n      );\n    }\n    return (\n      <ResultsComponent\n        results={results}\n        detailsComponents={detailsComponents}\n        partKey={partKey}\n        searchText={searchText}\n        searchData={searchData}\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        markersHandlers={markersHandlers}\n      />\n    );\n  };\n};\n\nexport default buildSearchComponent;\n","const negativeSupportingModulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nexport default negativeSupportingModulo;\n","import negativeSupportingModulo from 'lib/helpers/negativeSupportingModulo';\nimport React, {useEffect, useImperativeHandle, useRef, useState} from 'react';\n\nconst buildSearchResultsPickerComponent = ({\n  partKey,\n  ItemComponent,\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    markers,\n    markersHandlers,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        partKey,\n        selectedItem: data,\n        marker,\n        markers,\n      });\n      if (!update.id) {\n        throw new Error(\n          `onSelect function in part \"${partKey}\"'s search options did not return an \"id\" field which is required`\n        );\n      }\n      const newMarker = markersHandlers.updateMarkerPart(\n        {\n          marker,\n          partKey,\n        },\n        {\n          data,\n          ...update,\n          cursor: update.cursor ?? 'end',\n          isLocked: update.isLocked ?? true,\n        }\n      );\n      focusParent();\n      if (update.hide || (update.hide === undefined && newMarker?.isLocked)) {\n        setTimeout(() => onHide(false));\n      }\n    };\n\n    const focused =\n      focusedIndex == null\n        ? null\n        : negativeSupportingModulo(focusedIndex, results.length);\n    const focusedRef = useRef();\n\n    useEffect(() => {\n      if (focused != null && focusedRef.current) {\n        focusedRef.current.focus();\n        const t = setTimeout(() => {\n          if (\n            document.activeElement !== focusedRef.current &&\n            document.activeElement.getAttribute('tabIndex') === '-1'\n          ) {\n            document.activeElement.removeAttribute('tabIndex');\n            focusedRef.current.focus();\n          }\n        });\n        return () => clearTimeout(t);\n      }\n      return undefined;\n    }, [focused]);\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      }\n    };\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={elem => {\n                if (focused === i) {\n                  focusedRef.current = elem;\n                }\n              }}\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent\n                partKey={partKey}\n                item={item}\n                marker={marker}\n                markers={markers}\n              />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nexport default buildSearchResultsPickerComponent;\n","import mapAndKeyBy from 'lib/helpers/mapAndKeyBy';\nimport React from 'react';\nimport buildDetailsComponent from './buildDetailsComponent';\nimport buildSearchComponent from './buildSearchComponent';\nimport buildSearchResultsPickerComponent from './buildSearchResultsPickerComponent';\n\nconst buildMarkerTipComponent = ({\n  tipOptions: {markerType, anchorChar, parts},\n  isAbortError,\n}) => {\n  const detailsComponents = mapAndKeyBy(\n    parts,\n    ({key, details}) => {\n      if (!details) {\n        return null;\n      }\n      const {\n        Component,\n        NotFoundComponent,\n        loader,\n        getCacheKey,\n        shouldReloadData,\n        getLoadData,\n        LoaderComponent,\n        ErrorComponent,\n        getCache,\n      } = details;\n      return buildDetailsComponent({\n        markerType,\n        anchorChar,\n        partKey: key,\n        Component,\n        NotFoundComponent,\n        loader,\n        getCacheKey,\n        shouldReloadData,\n        getLoadData,\n        LoaderComponent,\n        ErrorComponent,\n        getCache,\n        isAbortError,\n      });\n    },\n    'key'\n  );\n\n  const searchComponents = mapAndKeyBy(\n    parts,\n    ({\n      key,\n      search: {\n        ResultsComponent,\n        ResultItemComponent,\n        onItemSelect,\n        ZeroSearchResultsComponent = () => 'No matching entries found',\n        NoSearchComponent,\n        loader,\n        filterResults,\n        getSearchData,\n        autoSelect: baseAutoSelect,\n        getCacheKey = searchData => JSON.stringify(searchData),\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n      },\n    }) => {\n      if (baseAutoSelect && !onItemSelect) {\n        throw new Error('autoSelect needs onItemSelect to be defined');\n      }\n      const autoSelect = baseAutoSelect\n        ? params => {\n            const {partKey, marker, markers} = params;\n            const selectedItem = baseAutoSelect(params);\n            if (!selectedItem) {\n              return undefined;\n            }\n            const update = onItemSelect({\n              partKey,\n              selectedItem,\n              marker,\n              markers,\n            });\n            if (update) {\n              return {\n                data: selectedItem,\n                ...update,\n              };\n            }\n            return update;\n          }\n        : () => undefined;\n      return buildSearchComponent({\n        markerType,\n        anchorChar,\n        partKey: key,\n        detailsComponents,\n        loader,\n        filterResults,\n        getSearchData,\n        getCacheKey,\n        NoSearchComponent,\n        ZeroSearchResultsComponent,\n        ResultsComponent: ResultItemComponent\n          ? buildSearchResultsPickerComponent({\n              partKey: key,\n              ItemComponent: ResultItemComponent,\n              ContainerComponent: ResultsComponent,\n              onSelect: onItemSelect,\n            })\n          : ResultsComponent,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n        autoSelect,\n        isAbortError,\n      });\n    },\n    'key'\n  );\n\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    if (marker.isLocked) {\n      const lastPartConfig = marker.partsConfig[marker.partsConfig.length - 1];\n      const DetailsComponent = detailsComponents[lastPartConfig.key];\n      return (\n        <DetailsComponent\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n\n    const firstUnresolvedPartIndex = marker.lastResolvedPartIndex + 1;\n    const firstUnresolvedPartConfig =\n      marker.partsConfig[firstUnresolvedPartIndex];\n    const SearchComponent = searchComponents[firstUnresolvedPartConfig.key];\n\n    return (\n      <SearchComponent\n        marker={marker}\n        markers={markers}\n        focusParent={focusParent}\n        onHide={onHide}\n        markersHandlers={markersHandlers}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n      />\n    );\n  };\n};\n\nexport default buildMarkerTipComponent;\n","import React, {useEffect, useRef} from 'react';\nimport buildMarkerTipComponent from './buildMarkerTipComponent';\n\nconst buildTipComponent = ({tipsOptionsByType, isAbortError}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = buildMarkerTipComponent({\n      tipOptions: tipsOptionsByType[type],\n      isAbortError,\n    });\n  }\n  return ({\n    marker,\n    markers,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          markers={markers}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nexport default buildTipComponent;\n","import withSmartTextArea from './hocs/withSmartTextArea';\n\nexport default withSmartTextArea;\n","import withMarkerParser from '../../withMarkerParser';\nimport withMarkableTextArea from '../../withMarkableTextArea';\nimport withResize from '../../withResize';\nimport withSelectionChange from '../../withSelectionChange';\nimport withMarkerSelection from '../../withMarkerSelection';\nimport withTips from '../../withTips';\nimport withFocusTipOnDown from '../../withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from '../../withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport withBlockUndoRedoAndDragDropText from '../../withBlockUndoRedoAndDragDropText';\nimport withBaseTextArea from '../../withBaseTextArea';\nimport fortifyGetCache from '../helpers/fortifyGetCache.';\nimport defaultGetCache from '../helpers/defaultGetCache';\nimport mapAndKeyBy from '../../../helpers/mapAndKeyBy';\nimport searchArray from '../../../helpers/searchArray';\nimport ensureLoaderIsAsync from '../helpers/ensureLoaderIsAsync';\nimport withId from './withId';\nimport withStyle from './withStyle';\nimport buildTipComponent from '../builders/component/buildTipComponent';\n\n/** @type {import('./types.jsdocs').WithSmartTextAreaHOC} */\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version = 0,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  debounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  lineHeight,\n  width,\n  TextArea,\n  tipsZIndex,\n  isAbortError = error =>\n    error.aborted || error.message.toLowerCase().includes('abort'),\n}) => {\n  getCache = getCache ? fortifyGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = mapAndKeyBy(\n    baseAnchors,\n    anchor => {\n      const anchorGetCache = anchor.getCache\n        ? fortifyGetCache(anchor.getCache)\n        : getCache;\n      const anchorLoaderComponent =\n        anchor.LoaderComponent || LoaderComponent || (() => 'Loading...');\n      const anchorErrorComponent =\n        anchor.ErrorComponent ||\n        ErrorComponent ||\n        (({error}) => error?.message || 'Oops');\n      const anchorDebounceDuration =\n        anchor.debounceDuration || debounceDuration;\n\n      return {\n        markerType: anchor.type,\n        parts: anchor.parts.map(\n          (\n            {\n              key,\n              searchConfig,\n              detailsConfig,\n              searchOptions,\n              detailsOptions,\n              LoaderComponent,\n              ErrorComponent,\n              debounceDuration,\n              getCache,\n            },\n            i\n          ) => {\n            searchConfig = searchConfig || searchOptions;\n            detailsConfig = detailsConfig || detailsOptions;\n            let searchLoader;\n            if (searchConfig.data) {\n              searchLoader = (\n                searchConfig.filterData ||\n                ((data, searchData) => searchArray(data, searchData.searchText))\n              ).bind(null, searchConfig.data);\n            } else {\n              searchLoader =\n                searchConfig.loader ||\n                searchConfig.search ||\n                searchConfig.searchFunction;\n            }\n            if (!searchLoader) {\n              throw new Error(\n                `${anchor.type}'s ${key} part does not have a search \"loader\" function nor (a \"data\" field with optional \"filterData\" function)`\n              );\n            }\n            let detailsLoader;\n            if (detailsConfig) {\n              if (searchConfig.data) {\n                if (!detailsConfig.findInSearchData) {\n                  throw new Error(\n                    `${anchor.type}'s ${key} part which has a \"data\" search field does not provide a \"findInSearchData\" function. It is needed to locate an specific item by id in the search \"data\"`\n                  );\n                }\n                detailsLoader = detailsConfig.findInSearchData.bind(\n                  null,\n                  searchConfig.data\n                );\n              } else {\n                detailsLoader =\n                  detailsConfig.loader ||\n                  detailsConfig.loadDetails ||\n                  detailsConfig.loadDetail;\n              }\n              if (!detailsLoader) {\n                throw new Error(\n                  `${anchor.type}'s ${key} part does not have a details \"loader\" function nor a (details \"findInSearchData\" function and a search \"data\" field)`\n                );\n              }\n            } else if (i === anchor.parts[i].length - 1) {\n              throw new Error(\n                `detailsConfig is issing for last part (${key}) of marker ${anchor.type}. Last part of a marker must have a detailsConfig defined`\n              );\n            }\n\n            return {\n              key,\n              search: {\n                LoaderComponent: LoaderComponent || anchorLoaderComponent,\n                ErrorComponent: ErrorComponent || anchorErrorComponent,\n                debounceDuration: debounceDuration || anchorDebounceDuration,\n                ...searchConfig,\n                filterResults:\n                  searchConfig.filterResults || (results => results),\n                getCache:\n                  searchConfig.getCache || getCache\n                    ? fortifyGetCache(searchConfig.getCache || getCache)\n                    : anchorGetCache,\n                loader: ensureLoaderIsAsync(searchLoader),\n              },\n              details: detailsConfig\n                ? {\n                    LoaderComponent: LoaderComponent || anchorLoaderComponent,\n                    ErrorComponent: ErrorComponent || anchorErrorComponent,\n                    ...detailsConfig,\n                    Component:\n                      detailsConfig.Component ||\n                      detailsConfig.DisplayComponent ||\n                      detailsConfig.DetailsComponent ||\n                      detailsConfig.DetailComponent,\n                    getCache:\n                      detailsConfig.getCache || getCache\n                        ? fortifyGetCache(detailsConfig.getCache || getCache)\n                        : anchorGetCache,\n                    loader: ensureLoaderIsAsync(detailsLoader),\n                  }\n                : null,\n            };\n          }\n        ),\n      };\n    },\n    'type'\n  );\n  const anchors = baseAnchors.map(anchor => ({\n    anchorChar: anchor.anchorChar,\n    type: anchor.type,\n    parts: anchor.parts.map(\n      ({\n        searchConfig,\n        detailsConfig,\n        searchOptions,\n        detailsOptions,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n        ...restOptions\n      }) => restOptions\n    ),\n  }));\n\n  return withId(getId)(\n    withStyle({\n      defaultLineHeight: lineHeight,\n      defaultWidth: width,\n    })(\n      withTips({\n        hideOnEscape: hideTipOnEscape,\n        TipComponent: buildTipComponent({\n          tipsOptionsByType,\n          isAbortError,\n        }),\n      })(\n        withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n          withFocusTipOnDown(\n            withMarkableTextArea({\n              classNameGetters,\n              tipsZIndex,\n              defaultBackgroundColor: backgroundColor,\n            })(\n              withResize(\n                withMarkerParser({\n                  markerParserOptions: {\n                    version,\n                    anchors,\n                  },\n                })(\n                  withMarkerSelection(\n                    withSelectionChange(\n                      withBlockUndoRedoAndDragDropText(\n                        withBaseTextArea(TextArea)\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({marker, markersHandlers}) => {\n  const [countDown, setCountDown] = useState(4);\n  const mutableRef = useRef({});\n  mutableRef.current.markersHandlers = markersHandlers;\n  mutableRef.current.marker = marker;\n  useEffect(() => {\n    const t = setInterval(() => {\n      setCountDown(countDown => countDown - 1);\n    }, 1000);\n    return () => clearInterval(t);\n  }, []);\n  const done = countDown === 0;\n  useEffect(() => {\n    if (done) {\n      mutableRef.current.markersHandlers.deleteMarker(\n        mutableRef.current.marker\n      );\n    }\n  }, [done]);\n  return <b>Person not found! will delete in {countDown}</b>;\n};\n\nconst capitalize = str =>\n  str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase();\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  classNameGetters: {\n    back: ({marker}, defaultClassName) => {\n      if (marker.type === 'combined' && marker.partsIds.type) {\n        return `${defaultClassName} textarea-back-${marker.partsIds.type}-label`;\n      }\n      return undefined;\n    },\n  },\n  anchors: [\n    {\n      anchorChar: '!',\n      type: 'combined',\n      parts: [\n        {\n          key: 'type',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: ({item}) => <div>{capitalize(item)}</div>,\n            loader: () => ['person', 'thing'],\n            onItemSelect: ({selectedItem}) => ({\n              text: capitalize(selectedItem),\n              id: selectedItem,\n            }),\n            autoSelect: ({searchText}) => {\n              switch (searchText?.trim().toLowerCase()) {\n                case 'person':\n                  return 'person';\n                case 'thing':\n                  return 'thing';\n                default:\n                  return undefined;\n              }\n            },\n            getCacheKey: () => '',\n          },\n          detailsOptions: {\n            Component: ({data}) => <h4>{capitalize(data)}</h4>,\n            loader: ({id}) => id,\n          },\n        },\n        {\n          key: 'item',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: props => {\n              switch (props.marker.partsIds.type) {\n                case 'person':\n                  return <PersonSearchResultItem {...props} />;\n                case 'thing':\n                  return <ThingSearchResultItem {...props} />;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            loader: ({searchText, partsIds: {type}}, signal) => {\n              switch (type) {\n                case 'person':\n                  return personSearch(searchText, signal);\n                case 'thing':\n                  return thingSearch(searchText, signal);\n                default:\n                  throw new Error('Oops! Unknown type!');\n              }\n            },\n            onItemSelect: ({\n              selectedItem,\n              marker: {\n                partsIds: {type},\n              },\n            }) => {\n              switch (type) {\n                case 'person':\n                  return {\n                    text: selectedItem.name,\n                    id: selectedItem.id,\n                  };\n                case 'thing':\n                  return {\n                    text: selectedItem.name,\n                    id: selectedItem.id,\n                  };\n                default:\n                  return false;\n              }\n            },\n            getCacheKey: ({searchText, partsIds: {type}}) =>\n              `${type}:${searchText?.trim().toLowerCase() || ''}`,\n          },\n          detailsOptions: {\n            Component: props => {\n              switch (props.marker.partsIds.type) {\n                case 'person':\n                  return <PersonDetails {...props} />;\n                case 'thing':\n                  return <ThingDetails {...props} />;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            NotFoundComponent: props => {\n              const onHide = props.onHide;\n              const type = props.marker.partsIds.type;\n              useEffect(() => {\n                if (type === 'thing') {\n                  onHide();\n                }\n              }, [type, onHide]);\n              switch (type) {\n                case 'person':\n                  return <NotFoundPersonComponent {...props} />;\n                case 'thing':\n                  return null;\n                default:\n                  return 'Oops! Unknown type!';\n              }\n            },\n            loader: ({type, item: id}, signal) => {\n              switch (type) {\n                case 'person':\n                  return personDetails(id, signal);\n                case 'thing':\n                  return thingDetails(id, signal);\n                default:\n                  throw new Error('Oops! Unknown type!');\n              }\n            },\n            getCacheKey: ({type, item: id}) => `${type}:${id}`,\n          },\n        },\n      ],\n    },\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'person',\n          endChar: ':',\n          searchOptions: {\n            ResultItemComponent: PersonSearchResultItem,\n            NoResultItemComponent: () => 'No matching people found',\n            onItemSelect: ({selectedItem: person}) => ({\n              text: person.name,\n              id: person.id,\n            }),\n            loader: ({searchText: name}, signal) => personSearch(name, signal),\n            getCacheKey: ({searchText: name}) =>\n              name?.trim().toLowerCase() || null,\n            debounceDuration: 350,\n          },\n          detailsOptions: {\n            Component: PersonDetails,\n            NotFoundComponent: NotFoundPersonComponent,\n            loader: ({person: id}, signal) => personDetails(id, signal),\n            getCacheKey: ({person: id}) => id,\n          },\n        },\n      ],\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'thing',\n          endChar: ':',\n          searchOptions: {\n            ResultsComponent: ({ResultListComponent, ...props}) => (\n              <p>\n                <h5>Found the following things:</h5>\n                <ResultListComponent {...props} />\n              </p>\n            ),\n            NoSearchComponent: () => (\n              <pre>\n                Write something to start the search.\n                <br />\n                This custom no search message is only configured for things\n              </pre>\n            ),\n            ResultItemComponent: ThingSearchResultItem,\n            onItemSelect: ({selectedItem: thing}) => ({\n              text: thing.name,\n              id: thing.id,\n            }),\n            loader: ({searchText: name}, signal) => thingSearch(name, signal),\n            getCacheKey: ({searchText: name}) =>\n              name?.trim().toLowerCase() || null,\n            debounceDuration: 350,\n          },\n          detailsOptions: {\n            Component: ThingDetails,\n            loader: ({thing: id}, signal) => thingDetails(id, signal),\n            getCacheKey: ({thing: id}) => id,\n          },\n        },\n      ],\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useRef, useState} from 'react';\nimport classes from './App.module.css';\nimport SmartTextArea, {people, things} from './SmartTextArea';\n\nconst availablePpl = people.map(person => person.name).join(', ');\nconst availableThings = things.map(thing => thing.name).join(', ');\nconst App = () => {\n  const [markers, setMarkers] = useState([]);\n  const [inEditMarker, setInEditMarker] = useState([]);\n  const imperativeRef = useRef();\n  return (\n    <div className={classes.container}>\n      <ul>\n        <li>\n          use <b>!</b> to trigger mixed marker start. Here you first need to\n          select a type (person/thing), then select the item you want.\n          <ul>\n            <li>\n              Available people:\n              <br />\n              {availablePpl}\n            </li>\n            <li>\n              Available things:\n              <br />\n              {availableThings}\n            </li>\n            <li>\n              Mixed marker has autoSelect enabled on its first part (the type\n              part). to test it out try writing &quot;!person&quot; and it\n              should automatically select the person type.\n            </li>\n            <li>\n              if selected type is thing the color of the marker will be orange,\n              else it will default to gray\n            </li>\n            <li>\n              All mixed markers will have a custom gray border (actually its an\n              outline)\n            </li>\n          </ul>\n        </li>\n        <li>\n          use <b>@</b> to trigger person marker start. Available people to\n          search same as above.\n          <br />\n          people marker color is the default gray color\n        </li>\n        <li>\n          use <b>#</b> to trigger things marker start. Available things to\n          search same as above.\n          <br />\n          things marker color is a custom orange color\n        </li>\n      </ul>\n      <SmartTextArea\n        className=\"smart-text-area\"\n        imperativeRef={imperativeRef}\n        initValue={\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\n        }\n        initMarkers={[\n          {\n            start: 0,\n            end: 13,\n            type: 'combined',\n            partsIds: {type: 'person', item: 'mo'},\n          },\n          {start: 46, end: 54, type: 'person', partsIds: {person: 'john'}},\n          {start: 78, end: 86, type: 'person', partsIds: {person: 'jane'}},\n          {start: 112, end: 117, type: 'person', partsIds: {person: 'asdfg'}},\n          {start: 149, end: 153, type: 'thing', partsIds: {thing: 'fork'}},\n          {\n            start: 155,\n            end: 160,\n            type: 'combined',\n            partsIds: {type: 'thing', item: 'knife'},\n          },\n          {start: 165, end: 170, type: 'thing', partsIds: {thing: 'spoon'}},\n        ]}\n        onMarkersChange={e => {\n          setMarkers(e.markers);\n        }}\n        onInEditMarkerChange={e => {\n          setInEditMarker(e.markers[e.inEditMarkerIndex]);\n        }}\n      />\n      <h5>Markers:</h5>\n      <pre>\n        {markers.map(({partsConfig, ...marker}) => (\n          <div\n            key={marker.uuid}\n            className={\n              marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\n            }>\n            {JSON.stringify(marker, null, 3)}\n          </div>\n        ))}\n      </pre>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}