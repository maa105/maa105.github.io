{"version":3,"sources":["environment/App/App.module.css","lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withSelectionBlocker.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/components/BaseTextArea.js","lib/hooks/useDebounceValue.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hooks/usePrev.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["module","exports","mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","blockMarkerUpdates","selection","markers","midSelectedMarkerIndex","endSelectedMarkerIndex","startSelectedMarkerIndex","midSelectedMarker","endSelectedMarker","startSelectedMarker","isLocked","block","selectionStart","start","selectionEnd","end","getMarkerSelections","prevMarkerIndex","nextMarkerIndex","selectedMarkersRange","startIndex","endIndex","markerWithStartTouchedIndex","markerWithEndTouchedIndex","getReturn","marker","startTotallySelected","endTotallySelected","totalySelected","withMarkerSelectionBlocker","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","restProps","innerRef","useEffect","textarea","onPointerDownListener","pointerDown","onPointerUpListener","addEventListener","document","removeEventListener","e","target","isSingleSelection","prevSelection","startCursorMoved","endCursorMoved","DEFAULT_END","spaces","getMarkerRawValue","textareaValue","substring","createMarker","uuid","anchor","type","markerData","data","Math","round","random","Date","now","parseMarkers","options","anchors","parts","j","key","startChar","endChars","partStart","push","anchorChar","version","wrapMarkerParser","markerOffset","oldFirstMarker","map","prevValue","insertedText","markerParser","newValue","lengthChange","inEditMarkerIndex","newMarkers","slice","nextMarkers","inEditMarker","startParse","endParse","toParse","parsedValue","parsedMarkers","nextNewMarkers","getIneditMarkerIndex","withMarkerParser","markerParserOptions","forEach","endChar","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","onInEditMarkerChange","imperativeRef","props","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","updateMarker","findIndex","m","updateFunction","newMarker","textValue","appendText","markerUpdates","hasNewText","join","oldValue","oldMarkers","undefined","childImperativeRef","newSelectionEnd","prevSelectionEnd","minSelectionEnd","min","blockResult","blockTimer","clearTimeout","setTimeout","err","preventDefault","error","oldInEditMarkerIndex","newCursorPosition","newInEditMarkerIndex","oldInEditMarker","newInEditMarker","properties","getCoordinatesAtPositions","positions","debug","el","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","pointerEnter","timer","visibile","showTip","hideTip","pointerLeave","focus","delta","markerUuid","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onPointerEnter","onPointerLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","constraints","to","renderTarget","renderElement","focusParent","onHide","whereToFocus","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","Boolean","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultLineHeight","defaultBackgroundColor","classNameGetters","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","onKeyUpListener","withHideTipOnEscape","listener","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","newTipsData","newTipsDataStack","filter","lastTipData","oldDataStack","newDataStack","currType","BaseTextArea","React","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","withFocusTipOnDown","tipData","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","inMe","dataset","tipForTextarea","tipAnchorForTextarea","tipForMarker","tipAnchorForMarker","usePrev","preValue","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","getSingleTip","tipOptions","search","SearchResultsComponent","ResultsComponent","SearchResultsItemComponent","ResultItemComponent","resultItemComponentOnSelect","NoResultItemComponent","searchFunction","loader","preProcessMarkerData","preProcessMarkerDataForSearch","getCacheKey","getSearchCacheKey","searchData","SearchLoaderComponent","LoaderComponent","SearchErrorComponent","ErrorComponent","debounceDuration","details","DetailComponent","Component","loadSingleFunction","DetailNotFoundComponent","NotFoundComponent","preProcessMarkerDataForSingleLoad","getDetailsCacheKey","DetailLoaderComponent","DetailErrorComponent","CommonLoaderComponent","CommonErrorComponent","getCache","cache","loading","setResult","loadData","cacheKey","cachedData","getItem","abortCtrl","AbortController","signal","then","result","setItem","catch","aborted","abort","getDetailComponent","ItemComponent","NoItemsComponent","ContainerComponent","ResultListComponent","onSelect","results","focusedIndex","setFocusedIndex","index","num","mod","select","selectedItem","focused","toFocus","onKeyDown","next","item","tabIndex","getSearchResultPickerComponent","setResults","cachedResults","getTip","tipsOptionsByType","ComponentsByType","defaultGetCache","withSmartTextArea","baseAnchors","hideTipOnEscape","getId","wrapGetCache","searchOptions","detailsOptions","withId","people","name","imageUrl","things","SmartTextArea","person","src","alt","Promise","resolve","reject","trim","toLocaleLowerCase","includes","toLowerCase","Error","personSearch","countDown","setCountDown","updateMarkerRef","setInterval","clearInterval","done","find","personDetails","thing","thingSearch","thingDetails","message","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.e5c3f683.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"inEditMarker\":\"App_inEditMarker__2hzif\"};","const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (typeof ref === 'string') {\n        // console.log(ref, element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","export const blockMarkerUpdates = selection => {\n  const {\n    markers,\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = selection;\n\n  const midSelectedMarker = markers[midSelectedMarkerIndex];\n  const endSelectedMarker = markers[endSelectedMarkerIndex];\n  const startSelectedMarker = markers[startSelectedMarkerIndex];\n\n  if (midSelectedMarker && midSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: midSelectedMarker.start,\n      selectionEnd: midSelectedMarker.end,\n    };\n  }\n  if (endSelectedMarker && endSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: endSelectedMarker.start,\n      selectionEnd: endSelectedMarker.end,\n    };\n  }\n  if (startSelectedMarker && startSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: startSelectedMarker.start,\n      selectionEnd: startSelectedMarker.end,\n    };\n  }\n  return {\n    block: false,\n  };\n};\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart: start,\n  selectionEnd: end,\n}) => {\n  const selectedMarkersRange = {startIndex: -1, endIndex: -1};\n  let startSelectedMarkerIndex = -1;\n  let endSelectedMarkerIndex = -1;\n  let midSelectedMarkerIndex = -1;\n  let markerWithStartTouchedIndex = -1;\n  let markerWithEndTouchedIndex = -1;\n  let prevMarkerIndex;\n  let nextMarkerIndex;\n  let i = 0;\n\n  const getReturn = () => ({\n    markers,\n    selectedMarkersRange,\n    startSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    midSelectedMarkerIndex,\n    markerWithStartTouchedIndex,\n    markerWithEndTouchedIndex,\n    prevMarkerIndex,\n    nextMarkerIndex:\n      (nextMarkerIndex ?? -1) >= markers.length ? -1 : nextMarkerIndex ?? -1,\n  });\n\n  for (; i < markers.length && markers[i].end < start; i++);\n\n  prevMarkerIndex = i - 1;\n\n  let marker = markers[i];\n  if (!marker) {\n    return getReturn();\n  }\n\n  if (marker.end === start) {\n    markerWithEndTouchedIndex = prevMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n  }\n\n  if (marker.start >= end) {\n    nextMarkerIndex = i;\n    if (marker.start === end) {\n      markerWithStartTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected = start <= marker.start && marker.start < end;\n  let endTotallySelected = start < marker.end && marker.end <= end;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedMarkerIndex = i;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedMarkerIndex = i;\n      nextMarkerIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedMarkersRange.startIndex = i;\n\n  i++;\n  for (; i < markers.length; i++) {\n    marker = markers[i];\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedMarkersRange.endIndex = i;\n  return getReturn();\n};\n\nconst withMarkerSelectionBlocker = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {onSelectionChange: onSelectionChangeFromParent, markers, ...restProps},\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        let start = selectionStart;\n        let end = selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.start === selectionStart\n            ? 0\n            : selectionStart - prevSelection.start;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.end === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.end;\n\n        let {\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          // eslint-disable-next-line prefer-const\n          prevMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          nextMarkerIndex,\n        } = getMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n        });\n\n        if (midSelectedMarkerIndex >= 0) {\n          const midSelectedMarker = markers[midSelectedMarkerIndex];\n          if (midSelectedMarker.isLocked) {\n            if (isSingleSelection) {\n              if (startCursorMoved < 0) {\n                start = end = midSelectedMarker.start;\n                markerWithStartTouchedIndex = midSelectedMarkerIndex;\n              } else {\n                start = end = midSelectedMarker.end;\n                markerWithEndTouchedIndex = midSelectedMarkerIndex;\n              }\n              midSelectedMarkerIndex = -1;\n            } else {\n              start = midSelectedMarker.start;\n              end = midSelectedMarker.end;\n              selectedMarkersRange.startIndex = midSelectedMarkerIndex;\n              selectedMarkersRange.endIndex = midSelectedMarkerIndex;\n              midSelectedMarkerIndex = -1;\n            }\n          }\n        } else {\n          if (endSelectedMarkerIndex >= 0) {\n            const endSelectedMarker = markers[endSelectedMarkerIndex];\n            if (endSelectedMarker.isLocked) {\n              if (startCursorMoved < 0) {\n                start = endSelectedMarker.start;\n                selectedMarkersRange.startIndex = endSelectedMarkerIndex;\n                if (selectedMarkersRange.endIndex === -1) {\n                  selectedMarkersRange.endIndex = endSelectedMarkerIndex;\n                }\n                endSelectedMarkerIndex = -1;\n              } else {\n                start = endSelectedMarker.end;\n                markerWithEndTouchedIndex = endSelectedMarkerIndex;\n                endSelectedMarkerIndex = -1;\n              }\n            }\n          }\n          if (startSelectedMarkerIndex >= 0) {\n            const startSelectedMarker = markers[startSelectedMarkerIndex];\n            if (startSelectedMarker.isLocked) {\n              if (endCursorMoved > 0) {\n                end = startSelectedMarker.end;\n                selectedMarkersRange.endIndex = startSelectedMarkerIndex;\n                if (selectedMarkersRange.startIndex === -1) {\n                  selectedMarkersRange.startIndex = startSelectedMarkerIndex;\n                }\n                startSelectedMarkerIndex = -1;\n              } else {\n                end = startSelectedMarker.start;\n                markerWithStartTouchedIndex = startSelectedMarkerIndex;\n                startSelectedMarkerIndex = -1;\n              }\n            }\n          }\n        }\n\n        if (selectionEnd !== end) {\n          textarea.selectionEnd = end;\n        }\n        if (selectionStart !== start) {\n          textarea.selectionStart = start;\n        }\n        if (!mutableRef.current.pointerDown) {\n          mutableRef.current.selection = {start, end};\n        }\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            markers,\n\n            selectionStart: start,\n            selectionEnd: end,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            selectedMarkersRange,\n            startSelectedMarkerIndex,\n            markerWithStartTouchedIndex,\n            nextMarkerIndex,\n          });\n      };\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const onPointerDownListener = () => {\n          mutableRef.current.pointerDown = true;\n        };\n        const onPointerUpListener = () => {\n          mutableRef.current.pointerDown = false;\n        };\n        textarea.addEventListener('pointerdown', onPointerDownListener);\n        document.addEventListener('pointerup', onPointerUpListener);\n        return () => {\n          textarea.removeEventListener('pointerdown', onPointerDownListener);\n          document.removeEventListener('pointerup', onPointerUpListener);\n        };\n      }, []);\n\n      return (\n        <TextArea\n          ref={mergeRefs('withSelectionBlocker', ref, innerRef)}\n          {...restProps}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelectionBlocker;\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {getMarkerSelections} from './withSelectionBlocker';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n};\n\nconst getMarkerRawValue = (textareaValue, marker) =>\n  textareaValue.substring(marker.start, marker.end);\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  anchor,\n  type,\n  start,\n  end,\n  markerData = {},\n  data,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  anchor,\n  type,\n  start,\n  end,\n  markerData,\n  data,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if ((i === 0 || spaces[value[i - 1]]) && anchors[value[i]]) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const markerData = {};\n\n    const parts = anchor.parts;\n    for (let j = 0; j < parts.length; j++) {\n      const {key, startChar, endChars} = parts[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      markerData[key] = value.substring(partStart, i);\n      if (i >= value.length || endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n      if (endChars[value[i]] === CURRENT_END) {\n        i++;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      markerData,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser =\n  (parseMarkers, options) => (value, markerOffset, oldFirstMarker) => {\n    const markers = parseMarkers(value, options).map((marker, i) => {\n      const updatedMarker = createMarker({\n        isLocked: false,\n        ...(i === 0 && marker.start === 0 ? oldFirstMarker : {}),\n        ...marker,\n        uuid:\n          i === 0 && marker.start === 0 && oldFirstMarker\n            ? oldFirstMarker.uuid\n            : null,\n        start: marker.start + markerOffset,\n        end: marker.end + markerOffset,\n        value,\n      });\n      return updatedMarker;\n    });\n    return [value, markers];\n  };\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  let lengthChange = newValue.length - prevValue.length;\n  let inEditMarkerIndex = -1;\n\n  let newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    inEditMarkerIndex = midSelectedMarkerIndex;\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end: selectionEnd,\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n      lengthChange = insertedText.length;\n      newValue =\n        prevValue.substring(0, selectionStart) +\n        insertedText +\n        prevValue.substring(selectionEnd);\n    }\n    newMarkers.push(\n      ...markers.slice(midSelectedMarkerIndex + 1).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }))\n    );\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      inEditMarkerIndex = markerWithEndTouchedIndex;\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex + 1));\n    } else if (endSelectedMarkerIndex >= 0) {\n      inEditMarkerIndex = endSelectedMarkerIndex;\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n      if (!endSelectedMarker.isLocked) {\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart,\n        });\n      } else {\n        selectionStart = selectionEnd = endSelectedMarker.end;\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex + 1));\n        lengthChange = insertedText.length;\n        newValue =\n          prevValue.substring(0, selectionStart) +\n          insertedText +\n          prevValue.substring(selectionEnd);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker && !inEditMarker.isLocked) {\n    const startParse = inEditMarker.start;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(\n      toParse,\n      startParse,\n      inEditMarker // will just update him and should be returned as first element\n    );\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    newMarkers = [\n      ...newMarkers.slice(0, inEditMarkerIndex),\n      ...parsedMarkers,\n      ...newMarkers.slice(inEditMarkerIndex + 1),\n    ];\n  } else {\n    const startParse =\n      prevMarkerIndex >= 0 ? newMarkers[prevMarkerIndex].end : 0;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(toParse, startParse);\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    const nextNewMarkers = [];\n    if (prevMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(0, prevMarkerIndex + 1));\n    }\n    nextNewMarkers.push(...parsedMarkers);\n    if (nextMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(nextMarkerIndex));\n    }\n    newMarkers = nextNewMarkers;\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst getIneditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\n\nconst withMarkerParser = ({\n  markerParser = parseMarkers,\n  markerParserOptions = {\n    version: 0,\n    anchors: [\n      {\n        anchorChar: '@',\n        type: 'person',\n        parts: [\n          {\n            key: 'username',\n          },\n        ],\n      },\n      {\n        anchorChar: '#',\n        type: 'rfi',\n        parts: [\n          {\n            key: 'rifId',\n          },\n        ],\n      },\n    ],\n  },\n} = {}) => {\n  if (markerParser === parseMarkers) {\n    const anchors = {};\n    markerParserOptions.anchors.forEach(anchor => {\n      const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n        key,\n        startChar,\n        endChars: {\n          ...(endChar ? {[endChar]: CURRENT_END} : spaces),\n          ...(parts[i + 1]?.startChar\n            ? {\n                [parts[i + 1].startChar]: NEXT_START,\n              }\n            : null),\n        },\n      }));\n      anchors[anchor.anchorChar] = {\n        ...anchor,\n        parts,\n      };\n    });\n    markerParserOptions = {...markerParserOptions, anchors};\n  }\n\n  markerParser = wrapMarkerParser(markerParser, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onMarkersChange,\n          onInEditMarkerChange,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers: (initMarkers ?? []).map(marker =>\n            createMarker({\n              ...marker,\n              isLocked: true,\n            })\n          ),\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const updateMarker = (marker, update) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const updateFunction = update => {\n                if (!update && update !== null) {\n                  return marker;\n                }\n\n                let newValue;\n                let newMarkers;\n                let newMarker = null;\n\n                if (update) {\n                  const {textValue, appendText = '', ...markerUpdates} = update;\n                  const hasNewText = textValue != null;\n                  const lengthChange = hasNewText\n                    ? textValue.length +\n                      appendText.length -\n                      (marker.end - marker.start)\n                    : 0;\n\n                  newMarkers = [...markers.slice(0, i)];\n                  newMarker = {\n                    ...marker,\n                    end: hasNewText\n                      ? marker.start + textValue.length\n                      : marker.end,\n                    ...markerUpdates,\n                  };\n                  newMarkers.push(newMarker);\n                  if (lengthChange) {\n                    newMarkers.push(\n                      ...markers.slice(i + 1).map(marker => ({\n                        ...marker,\n                        start: marker.start + lengthChange,\n                        end: marker.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newMarkers.push(...markers.slice(i + 1));\n                  }\n\n                  newValue = value;\n                  if (hasNewText) {\n                    newValue = [\n                      value.substring(0, marker.start),\n                      textValue,\n                      appendText,\n                      value.substring(marker.end),\n                    ].join('');\n\n                    setValue(newValue);\n                  }\n                  setMarkers(newMarkers);\n                } else {\n                  const {start: selectionStart, end: selectionEnd} = marker;\n                  const lengthChange = selectionEnd - selectionStart;\n\n                  newValue =\n                    value.substring(0, marker.start) +\n                    value.substring(marker.end);\n\n                  newMarkers = [\n                    ...markers.slice(0, i),\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      start: marker.start - lengthChange,\n                      end: marker.end - lengthChange,\n                    })),\n                  ];\n\n                  setValue(newValue);\n                  setMarkers(newMarkers);\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                    inEditMarker: mutableRef.current.inEditMarker,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update(marker));\n              }\n              return updateFunction(update);\n            };\n            return {\n              updateMarker: (marker, update) =>\n                updateMarker(marker, marker => {\n                  if (typeof update === 'function') {\n                    update = update(marker);\n                  }\n                  if (update) {\n                    let isLocked;\n                    if (marker.isLocked) {\n                      isLocked = true;\n                      if (update.isLocked === false) {\n                        console.warn(\n                          'cannot unloack a locked marker. Will keep it locked!'\n                        );\n                      }\n                    } else {\n                      isLocked = update.isLocked ?? false;\n                    }\n                    return {\n                      isLocked,\n                      textValue: update.textValue,\n                      data:\n                        update.data === undefined ? marker.data : update.data,\n                      markerData: update.markerData ?? marker.markerData,\n                    };\n                  }\n                  return update;\n                }),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          const newSelectionEnd = textarea.selectionEnd;\n          const prevSelectionEnd =\n            prevValue.length - (newValue.length - newSelectionEnd);\n          const minSelectionEnd = Math.min(prevSelectionEnd, newSelectionEnd);\n\n          let selectionStart;\n          for (\n            selectionStart = 0;\n            selectionStart < minSelectionEnd &&\n            prevValue[selectionStart] === newValue[selectionStart];\n            selectionStart++\n          );\n\n          let selection = getMarkerSelections({\n            markers,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          const blockResult = blockMarkerUpdates(selection);\n\n          if (mutableRef.current.blockTimer) {\n            clearTimeout(mutableRef.current.blockTimer);\n            mutableRef.current.blockTimer = null;\n          }\n          if (blockResult.block) {\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            mutableRef.current.blockTimer = setTimeout(() => {\n              mutableRef.current.blockTimer = null;\n              try {\n                textarea.selectionStart = blockResult.selectionStart;\n                textarea.selectionEnd = blockResult.selectionEnd;\n                // eslint-disable-next-line no-empty\n              } catch (err) {}\n            });\n            e.preventDefault();\n            return false;\n          }\n\n          const insertedText = newValue.substring(\n            selectionStart,\n            newSelectionEnd\n          );\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {newValue: parsedValue, newMarkers: parsedMarkers} = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          if (parsedValue !== newValue) {\n            console.error(\n              `OOPS! input tracking is broken. Expected \"${newValue}\" got \"${parsedValue}\"`\n            );\n          }\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const oldInEditMarkerIndex = selection.inEditMarkerIndex;\n\n          const newCursorPosition = newSelectionEnd; // might need to be refined!!!\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          const newInEditMarkerIndex = getIneditMarkerIndex(selection);\n          selection.inEditMarkerIndex = newInEditMarkerIndex;\n\n          mutableRef.current.selection = selection;\n\n          const oldInEditMarker = markers[oldInEditMarkerIndex];\n          const newInEditMarker = parsedMarkers[newInEditMarkerIndex];\n          if (\n            onInEditMarkerChange &&\n            (newInEditMarker?.uuid !== oldInEditMarker?.uuid ||\n              (newInEditMarker &&\n                getMarkerRawValue(parsedValue, newInEditMarker) !==\n                  getMarkerRawValue(prevValue, oldInEditMarker)))\n          ) {\n            onInEditMarkerChange({\n              target: textarea,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n              inEditMarker: newInEditMarker,\n              oldInEditMarker: mutableRef.current.inEditMarker,\n            });\n          }\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n              inEditMarker: newInEditMarker,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n              inEditMarker: mutableRef.current.inEditMarker,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs('withMarkerParser', ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const pointerEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('pointerOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: false,\n        type,\n      });\n    }\n  };\n  const pointerLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('pointerOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = ({start, delta} = {}) => {\n    delta = delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else {\n      markersHandlers.focus(marker.end + delta);\n    }\n  };\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onPointerEnter={() => pointerEnter(i)}\n        onPointerLeave={pointerLeave}\n        onPointerDown={focus}\n        onPointerUp={focus}\n        onClick={focus}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onPointerEnter: () => pointerEnter(i),\n              onPointerLeave: pointerLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({marker})}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultLineHeight = '135%',\n  defaultBackgroundColor = 'white',\n  classNameGetters = defaultClassNameGetters,\n} = {}) => {\n  classNameGetters = {...defaultClassNameGetters, ...classNameGetters};\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          lineHeight = defaultLineHeight,\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.inEditMarker;\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div id={id} className=\"textarea-container\" style={{backgroundColor}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              style={{\n                ...restProps.style,\n                lineHeight: restProps.style?.lineHeight ?? lineHeight,\n              }}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div className=\"textarea-with-resize-container\">\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visibile, labelLineIndex}) => {\n            const markerUuid = marker?.uuid || marker;\n            if (!visibile && !markerUuid) {\n              if (!type) {\n                setVisibleTipsSettings({\n                  data: {},\n                  dataStack: {},\n                });\n                return;\n              }\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  newTipsDataStack[markerUuid] = newTipsDataStack[\n                    markerUuid\n                    // eslint-disable-next-line no-loop-func\n                  ].filter(({type: currType}) => currType !== type);\n                  if (newTipsDataStack[markerUuid].length) {\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              if (!visibile) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (oldDataStack) {\n                  if (type) {\n                    const newDataStack = oldDataStack.filter(\n                      ({type: currType}) => type !== currType\n                    );\n\n                    if (newDataStack.length) {\n                      const lastTipData = newDataStack[newDataStack.length - 1];\n                      return {\n                        data: {\n                          ...tipsData,\n                          [markerUuid]: {\n                            type: lastTipData.type,\n                            labelLineIndex: lastTipData.labelLineIndex,\n                            focus: tipsData[markerUuid].focus,\n                          },\n                        },\n                        dataStack: {\n                          ...tipsDataStack,\n                          [markerUuid]: newDataStack,\n                        },\n                      };\n                    }\n                  }\n\n                  const newTipsData = {...tipsData};\n                  delete newTipsData[markerUuid];\n\n                  const newDataStack = {...tipsDataStack};\n                  delete newDataStack[markerUuid];\n\n                  return {\n                    data: newTipsData,\n                    dataStack: newDataStack,\n                  };\n                }\n\n                return visibleTipsSettings;\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {inEditMarker, oldInEditMarker} = e;\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visibile: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker) {\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visibile: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst BaseTextArea = React.forwardRef(\n  ({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <textarea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  }\n);\n\nexport default BaseTextArea;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visibile: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visibile: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={e => {\n            mutableRef.current.inEditMarker = e.inEditMarker;\n            onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n          }}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const listener = e => {\n        let elem = e.target;\n        let inMe = false;\n        while (elem) {\n          if (\n            elem.id === id ||\n            elem.dataset?.tipForTextarea === id ||\n            elem.dataset?.tipAnchorForTextarea === id\n          ) {\n            inMe = true;\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!inMe) {\n          mutable.updateTipVisibility({\n            visibile: false,\n          });\n          e.preventDefault();\n        } else {\n          mutable.updateTipVisibility({\n            visibile: false,\n            type: 'clickOnTip',\n          });\n          const markerUuid =\n            elem.dataset?.tipForMarker || elem.dataset?.tipAnchorForMarker;\n          if (markerUuid) {\n            mutable.updateTipVisibility({\n              marker: markerUuid,\n              visibile: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', listener);\n      return () => document.removeEventListener('click', listener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import {useRef} from 'react';\n\nconst usePrev = value => {\n  const ref = useRef(undefined);\n  const preValue = ref.current;\n  ref.current = value;\n  return preValue;\n};\n\nexport default usePrev;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport AbortController from 'abort-controller';\n\nimport withMarkerParser from './withMarkerParser';\nimport withMarkableTextArea from './withMarkableTextArea';\nimport withResize from './withResize';\nimport withSelectionChange from './withSelectionChange';\nimport withMarkerSelectionBlocker from './withSelectionBlocker';\nimport withTips from './withTips';\n\nimport BaseTextArea from '../components/BaseTextArea';\nimport useDebounceValue from '../hooks/useDebounceValue';\nimport withFocusTipOnDown from './withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from './withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport usePrev from '../hooks/usePrev';\nimport withBlockUndoRedoAndDragDropText from './withBlockUndoRedoAndDragDropText';\n\nconst getDetailComponent = ({\n  Component,\n  NotFoundComponent,\n  loader,\n  preProcessMarkerData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n}) => {\n  const cache = getCache();\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  return ({marker, updateMarker}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error}, setResult] = useState({});\n\n    const {data, markerData} = marker;\n    const loadData = preProcessMarkerData(markerData);\n    const cacheKey = getCacheKey(loadData);\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.updateMarker = updateMarker;\n    mutableRef.current.cacheKey = cacheKey;\n\n    useEffect(() => {\n      if (data || data === null) {\n        return null;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.updateMarker({\n          data: cachedData,\n        });\n        setResult({});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResult({loading: true});\n      loader(mutableRef.current.loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.updateMarker({\n              data: result,\n            });\n            setResult({});\n          }\n        })\n        .catch(error => {\n          if (error.aborted) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResult({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, data]);\n\n    if (loading) {\n      return <LoaderComponent loadData={loadData} />;\n    }\n\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          marker={marker}\n          updateMarker={updateMarker}\n        />\n      );\n    }\n\n    if (data) {\n      return (\n        <Component data={data} marker={marker} updateMarker={updateMarker} />\n      );\n    }\n\n    return null;\n  };\n};\n\nconst modulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nconst getSearchResultPickerComponent = ({\n  ItemComponent,\n  NoItemsComponent = () => 'No matching entries found',\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    updateMarker,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        selectedItem: data,\n        marker,\n      });\n      updateMarker({\n        data,\n        ...update,\n        isLocked: update.isLocked ?? true,\n      });\n      setTimeout(() => onHide());\n    };\n\n    const focused =\n      focusedIndex == null ? null : modulo(focusedIndex, results.length);\n    const toFocus = usePrev(focused) !== focused ? focused : null;\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n        }\n      }\n    };\n\n    if (!results.length) {\n      return <NoItemsComponent marker={marker} />;\n    }\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={\n                toFocus === i\n                  ? elem => {\n                      if (elem?.focus) {\n                        elem.focus();\n                      }\n                    }\n                  : null\n              }\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent item={item} />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nconst getSingleTip = ({\n  tipOptions: {\n    search: {\n      ResultsComponent: SearchResultsComponent,\n      ResultItemComponent: SearchResultsItemComponent,\n      resultItemComponentOnSelect,\n      NoResultItemComponent,\n      loader: searchFunction,\n      preProcessMarkerData: preProcessMarkerDataForSearch = markerData =>\n        markerData,\n      getCacheKey: getSearchCacheKey = searchData => JSON.stringify(searchData),\n      LoaderComponent: SearchLoaderComponent,\n      ErrorComponent: SearchErrorComponent,\n      debounceDuration = 350,\n    },\n    details: {\n      Component: DetailComponent,\n      loader: loadSingleFunction,\n      NotFoundComponent: DetailNotFoundComponent,\n      preProcessMarkerData: preProcessMarkerDataForSingleLoad = markerData =>\n        markerData,\n      getCacheKey: getDetailsCacheKey = searchData =>\n        JSON.stringify(searchData),\n      LoaderComponent: DetailLoaderComponent,\n      ErrorComponent: DetailErrorComponent,\n    },\n  },\n  LoaderComponent: CommonLoaderComponent,\n  ErrorComponent: CommonErrorComponent,\n  getCache,\n}) => {\n  DetailComponent = getDetailComponent({\n    Component: DetailComponent,\n    NotFoundComponent: DetailNotFoundComponent,\n    loader: loadSingleFunction,\n    getCacheKey: getDetailsCacheKey,\n    preProcessMarkerData: preProcessMarkerDataForSingleLoad,\n    LoaderComponent: DetailLoaderComponent || CommonLoaderComponent,\n    ErrorComponent: DetailErrorComponent || CommonErrorComponent,\n    getCache,\n  });\n\n  SearchResultsComponent = SearchResultsItemComponent\n    ? getSearchResultPickerComponent({\n        ItemComponent: SearchResultsItemComponent,\n        NoItemsComponent: NoResultItemComponent,\n        ContainerComponent: SearchResultsComponent,\n        onSelect: resultItemComponentOnSelect,\n      })\n    : SearchResultsComponent;\n\n  const cache = getCache();\n\n  const LoaderComponent = SearchLoaderComponent || CommonLoaderComponent;\n  const ErrorComponent = SearchErrorComponent || CommonErrorComponent;\n\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    const {markerData} = marker;\n    const searchData = preProcessMarkerDataForSearch(markerData) ?? null;\n\n    const [{loading, error, results}, setResults] = useState({});\n\n    mutableRef.current.isLocked = marker.isLocked;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.searchData = searchData;\n\n    const cacheKey = useDebounceValue(\n      searchData != null ? getSearchCacheKey(searchData) : null,\n      debounceDuration\n    );\n    useEffect(() => {\n      if (mutableRef.current.isLocked) {\n        setResults({});\n        return null;\n      }\n      mutableRef.current.cacheKey = cacheKey;\n      if (cacheKey === null) {\n        mutableRef.current.onHide();\n        return null;\n      }\n\n      const cachedResults = cache.getItem(cacheKey);\n      if (cachedResults) {\n        setResults({results: cachedResults});\n        return null;\n      }\n      const abortCtrl = new AbortController();\n      setResults({loading: true});\n      searchFunction(mutableRef.current.searchData, abortCtrl.signal)\n        .then(results => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          cache.setItem(cacheKey, results);\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({results});\n          }\n        })\n        .catch(error => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          if (error.aborted) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === cacheKey) {\n            setResults({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey]); // , marker.isLocked, onHide, searchData\n\n    if (marker.isLocked) {\n      return (\n        <DetailComponent\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          updateMarker={update => {\n            markersHandlers.updateMarker(marker, update);\n          }}\n        />\n      );\n    }\n\n    if (loading) {\n      return <LoaderComponent loadData={searchData} />;\n    }\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n    if (!results) {\n      return null;\n    }\n    return (\n      <SearchResultsComponent\n        results={results}\n        marker={marker}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        updateMarker={update => {\n          markersHandlers.updateMarker(marker, update);\n        }}\n      />\n    );\n  };\n};\n\nconst getTip = ({\n  tipsOptionsByType,\n  LoaderComponent,\n  ErrorComponent,\n  debounceDuration,\n  getCache,\n}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = getSingleTip({\n      tipOptions: tipsOptionsByType[type],\n      LoaderComponent,\n      ErrorComponent,\n      debounceDuration,\n      getCache,\n    });\n  }\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nconst defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nconst wrapGetCache = getCache => () => {\n  const cache = getCache();\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  debounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  lineHeight,\n}) => {\n  getCache = getCache ? wrapGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = {};\n  const anchors = [];\n  baseAnchors.forEach(anchor => {\n    tipsOptionsByType[anchor.type] = {\n      search: anchor.searchOptions,\n      details: anchor.detailsOptions,\n    };\n    anchors.push({\n      anchorChar: anchor.anchorChar,\n      type: anchor.type,\n      parts: anchor.parts,\n    });\n  });\n  return withId(getId)(\n    withTips({\n      hideOnEscape: hideTipOnEscape,\n      TipComponent: getTip({\n        tipsOptionsByType,\n        LoaderComponent,\n        ErrorComponent,\n        debounceDuration,\n        getCache,\n      }),\n    })(\n      withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n        withFocusTipOnDown(\n          withMarkableTextArea({\n            classNameGetters,\n            defaultBackgroundColor: backgroundColor,\n            defaultLineHeight: lineHeight,\n          })(\n            withResize(\n              withMarkerParser({\n                markerParserOptions: {\n                  version,\n                  anchors,\n                },\n              })(\n                withMarkerSelectionBlocker(\n                  withSelectionChange(\n                    withBlockUndoRedoAndDragDropText(BaseTextArea)\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({updateMarker}) => {\n  const [countDown, setCountDown] = useState(4);\n  const updateMarkerRef = useRef();\n  updateMarkerRef.current = updateMarker;\n  useEffect(() => {\n    const t = setInterval(() => {\n      setCountDown(countDown => countDown - 1);\n    }, 1000);\n    return () => clearInterval(t);\n  }, []);\n  const done = countDown === 0;\n  useEffect(() => {\n    if (done) {\n      updateMarkerRef.current(null);\n    }\n  }, [done]);\n  return <b>Person not found! will delete in {countDown}</b>;\n};\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  anchors: [\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultItemComponent: PersonSearchResultItem,\n        NoResultItemComponent: () => 'No matching people found',\n        resultItemComponentOnSelect: ({selectedItem: person}) => ({\n          textValue: person.name,\n          markerData: {\n            id: person.id,\n          },\n        }),\n        loader: ({name}, signal) => personSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: PersonDetails,\n        NotFoundComponent: NotFoundPersonComponent,\n        loader: ({id}, signal) => personDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultsComponent: ({ResultListComponent, ...props}) => (\n          <p>\n            <h5>Found the following things:</h5>\n            <ResultListComponent {...props} />\n          </p>\n        ),\n        ResultItemComponent: ThingSearchResultItem,\n        resultItemComponentOnSelect: ({selectedItem: thing}) => ({\n          textValue: thing.name,\n          markerData: {\n            id: thing.id,\n          },\n        }),\n        loader: ({name}, signal) => thingSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: ThingDetails,\n        loader: ({id}, signal) => thingDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useState} from 'react';\r\nimport classes from './App.module.css';\r\nimport SmartTextArea, {people, things} from './SmartTextArea';\r\n\r\nconst availablePpl = people.map(person => person.name).join(', ');\r\nconst availableThings = things.map(thing => thing.name).join(', ');\r\nconst App = () => {\r\n  const [markers, setMarkers] = useState([]);\r\n  const [inEditMarker, setInEditMarker] = useState([]);\r\n  return (\r\n    <div className={classes.container}>\r\n      <ul>\r\n        <li>\r\n          use @ to trigger person marker start. Available people to search:\r\n          <ul>\r\n            <li>{availablePpl}</li>\r\n          </ul>\r\n          people marker color is the default gray color\r\n        </li>\r\n        <li>\r\n          use # to trigger things marker start. Available things to search:\r\n          <ul>\r\n            <li>{availableThings}</li>\r\n          </ul>\r\n          things marker color is a custom orange color\r\n        </li>\r\n      </ul>\r\n      <SmartTextArea\r\n        className=\"smart-text-area\"\r\n        initValue={\r\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\r\n        }\r\n        initMarkers={[\r\n          {start: 0, end: 13, type: 'person', markerData: {id: 'mo'}},\r\n          {start: 46, end: 54, type: 'person', markerData: {id: 'john'}},\r\n          {start: 78, end: 86, type: 'person', markerData: {id: 'jane'}},\r\n          {start: 112, end: 117, type: 'person', markerData: {id: 'asdfg'}},\r\n          {start: 149, end: 153, type: 'thing', markerData: {id: 'fork'}},\r\n          {start: 155, end: 160, type: 'thing', markerData: {id: 'knife'}},\r\n          {start: 165, end: 170, type: 'thing', markerData: {id: 'spoon'}},\r\n        ]}\r\n        onMarkersChange={e => {\r\n          setMarkers(e.markers);\r\n        }}\r\n        onInEditMarkerChange={e => {\r\n          setInEditMarker(e.inEditMarker);\r\n        }}\r\n      />\r\n      <p>\r\n        <h5>Markers:</h5>\r\n        <pre>\r\n          {markers.map(marker => (\r\n            <div\r\n              className={\r\n                marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\r\n              }>\r\n              {JSON.stringify(marker, null, 3)}\r\n            </div>\r\n          ))}\r\n        </pre>\r\n      </p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}