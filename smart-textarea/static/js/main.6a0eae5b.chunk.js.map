{"version":3,"sources":["environment/App/App.module.css","lib/helpers/mergeRefs.js","lib/hooks/useImperativeForwarder.js","lib/helpers/blockMarkerUpdates.js","lib/hocs/withMarkerSelection.js","lib/hocs/withMarkerParser.js","lib/hocs/withMarkableTextArea.js","lib/hocs/withResize.js","lib/hocs/withSelectionChange.js","lib/hocs/withTips.js","lib/hooks/useDebounceValue.js","lib/hocs/withFocusTipOnDown.js","lib/hocs/withBlurTipsOnOutsideClickOrFocusOnInsideClick.js","lib/hocs/withBlockUndoRedoAndDragDropText.js","lib/hocs/withBaseTextArea.js","lib/hocs/withSmartTextArea.js","environment/App/SmartTextArea.js","environment/App/App.js","index.js"],"names":["module","exports","mergeRefs","refs","mergedRef","element","i","length","ref","current","useImperativeForwarder","parentImperativeRef","init","deps","mutableRef","useRef","update","value","merged","children","useImperativeHandle","elem","blockMarkerUpdates","selection","markers","midSelectedMarkerIndex","endSelectedMarkerIndex","startSelectedMarkerIndex","midSelectedMarker","endSelectedMarker","startSelectedMarker","isLocked","block","selectionStart","start","selectionEnd","end","withInEditMarkerIndex","inEditMarkerIndex","markerWithEndTouchedIndex","getInEditMarkerIndex","getMarkerSelections","prevMarkerIndex","nextMarkerIndex","selectedMarkersRange","startIndex","endIndex","markerWithStartTouchedIndex","getReturn","marker","startTotallySelected","endTotallySelected","totalySelected","withMarkerSelection","TextArea","forwardRef","onSelectionChangeFromParent","onSelectionChange","onInEditMarkerChange","restProps","innerRef","e","textarea","target","isSingleSelection","prevSelection","startCursorMoved","endCursorMoved","newSelection","oldInEditMarkerIndex","DEFAULT_END","spaces","createMarker","uuid","version","anchor","type","markerData","data","Math","round","random","Date","now","parseMarkers","options","anchors","parts","j","key","startChar","endChars","partStart","substring","push","anchorChar","wrapMarkerParser","markerOffset","oldFirstMarker","map","prevValue","insertedText","markerParser","newValue","lengthChange","newMarkers","slice","nextMarkers","inEditMarker","startParse","endParse","toParse","parsedValue","parsedMarkers","nextNewMarkers","withMarkerParser","markerParserOptions","forEach","endChar","initValue","initMarkers","onInputFromParent","onInput","onChangeFromParent","onChange","onMarkersChange","disabled","imperativeRef","props","console","warn","useState","setInternalValue","setInternalMarkers","setValue","setMarkers","updateMarker","findIndex","m","updateFunction","newMarker","textValue","cursor","appendText","markerUpdates","hasNewText","join","oldValue","oldMarkers","undefined","childImperativeRef","useEffect","newSelectionEnd","prevSelectionEnd","minSelectionEnd","min","blockResult","blockTimer","clearTimeout","setTimeout","err","preventDefault","error","newCursorPosition","properties","getCoordinatesAtPositions","positions","debug","el","document","querySelector","parentNode","removeChild","div","createElement","id","body","appendChild","style","computed","window","getComputedStyle","currentStyle","isInput","nodeName","whiteSpace","wordWrap","position","visibility","prop","boxSizing","height","parseInt","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","lineHeight","clientHeight","scrollHeight","overflowY","clientWidth","scrollWidth","overflowX","contentBuilder","last","replace","spans","span","textContent","backgroundColor","coordinates","topCorrection","marginTop","scrollTop","leftCorrection","borderLeftWidth","marginLeft","scrollLeft","top","offsetTop","left","offsetLeft","right","markers2Labels","positionsWithNoDuplicates","coordinatesWithNoDuplicates","labels","x","y","h","x2","y2","w","lines","getStyleFromLableLine","width","LabelLine","labelLine","TipAnchor","anchorProps","TipComponent","FrontLabelLines","labelLines","getClassName","tipClassName","InnerComponent","visibleTipDataFromParent","visibleTipData","updateTipVisibility","updateTipFocusFunction","markersHandlers","textAreaId","tipsZIndex","visibleTipLabelLineIndex","setVisibleTipLabelLineIndex","visibleTipIndex","labelLineIndex","mouseEnter","timer","visibile","showTip","hideTip","mouseLeave","focus","delta","markerUuid","focusImperativeRef","useCallback","obj","hasVisibleTip","isFirstLine","isLastLine","menuButtonId","menuListId","isTipVisible","renderLabelLine","role","onMouseEnter","onMouseLeave","onPointerDown","onPointerUp","onClick","className","attachment","targetAttachment","zIndex","constraints","to","renderTarget","renderElement","focusParent","onHide","whereToFocus","DefaultTip","JSON","stringify","FrontMarkers","getTipClassName","visibleTipsData","isFirstLastOrTipVisible","isInEdit","BackLabelLines","BackMarkers","isFirstLast","Boolean","defaultClassNameGetters","back","front","tip","withMarkableTextArea","defaultBackgroundColor","classNameGetters","onResizeFromParent","onResize","onScrollFromParent","onScroll","onMarkersChangeFromParent","onInEditMarkerChangeFromParent","imperativeRefFromParent","setLabels","setInEditMarker","withResize","iframeRef","iframeWindow","contentWindow","onresize","title","withSelectionChange","onSelectionChangeListener","activeElement","addEventListener","onKeyUpListener","removeEventListener","SKIP_HIDE","DEFAULT_HIDE","TOGGLE_VISIBLITY","withHideTipOnEscape","listener","wrapHideAction","baseHideAction","visiblityStack","requestedHideType","hideOrNewVisiblityStack","Array","isArray","filter","withTips","hideOnEscape","dataStack","setVisibleTipsSettings","visibleTipsSettings","tipsData","tipsDataStack","hideAction","find","oldDataStack","newCurrMarkerDataStack","lastTipData","newTipsData","newDataStack","newTipsDataStack","oldInEditMarker","useDebounceValue","duration","debouncedValue","setDebouncedValue","t","withFocusTipOnDown","tipData","stopPropagation","prevInEditMarker","withBlurTipsOnOutsideClickOrFocusOnInsideClick","mutable","clickListener","onTextArea","onTip","onMarker","dataset","tipForTextarea","tipAnchorForTextarea","anchorMarkerUuid","tipAnchorForMarker","tipForMarker","withBlockUndoRedoAndDragDropText","prevent","preventUndoRedo","keyCode","ctrlKey","withBaseTextArea","React","getSingleTip","tipOptions","search","SearchResultsComponent","ResultsComponent","SearchResultsItemComponent","ResultItemComponent","resultItemComponentOnSelect","NoResultItemComponent","searchFunction","loader","preProcessMarkerData","preProcessMarkerDataForSearch","getCacheKey","getSearchCacheKey","searchData","SearchLoaderComponent","LoaderComponent","SearchErrorComponent","ErrorComponent","debounceDuration","details","DetailComponent","Component","loadSingleFunction","DetailNotFoundComponent","NotFoundComponent","preProcessMarkerDataForSingleLoad","getDetailsCacheKey","DetailLoaderComponent","DetailErrorComponent","CommonLoaderComponent","CommonErrorComponent","getCache","defaultDebounceDuration","cache","loading","setResult","loadData","cacheKey","cachedData","getItem","abortCtrl","AbortController","signal","then","result","setItem","catch","aborted","abort","getDetailComponent","ItemComponent","NoItemsComponent","ContainerComponent","ResultListComponent","onSelect","results","focusedIndex","setFocusedIndex","index","num","mod","select","selectedItem","focused","focusedRef","getAttribute","removeAttribute","onKeyDown","next","item","tabIndex","getSearchResultPickerComponent","resultsCacheKey","setResults","debouncedCacheKey","cachedResults","getTip","tipsOptionsByType","message","ComponentsByType","defaultGetCache","withSmartTextArea","baseAnchors","hideTipOnEscape","getId","defaultLineHeight","defaultWidth","wrapGetCache","searchOptions","detailsOptions","withId","withStyle","people","name","imageUrl","things","SmartTextArea","person","src","alt","Promise","resolve","reject","trim","toLocaleLowerCase","includes","toLowerCase","Error","personSearch","countDown","setCountDown","updateMarkerRef","setInterval","clearInterval","done","personDetails","thing","thingSearch","thingDetails","availablePpl","availableThings","App","classes","container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.6a0eae5b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"inEditMarker\":\"App_inEditMarker__2hzif\"};","const mergeRefs = (...refs) => {\n  const mergedRef = element => {\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      if (typeof ref === 'function') {\n        ref(element);\n      } else if (typeof ref === 'string') {\n        // console.log(ref, element);\n      } else if (ref) {\n        ref.current = element;\n      }\n    }\n  };\n  return mergedRef;\n};\n\nexport default mergeRefs;\n","import {useImperativeHandle, useRef} from 'react';\n\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n};\n\nconst useImperativeForwarder = (parentImperativeRef, init, deps) => {\n  const mutableRef = useRef({});\n  const mergedRef = useRef({});\n  const update = () => {\n    const merged = {\n      ...mutableRef.current.children,\n      ...mutableRef.current.current,\n    };\n    mergedRef.current = merged;\n    setRef(parentImperativeRef, merged);\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useImperativeHandle(\n    elem => {\n      mutableRef.current.current = elem;\n      update();\n    },\n    init,\n    deps\n  );\n  return [\n    elem => {\n      mutableRef.current.children = elem;\n      update();\n    },\n    mergedRef,\n    mutableRef,\n  ];\n};\n\nexport default useImperativeForwarder;\n","export const blockMarkerUpdates = selection => {\n  const {\n    markers,\n    midSelectedMarkerIndex,\n    endSelectedMarkerIndex,\n    startSelectedMarkerIndex,\n  } = selection;\n\n  const midSelectedMarker = markers[midSelectedMarkerIndex];\n  const endSelectedMarker = markers[endSelectedMarkerIndex];\n  const startSelectedMarker = markers[startSelectedMarkerIndex];\n\n  if (midSelectedMarker && midSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: midSelectedMarker.start,\n      selectionEnd: midSelectedMarker.end,\n    };\n  }\n  if (endSelectedMarker && endSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: endSelectedMarker.start,\n      selectionEnd: endSelectedMarker.end,\n    };\n  }\n  if (startSelectedMarker && startSelectedMarker.isLocked) {\n    return {\n      block: true,\n      selectionStart: startSelectedMarker.start,\n      selectionEnd: startSelectedMarker.end,\n    };\n  }\n  return {\n    block: false,\n  };\n};\n","import React, {forwardRef, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst getInEditMarkerIndex = selection =>\n  selection.midSelectedMarkerIndex >= 0\n    ? selection.midSelectedMarkerIndex\n    : selection.endSelectedMarkerIndex >= 0\n    ? selection.endSelectedMarkerIndex\n    : selection.markerWithEndTouchedIndex >= 0\n    ? selection.markerWithEndTouchedIndex\n    : -1;\nconst withInEditMarkerIndex = selection => {\n  const inEditMarkerIndex = getInEditMarkerIndex(selection);\n  selection.inEditMarkerIndex = inEditMarkerIndex;\n  return selection;\n};\n\nexport const getMarkerSelections = ({\n  markers,\n  selectionStart: start,\n  selectionEnd: end,\n}) => {\n  const selectedMarkersRange = {startIndex: -1, endIndex: -1};\n  let startSelectedMarkerIndex = -1;\n  let endSelectedMarkerIndex = -1;\n  let midSelectedMarkerIndex = -1;\n  let markerWithStartTouchedIndex = -1;\n  let markerWithEndTouchedIndex = -1;\n  let prevMarkerIndex;\n  let nextMarkerIndex;\n  let i = 0;\n\n  const getReturn = () =>\n    withInEditMarkerIndex({\n      markers,\n      selectedMarkersRange,\n      startSelectedMarkerIndex,\n      endSelectedMarkerIndex,\n      midSelectedMarkerIndex,\n      markerWithStartTouchedIndex,\n      markerWithEndTouchedIndex,\n      prevMarkerIndex,\n      nextMarkerIndex:\n        (nextMarkerIndex ?? -1) >= markers.length ? -1 : nextMarkerIndex ?? -1,\n    });\n\n  for (; i < markers.length && markers[i].end < start; i++);\n\n  prevMarkerIndex = i - 1;\n\n  let marker = markers[i];\n  if (!marker) {\n    return getReturn();\n  }\n\n  if (marker.end === start) {\n    markerWithEndTouchedIndex = prevMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n  }\n\n  if (marker.start >= end) {\n    nextMarkerIndex = i;\n    if (marker.start === end) {\n      markerWithStartTouchedIndex = i;\n    }\n    return getReturn();\n  }\n\n  let startTotallySelected = start <= marker.start && marker.start < end;\n  let endTotallySelected = start < marker.end && marker.end <= end;\n  let totalySelected = startTotallySelected && endTotallySelected;\n  const midSelected = !startTotallySelected && !endTotallySelected;\n\n  if (midSelected) {\n    midSelectedMarkerIndex = i;\n    nextMarkerIndex = i + 1;\n    return getReturn();\n  }\n  if (!totalySelected) {\n    if (startTotallySelected) {\n      startSelectedMarkerIndex = i;\n      nextMarkerIndex = i + 1;\n      return getReturn();\n    }\n\n    endSelectedMarkerIndex = i;\n    i++;\n    marker = markers[i];\n    if (!marker) {\n      return getReturn();\n    }\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      return getReturn();\n    }\n  }\n  selectedMarkersRange.startIndex = i;\n\n  i++;\n  for (; i < markers.length; i++) {\n    marker = markers[i];\n\n    startTotallySelected = start <= marker.start && marker.start < end;\n    endTotallySelected = start < marker.end && marker.end <= end;\n    totalySelected = startTotallySelected && endTotallySelected;\n\n    if (!totalySelected) {\n      if (startTotallySelected) {\n        nextMarkerIndex = i + 1;\n        startSelectedMarkerIndex = i;\n      } else {\n        nextMarkerIndex = i;\n        if (marker.start === end) {\n          markerWithStartTouchedIndex = i;\n        }\n      }\n      break;\n    }\n  }\n  selectedMarkersRange.endIndex = i;\n  return getReturn();\n};\n\nconst withMarkerSelection = (TextArea = 'textarea') =>\n  forwardRef(\n    (\n      {\n        onSelectionChange: onSelectionChangeFromParent,\n        value,\n        markers,\n        onInEditMarkerChange,\n        ...restProps\n      },\n      ref\n    ) => {\n      const mutableRef = useRef({});\n\n      const innerRef = useRef();\n\n      const onSelectionChange = e => {\n        /** @type {HTMLTextAreaElement} */\n        const textarea = e.target;\n\n        const selectionStart = textarea.selectionStart;\n        const selectionEnd = textarea.selectionEnd;\n\n        const isSingleSelection = selectionStart === selectionEnd;\n\n        let start = selectionStart;\n        let end = selectionEnd;\n\n        const prevSelection = mutableRef.current.selection;\n        const startCursorMoved =\n          !prevSelection || prevSelection?.selectionStart === selectionStart\n            ? 0\n            : selectionStart - prevSelection.selectionStart;\n        const endCursorMoved =\n          !prevSelection || prevSelection?.selectionEnd === selectionEnd\n            ? 0\n            : selectionEnd - prevSelection.selectionEnd;\n\n        let {\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          // eslint-disable-next-line prefer-const\n          prevMarkerIndex,\n          // eslint-disable-next-line prefer-const\n          nextMarkerIndex,\n        } = getMarkerSelections({\n          markers,\n          selectionStart,\n          selectionEnd,\n        });\n\n        if (midSelectedMarkerIndex >= 0) {\n          const midSelectedMarker = markers[midSelectedMarkerIndex];\n          if (midSelectedMarker.isLocked) {\n            if (isSingleSelection) {\n              if (startCursorMoved < 0) {\n                start = end = midSelectedMarker.start;\n                markerWithStartTouchedIndex = midSelectedMarkerIndex;\n              } else {\n                start = end = midSelectedMarker.end;\n                markerWithEndTouchedIndex = midSelectedMarkerIndex;\n              }\n              midSelectedMarkerIndex = -1;\n            } else {\n              start = midSelectedMarker.start;\n              end = midSelectedMarker.end;\n              selectedMarkersRange.startIndex = midSelectedMarkerIndex;\n              selectedMarkersRange.endIndex = midSelectedMarkerIndex;\n              midSelectedMarkerIndex = -1;\n            }\n          }\n        } else {\n          if (endSelectedMarkerIndex >= 0) {\n            const endSelectedMarker = markers[endSelectedMarkerIndex];\n            if (endSelectedMarker.isLocked) {\n              if (startCursorMoved < 0) {\n                start = endSelectedMarker.start;\n                selectedMarkersRange.startIndex = endSelectedMarkerIndex;\n                if (selectedMarkersRange.endIndex === -1) {\n                  selectedMarkersRange.endIndex = endSelectedMarkerIndex;\n                }\n                endSelectedMarkerIndex = -1;\n              } else {\n                start = endSelectedMarker.end;\n                markerWithEndTouchedIndex = endSelectedMarkerIndex;\n                endSelectedMarkerIndex = -1;\n              }\n            }\n          }\n          if (startSelectedMarkerIndex >= 0) {\n            const startSelectedMarker = markers[startSelectedMarkerIndex];\n            if (startSelectedMarker.isLocked) {\n              if (endCursorMoved > 0) {\n                end = startSelectedMarker.end;\n                selectedMarkersRange.endIndex = startSelectedMarkerIndex;\n                if (selectedMarkersRange.startIndex === -1) {\n                  selectedMarkersRange.startIndex = startSelectedMarkerIndex;\n                }\n                startSelectedMarkerIndex = -1;\n              } else {\n                end = startSelectedMarker.start;\n                markerWithStartTouchedIndex = startSelectedMarkerIndex;\n                startSelectedMarkerIndex = -1;\n              }\n            }\n          }\n        }\n\n        if (selectionEnd !== end) {\n          textarea.selectionEnd = end;\n        }\n        if (selectionStart !== start) {\n          textarea.selectionStart = start;\n        }\n\n        const newSelection = withInEditMarkerIndex({\n          markers,\n\n          selectionStart: start,\n          selectionEnd: end,\n\n          prevMarkerIndex,\n          midSelectedMarkerIndex,\n          markerWithEndTouchedIndex,\n          endSelectedMarkerIndex,\n          selectedMarkersRange,\n          startSelectedMarkerIndex,\n          markerWithStartTouchedIndex,\n          nextMarkerIndex,\n        });\n\n        mutableRef.current.selection = newSelection;\n\n        onInEditMarkerChange &&\n          onInEditMarkerChange({\n            target: textarea,\n            value,\n            markers,\n            inEditMarkerIndex: newSelection.inEditMarkerIndex,\n            oldInEditMarkerIndex: prevSelection?.inEditMarkerIndex,\n          });\n\n        onSelectionChangeFromParent &&\n          onSelectionChangeFromParent({\n            ...e,\n            ...newSelection,\n          });\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          {...restProps}\n          value={value}\n          markers={markers}\n          onSelectionChange={onSelectionChange}\n        />\n      );\n    }\n  );\n\nexport default withMarkerSelection;\n","import React, {useEffect, useState, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\nimport {blockMarkerUpdates} from '../helpers/blockMarkerUpdates';\nimport {getMarkerSelections} from './withMarkerSelection';\n\nconst DEFAULT_END = true;\nconst CURRENT_END = 1;\nconst NEXT_START = 2;\n\nconst spaces = {\n  ' ': DEFAULT_END,\n  '\\t': DEFAULT_END,\n  '\\r': DEFAULT_END,\n  '\\n': DEFAULT_END,\n  '\\v': DEFAULT_END,\n  '\\0': DEFAULT_END,\n};\n\nconst getUuid = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`;\nconst createMarker = ({\n  uuid,\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  markerData = {},\n  data,\n  isLocked = false,\n}) => ({\n  uuid: uuid ?? getUuid(),\n  version,\n  anchor,\n  type,\n  start,\n  end,\n  markerData,\n  data,\n  isLocked,\n});\nconst parseMarkers = (value, options) => {\n  let i = 0;\n  const anchors = options.anchors;\n  const markers = [];\n  while (i < value.length) {\n    let anchor;\n    while (i < value.length) {\n      if ((i === 0 || spaces[value[i - 1]]) && anchors[value[i]]) {\n        anchor = anchors[value[i]];\n        break;\n      }\n      i++;\n    }\n    if (!anchor) {\n      break;\n    }\n\n    const start = i;\n    i = start + 1;\n\n    const markerData = {};\n\n    const parts = anchor.parts;\n    for (let j = 0; j < parts.length; j++) {\n      const {key, startChar, endChars} = parts[j];\n      if (startChar) {\n        if (value[i] === startChar) {\n          i++;\n        } else {\n          break;\n        }\n      }\n      const partStart = i;\n      while (i < value.length) {\n        if (endChars[value[i]]) {\n          break;\n        }\n        i++;\n      }\n      markerData[key] = value.substring(partStart, i);\n      if (i >= value.length || endChars[value[i]] === DEFAULT_END) {\n        break;\n      }\n      if (endChars[value[i]] === CURRENT_END) {\n        i++;\n      }\n    }\n\n    markers.push({\n      anchor: anchor.anchorChar,\n      type: anchor.type,\n      version: options.version,\n      start,\n      end: i,\n      markerData,\n    });\n  }\n  return markers;\n};\n\nconst wrapMarkerParser =\n  (parseMarkers, options) => (value, markerOffset, oldFirstMarker) => {\n    const markers = parseMarkers(value, options).map((marker, i) => {\n      const updatedMarker = createMarker({\n        isLocked: false,\n        ...(i === 0 && marker.start === 0 ? oldFirstMarker : {}),\n        ...marker,\n        uuid:\n          i === 0 && marker.start === 0 && oldFirstMarker\n            ? oldFirstMarker.uuid\n            : null,\n        start: marker.start + markerOffset,\n        end: marker.end + markerOffset,\n        value,\n      });\n      return updatedMarker;\n    });\n    return [value, markers];\n  };\n\nconst update = ({\n  markers,\n  prevValue,\n  selectionStart,\n  selectionEnd,\n  insertedText,\n\n  prevMarkerIndex,\n  midSelectedMarkerIndex,\n  markerWithEndTouchedIndex,\n  endSelectedMarkerIndex,\n  nextMarkerIndex,\n  markerParser,\n}) => {\n  let newValue =\n    prevValue.substring(0, selectionStart) +\n    insertedText +\n    prevValue.substring(selectionEnd);\n\n  let lengthChange = newValue.length - prevValue.length;\n  let inEditMarkerIndex = -1;\n\n  let newMarkers = [];\n\n  if (midSelectedMarkerIndex >= 0) {\n    inEditMarkerIndex = midSelectedMarkerIndex;\n    const midSelectedMarker = markers[midSelectedMarkerIndex];\n    if (!midSelectedMarker.isLocked) {\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex));\n      newMarkers.push({\n        ...midSelectedMarker,\n        end: selectionEnd,\n      });\n    } else {\n      selectionStart = selectionEnd = midSelectedMarker.end;\n      newMarkers.push(...markers.slice(0, midSelectedMarkerIndex + 1));\n      lengthChange = insertedText.length;\n      newValue =\n        prevValue.substring(0, selectionStart) +\n        insertedText +\n        prevValue.substring(selectionEnd);\n    }\n    newMarkers.push(\n      ...markers.slice(midSelectedMarkerIndex + 1).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }))\n    );\n  } else {\n    if (markerWithEndTouchedIndex >= 0) {\n      inEditMarkerIndex = markerWithEndTouchedIndex;\n      newMarkers.push(...markers.slice(0, markerWithEndTouchedIndex + 1));\n    } else if (endSelectedMarkerIndex >= 0) {\n      inEditMarkerIndex = endSelectedMarkerIndex;\n      const endSelectedMarker = markers[endSelectedMarkerIndex];\n      if (!endSelectedMarker.isLocked) {\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex));\n        newMarkers.push({\n          ...endSelectedMarker,\n          end: selectionStart,\n        });\n      } else {\n        selectionStart = selectionEnd = endSelectedMarker.end;\n        newMarkers.push(...markers.slice(0, endSelectedMarkerIndex + 1));\n        lengthChange = insertedText.length;\n        newValue =\n          prevValue.substring(0, selectionStart) +\n          insertedText +\n          prevValue.substring(selectionEnd);\n      }\n    } else if (prevMarkerIndex >= 0) {\n      newMarkers.push(...markers.slice(0, prevMarkerIndex + 1));\n    }\n\n    if (nextMarkerIndex >= 0) {\n      const nextMarkers = markers.slice(nextMarkerIndex).map(marker => ({\n        ...marker,\n        start: marker.start + lengthChange,\n        end: marker.end + lengthChange,\n      }));\n\n      nextMarkerIndex = newMarkers.length;\n      newMarkers.push(...nextMarkers);\n\n      nextMarkerIndex =\n        nextMarkerIndex >= newMarkers.length ? -1 : nextMarkerIndex;\n    }\n  }\n\n  const inEditMarker = newMarkers[inEditMarkerIndex];\n  if (inEditMarker && !inEditMarker.isLocked) {\n    const startParse = inEditMarker.start;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(\n      toParse,\n      startParse,\n      inEditMarker // will just update him and should be returned as first element\n    );\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    newMarkers = [\n      ...newMarkers.slice(0, inEditMarkerIndex),\n      ...parsedMarkers,\n      ...newMarkers.slice(inEditMarkerIndex + 1),\n    ];\n  } else {\n    const startParse =\n      prevMarkerIndex >= 0 ? newMarkers[prevMarkerIndex].end : 0;\n    const endParse =\n      nextMarkerIndex >= 0\n        ? newMarkers[nextMarkerIndex].start\n        : newValue.length;\n    const toParse = newValue.substring(startParse, endParse);\n\n    const [parsedValue, parsedMarkers] = markerParser(toParse, startParse);\n\n    if (parsedValue !== toParse) {\n      const lengthChange = parsedValue - toParse;\n      if (lengthChange && nextMarkerIndex >= 0) {\n        for (let i = nextMarkerIndex; i < newMarkers.length; i++) {\n          const marker = newMarkers[i];\n          newMarkers[i] = {\n            ...marker,\n            start: marker.start + lengthChange,\n            end: marker.end + lengthChange,\n          };\n        }\n      }\n      newValue =\n        newValue.substring(0, startParse) +\n        parsedValue +\n        newValue.substring(endParse);\n    }\n\n    const nextNewMarkers = [];\n    if (prevMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(0, prevMarkerIndex + 1));\n    }\n    nextNewMarkers.push(...parsedMarkers);\n    if (nextMarkerIndex >= 0) {\n      nextNewMarkers.push(...newMarkers.slice(nextMarkerIndex));\n    }\n    newMarkers = nextNewMarkers;\n  }\n\n  return {\n    newValue,\n    newMarkers,\n    selectionStart,\n    selectionEnd,\n  };\n};\n\nconst withMarkerParser = ({\n  markerParser = parseMarkers,\n  markerParserOptions,\n} = {}) => {\n  if (markerParser === parseMarkers) {\n    const anchors = {};\n    markerParserOptions.anchors.forEach(anchor => {\n      const parts = anchor.parts.map(({startChar, endChar, key}, i, parts) => ({\n        key,\n        startChar,\n        endChars: {\n          ...(endChar ? {[endChar]: CURRENT_END} : spaces),\n          ...(parts[i + 1]?.startChar\n            ? {\n                [parts[i + 1].startChar]: NEXT_START,\n              }\n            : null),\n        },\n      }));\n      anchors[anchor.anchorChar] = {\n        ...anchor,\n        parts,\n      };\n    });\n    markerParserOptions = {...markerParserOptions, anchors};\n  }\n\n  markerParser = wrapMarkerParser(markerParser, markerParserOptions);\n\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          initValue,\n          initMarkers,\n          onInput: onInputFromParent,\n          onChange: onChangeFromParent,\n          onMarkersChange,\n          disabled,\n          imperativeRef,\n          ...props\n        },\n        ref\n      ) => {\n        const mutableRef = useRef();\n        mutableRef.current = mutableRef.current || {\n          value: initValue ?? '',\n          markers:\n            initMarkers?.map(marker =>\n              createMarker({\n                isLocked: true,\n                ...marker,\n              })\n            ) ?? [],\n        };\n\n        mutableRef.current.onMarkersChange = onMarkersChange;\n        mutableRef.current.disabled = disabled;\n\n        const innerRef = useRef();\n\n        if (props.value || props.markers) {\n          console.warn(\n            `Do not use props \"value\" and \"markers\". Use \"initValue\" and \"initMarkers\" instead`\n          );\n          delete props.markers;\n          delete props.value;\n        }\n\n        const [value, setInternalValue] = useState(mutableRef.current.value);\n        const [markers, setInternalMarkers] = useState(\n          mutableRef.current.markers\n        );\n        const setValue = value => {\n          mutableRef.current.value = value;\n          setInternalValue(value);\n        };\n        const setMarkers = markers => {\n          mutableRef.current.markers = markers;\n          setInternalMarkers(markers);\n        };\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => {\n            const updateMarker = (marker, update) => {\n              const markers = mutableRef.current.markers;\n              const value = mutableRef.current.value;\n              const i = markers.findIndex(m => m.uuid === marker.uuid);\n              if (i < 0) {\n                return false;\n              }\n              marker = markers[i];\n              const updateFunction = update => {\n                if (!update && update !== null) {\n                  return marker;\n                }\n\n                let newValue;\n                let newMarkers;\n                let newMarker = null;\n\n                if (update) {\n                  const {\n                    textValue,\n                    cursor,\n                    appendText = '',\n                    ...markerUpdates\n                  } = update;\n                  const hasNewText = textValue != null;\n                  const lengthChange = hasNewText\n                    ? textValue.length +\n                      appendText.length -\n                      (marker.end - marker.start)\n                    : 0;\n\n                  newMarkers = [...markers.slice(0, i)];\n                  newMarker = {\n                    ...marker,\n                    end: hasNewText\n                      ? marker.start + textValue.length\n                      : marker.end,\n                    ...markerUpdates,\n                  };\n                  newMarkers.push(newMarker);\n                  if (lengthChange) {\n                    newMarkers.push(\n                      ...markers.slice(i + 1).map(marker => ({\n                        ...marker,\n                        start: marker.start + lengthChange,\n                        end: marker.end + lengthChange,\n                      }))\n                    );\n                  } else {\n                    newMarkers.push(...markers.slice(i + 1));\n                  }\n\n                  newValue = value;\n                  if (hasNewText) {\n                    newValue = [\n                      value.substring(0, marker.start),\n                      textValue,\n                      appendText,\n                      value.substring(marker.end),\n                    ].join('');\n\n                    setValue(newValue);\n                  }\n                  setMarkers(newMarkers);\n                  if (cursor) {\n                    const textarea = innerRef.current;\n                    innerRef.current.value = newValue;\n                    const marker = newMarkers[i];\n                    if (cursor === 'start') {\n                      textarea.selectionStart = textarea.selectionEnd =\n                        marker.start;\n                    } else if (cursor === 'end') {\n                      textarea.selectionStart = textarea.selectionEnd =\n                        marker.end + appendText.length;\n                    }\n                  }\n                } else {\n                  const {start: selectionStart, end: selectionEnd} = marker;\n                  const lengthChange = selectionEnd - selectionStart;\n\n                  newValue =\n                    value.substring(0, marker.start) +\n                    value.substring(marker.end);\n\n                  newMarkers = [\n                    ...markers.slice(0, i),\n                    ...markers.slice(i + 1).map(marker => ({\n                      ...marker,\n                      start: marker.start - lengthChange,\n                      end: marker.end - lengthChange,\n                    })),\n                  ];\n\n                  setValue(newValue);\n                  setMarkers(newMarkers);\n                }\n\n                onMarkersChange &&\n                  onMarkersChange({\n                    target: innerRef.current,\n                    init: false,\n                    value: newValue,\n                    oldValue: value,\n                    markers: newMarkers,\n                    oldMarkers: markers,\n                  });\n\n                onChangeFromParent &&\n                  onChangeFromParent({\n                    target: innerRef.current,\n                    value: newValue,\n                    markers: newMarkers,\n                  });\n\n                return newMarker;\n              };\n              if (typeof update === 'function') {\n                return updateFunction(update(marker));\n              }\n              return updateFunction(update);\n            };\n            return {\n              updateMarker: (marker, update) =>\n                updateMarker(marker, marker => {\n                  if (typeof update === 'function') {\n                    update = update(marker);\n                  }\n                  if (mutableRef.current.disabled) {\n                    if (update === null) {\n                      return false; // if disabled you cannot delete a marker\n                    }\n                    if (update) {\n                      if (marker.data === undefined) {\n                        // if disabled you can only update the data and only if it didnt exist\n                        return {\n                          data: update.data,\n                        };\n                      }\n                      return false;\n                    }\n                  }\n                  if (update) {\n                    let isLocked;\n                    if (marker.isLocked) {\n                      isLocked = true;\n                      if (update.isLocked === false) {\n                        console.warn(\n                          'cannot unloack a locked marker. Will keep it locked!'\n                        );\n                      }\n                    } else {\n                      isLocked = update.isLocked ?? false;\n                    }\n                    return {\n                      isLocked,\n                      textValue: update.textValue,\n                      data:\n                        update.data === undefined ? marker.data : update.data,\n                      markerData: update.markerData ?? marker.markerData,\n                    };\n                  }\n                  return update;\n                }),\n            };\n          },\n          []\n        );\n\n        const onInput = e => {\n          const textarea = e.target;\n          const newValue = textarea.value;\n          const prevValue = value;\n          if (prevValue === newValue) {\n            return true;\n          }\n\n          const newSelectionEnd = textarea.selectionEnd;\n          const prevSelectionEnd =\n            prevValue.length - (newValue.length - newSelectionEnd);\n          const minSelectionEnd = Math.min(prevSelectionEnd, newSelectionEnd);\n\n          let selectionStart;\n          for (\n            selectionStart = 0;\n            selectionStart < minSelectionEnd &&\n            prevValue[selectionStart] === newValue[selectionStart];\n            selectionStart++\n          );\n\n          let selection = getMarkerSelections({\n            markers,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n          });\n\n          const blockResult = blockMarkerUpdates(selection);\n\n          if (mutableRef.current.blockTimer) {\n            clearTimeout(mutableRef.current.blockTimer);\n            mutableRef.current.blockTimer = null;\n          }\n          if (blockResult.block) {\n            textarea.selectionStart = blockResult.selectionStart;\n            textarea.selectionEnd = blockResult.selectionEnd;\n            mutableRef.current.blockTimer = setTimeout(() => {\n              mutableRef.current.blockTimer = null;\n              try {\n                textarea.selectionStart = blockResult.selectionStart;\n                textarea.selectionEnd = blockResult.selectionEnd;\n                // eslint-disable-next-line no-empty\n              } catch (err) {}\n            });\n            e.preventDefault();\n            return false;\n          }\n\n          const insertedText = newValue.substring(\n            selectionStart,\n            newSelectionEnd\n          );\n\n          const {\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n          } = selection;\n\n          const {newValue: parsedValue, newMarkers: parsedMarkers} = update({\n            markers,\n            prevValue,\n            selectionStart,\n            selectionEnd: prevSelectionEnd,\n            insertedText,\n\n            prevMarkerIndex,\n            midSelectedMarkerIndex,\n            markerWithEndTouchedIndex,\n            endSelectedMarkerIndex,\n            nextMarkerIndex,\n\n            markerParser,\n          });\n\n          if (parsedValue !== newValue) {\n            console.error(\n              `OOPS! input tracking is broken. Expected \"${newValue}\" got \"${parsedValue}\"`\n            );\n          }\n          setValue(parsedValue);\n          setMarkers(parsedMarkers);\n\n          const newCursorPosition = newSelectionEnd; // might need to be refined!!!\n          textarea.selectionStart = newCursorPosition; // forcing it for now if it isnt \"should\" always be though\n\n          selection = {\n            selectionStart: newCursorPosition,\n            selectionEnd: newCursorPosition,\n            ...getMarkerSelections({\n              markers: parsedMarkers,\n              selectionStart: newCursorPosition,\n              selectionEnd: newCursorPosition,\n            }),\n          };\n\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: false,\n              value: parsedValue,\n              oldValue: value,\n              markers: parsedMarkers,\n              oldMarkers: markers,\n            });\n\n          onInputFromParent &&\n            onInputFromParent({\n              target: textarea,\n              value: parsedValue,\n              markers: parsedMarkers,\n            });\n\n          return true;\n        };\n\n        const onChange = e => {\n          onChangeFromParent &&\n            onChangeFromParent({\n              target: e.target,\n              value: mutableRef.current.value,\n              markers: mutableRef.current.markers,\n            });\n        };\n\n        useEffect(() => {\n          const textarea = innerRef.current;\n          const onMarkersChange = mutableRef.current.onMarkersChange;\n          onMarkersChange &&\n            onMarkersChange({\n              target: textarea,\n              init: true,\n              value: mutableRef.current.value,\n              oldValue: '',\n              markers: mutableRef.current.markers,\n              oldMarkers: [],\n            });\n        }, []);\n\n        return (\n          <TextArea\n            {...props}\n            ref={mergeRefs(ref, innerRef)}\n            imperativeRef={childImperativeRef}\n            disabled={disabled}\n            value={value}\n            markers={markers}\n            onInput={onInput}\n            onChange={onChange}\n          />\n        );\n      }\n    );\n};\n\nexport default withMarkerParser;\n","import React, {\n  useEffect,\n  useState,\n  useRef,\n  forwardRef,\n  useCallback,\n} from 'react';\nimport TetherComponent from 'react-tether';\nimport mergeRefs from '../helpers/mergeRefs';\n\n// We'll copy the properties below into the mirror div.\n// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst properties = [\n  'direction', // RTL support\n  'boxSizing',\n  'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY', // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration', // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize',\n];\n\nfunction getCoordinatesAtPositions(element, positions, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) {\n    const el = document.querySelector(\n      '#input-textarea-caret-position-mirror-div'\n    );\n    if (el) el.parentNode.removeChild(el);\n  }\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  const style = div.style;\n  const computed = window.getComputedStyle\n    ? window.getComputedStyle(element)\n    : element.currentStyle; // currentStyle for IE < 9\n  const isInput = element.nodeName === 'INPUT';\n\n  // Default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (!isInput) style.wordWrap = 'break-word'; // only for textarea-s\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n  if (!debug) style.visibility = 'hidden'; // not 'display: none' because we want rendering\n\n  // Transfer the element's properties to the div\n  properties.forEach(prop => {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height, 10);\n        const outerHeight =\n          parseInt(computed.paddingTop, 10) +\n          parseInt(computed.paddingBottom, 10) +\n          parseInt(computed.borderTopWidth, 10) +\n          parseInt(computed.borderBottomWidth, 10);\n        const targetHeight = outerHeight + parseInt(computed.lineHeight, 10);\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = 0;\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else {\n      style[prop] = computed[prop];\n    }\n  });\n\n  // The thrid special handling for input type=\"text\" vs textarea:\n  // inputs has no scroll bar\n  if (!isInput && element.clientHeight < element.scrollHeight) {\n    style.overflowY = 'scroll';\n  } else {\n    style.overflowY = 'hidden';\n  }\n  if (!isInput && element.clientWidth < element.scrollWidth) {\n    style.overflowX = 'scroll';\n  } else {\n    style.overflowX = 'hidden';\n  }\n\n  const value = element.value;\n  const contentBuilder = [value.substring(0, positions[0])];\n  const last = value.length;\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] >= last) {\n      contentBuilder.push(null);\n      break;\n    }\n    // The thrid special handling for input type=\"text\" vs textarea:\n    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n    if (isInput) {\n      contentBuilder.push(value[positions[i]].replace(/\\s/g, '\\u00a0'));\n      contentBuilder.push(\n        value\n          .substring(positions[i] + 1, positions[i + 1])\n          .replace(/\\s/g, '\\u00a0')\n      );\n    } else {\n      contentBuilder.push(value[positions[i]]);\n      contentBuilder.push(value.substring(positions[i] + 1, positions[i + 1]));\n    }\n  }\n\n  const spans = [];\n  for (let i = 0; i < contentBuilder.length; i++) {\n    const span = document.createElement('span');\n    if (contentBuilder[i] === null) {\n      span.textContent = ' '; // || because a completely empty faux span doesn't render at all\n    } else {\n      span.textContent = contentBuilder[i];\n    }\n    if (i % 2) {\n      spans.push(span);\n      if (debug) {\n        span.style.backgroundColor = '#aaa';\n      }\n    }\n    div.appendChild(span);\n  }\n\n  const coordinates = [];\n\n  const topCorrection =\n    parseInt(computed.borderTopWidth, 10) +\n    parseInt(computed.marginTop, 10) -\n    element.scrollTop;\n  const leftCorrection =\n    parseInt(computed.borderLeftWidth, 10) +\n    parseInt(computed.marginLeft, 10) -\n    element.scrollLeft;\n  const height = parseInt(computed.lineHeight, 10);\n  for (let i = 0; i < spans.length; i++) {\n    coordinates.push({\n      top: spans[i].offsetTop + topCorrection,\n      left: spans[i].offsetLeft + leftCorrection,\n      height,\n    });\n  }\n\n  if (debug) {\n    style.top = '0';\n    style.right = '0';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\nconst markers2Labels = (textarea, markers, {debug} = {}) => {\n  if (!textarea) {\n    return [];\n  }\n  const positions = [];\n\n  for (let i = 0; i < markers.length; i++) {\n    positions.push(markers[i].start, markers[i].end);\n  }\n\n  const positionsWithNoDuplicates = [];\n  for (let i = 0; i < positions.length; i++) {\n    if (positions[i] !== positions[i - 1]) {\n      positionsWithNoDuplicates.push(positions[i]);\n    }\n  }\n\n  const coordinatesWithNoDuplicates = getCoordinatesAtPositions(\n    textarea,\n    positionsWithNoDuplicates,\n    {debug}\n  );\n  const coordinates = [];\n\n  for (let i = 0, j = 0; i < positions.length; i++) {\n    coordinates.push(coordinatesWithNoDuplicates[j]);\n    if (positions[i] !== positions[i + 1]) {\n      j++;\n    }\n  }\n\n  const labels = [];\n  const clientWidth = textarea.clientWidth;\n  for (let i = 0; i < coordinates.length; i += 2) {\n    const {left: x, top: y, height: h} = coordinates[i];\n    const {left: x2, top: y2} = coordinates[i + 1];\n    if (y !== y2) {\n      const parts = [{x, y, w: clientWidth - x, h}];\n      const lines = Math.round((y2 - y) / h) - 1;\n      for (let j = 0; j < lines; j++) {\n        parts.push({x: 0, y: y + (j + 1) * h, w: clientWidth, h});\n      }\n      parts.push({x: 0, y: y + (lines + 1) * h, w: x2, h});\n      labels.push(parts);\n    } else {\n      labels.push([{x, y, w: x2 - x, h}]);\n    }\n  }\n  return labels;\n};\n\nconst getStyleFromLableLine = ({x, y, w, h}) => ({\n  left: `${x}px`,\n  top: `${y}px`,\n  height: `${h}px`,\n  width: `${w}px`,\n});\n\nconst LabelLine = forwardRef(({labelLine, ...restProps}, ref) => (\n  <div ref={ref} {...restProps} style={getStyleFromLableLine(labelLine)} />\n));\n\nconst TipAnchor = forwardRef(\n  ({anchorProps, TipComponent, ...restProps}, ref) => (\n    <div ref={ref} {...anchorProps}>\n      <TipComponent {...restProps} />\n    </div>\n  )\n);\n\nconst FrontLabelLines = ({\n  marker,\n  labelLines,\n  getClassName,\n  tipClassName,\n  InnerComponent,\n  TipComponent,\n  visibleTipData: visibleTipDataFromParent,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) => {\n  const [visibleTipLabelLineIndex, setVisibleTipLabelLineIndex] = useState(-1);\n  let visibleTipIndex =\n    visibleTipDataFromParent == null\n      ? visibleTipLabelLineIndex\n      : visibleTipDataFromParent.labelLineIndex;\n\n  if (visibleTipIndex === true) {\n    visibleTipIndex = labelLines.length - 1;\n  }\n\n  const mutableRef = useRef({});\n\n  const showTip = (type, labelLineIndex) => {\n    if (visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(labelLineIndex);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: true,\n        labelLineIndex,\n        type,\n      });\n    }\n  };\n  const mouseEnter = labelLineIndex => {\n    clearTimeout(mutableRef.current.timer);\n    showTip('mouseOver', labelLineIndex);\n  };\n\n  const hideTip = type => {\n    if (!visibleTipDataFromParent == null) {\n      setVisibleTipLabelLineIndex(-1);\n    } else {\n      updateTipVisibility({\n        marker,\n        visibile: false,\n        type,\n      });\n    }\n  };\n  const mouseLeave = () => {\n    mutableRef.current.timer = setTimeout(() => {\n      hideTip('mouseOver');\n    }, 250);\n  };\n\n  useEffect(() => () => clearTimeout(mutableRef.current.timer), []);\n\n  const focus = ({start, delta} = {}) => {\n    delta = delta ?? 0;\n    if (start) {\n      markersHandlers.focus(marker.start - delta);\n    } else {\n      markersHandlers.focus(marker.end + delta);\n    }\n  };\n\n  const markerUuid = marker.uuid;\n  const focusImperativeRef = useCallback(\n    obj => {\n      updateTipFocusFunction({marker: markerUuid, focus: obj?.focus});\n    },\n    [updateTipFocusFunction, markerUuid]\n  );\n\n  const hasVisibleTip = visibleTipIndex >= 0;\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    const menuButtonId = `${marker.uuid}[${i}].button`;\n    const menuListId = `${marker.uuid}[${i}].list`;\n    const isTipVisible = TipComponent && visibleTipIndex === i;\n    const renderLabelLine = ref => (\n      <LabelLine\n        ref={ref}\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        id={menuButtonId}\n        role=\"button\"\n        aria-haspopup=\"true\"\n        aria-controls={menuListId}\n        aria-expanded={isTipVisible}\n        labelLine={labelLine}\n        onMouseEnter={() => mouseEnter(i)}\n        onMouseLeave={mouseLeave}\n        onPointerDown={focus}\n        onPointerUp={focus}\n        onClick={focus}\n        data-tip-anchor-for-textarea={textAreaId}\n        data-tip-anchor-for-marker={marker.uuid}\n        className={getClassName({\n          isFirstLine,\n          isLastLine,\n          isTipVisible: hasVisibleTip,\n        })}>\n        {InnerComponent ? (\n          <InnerComponent\n            marker={marker}\n            markersHandlers={markersHandlers}\n            labelLine={labelLine}\n            labelLineIndex={i}\n            labelLines={labelLines}\n          />\n        ) : null}\n      </LabelLine>\n    );\n    return isTipVisible ? (\n      <TetherComponent\n        key=\"visible-tip\"\n        attachment=\"top left\"\n        targetAttachment=\"bottom left\"\n        style={{zIndex: tipsZIndex}}\n        constraints={[\n          {\n            to: 'scrollParent',\n            attachment: 'together',\n          },\n          {\n            to: 'window',\n            attachment: 'together',\n          },\n        ]}\n        renderTarget={renderLabelLine}\n        renderElement={ref => (\n          <TipAnchor\n            ref={ref}\n            focusImperativeRef={focusImperativeRef}\n            TipComponent={TipComponent}\n            menuListId={menuListId}\n            menuButtonId={menuButtonId}\n            marker={marker}\n            markersHandlers={markersHandlers}\n            focusParent={focus}\n            onHide={whereToFocus => {\n              hideTip();\n              if (whereToFocus !== false) {\n                focus(whereToFocus); // when tip hides itself focus textarea\n              }\n            }}\n            anchorProps={{\n              className: tipClassName,\n              onMouseEnter: () => mouseEnter(i),\n              onMouseLeave: mouseLeave,\n              'data-tip-for-textarea': textAreaId,\n              'data-tip-for-marker': marker.uuid,\n            }}\n          />\n        )}\n      />\n    ) : (\n      renderLabelLine()\n    );\n  });\n};\n\nconst DefaultTip = ({marker}) => <pre>{JSON.stringify(marker, null, 3)}</pre>;\n\nconst FrontMarkers = ({\n  markers,\n  inEditMarker,\n  labels,\n  getClassName,\n  getTipClassName,\n  InnerComponent,\n  TipComponent = DefaultTip,\n  visibleTipsData,\n  updateTipVisibility,\n  updateTipFocusFunction,\n  markersHandlers,\n  textAreaId,\n  tipsZIndex,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <FrontLabelLines\n        key={marker.uuid}\n        marker={marker}\n        labelLines={labelLines}\n        getClassName={isFirstLastOrTipVisible =>\n          getClassName({\n            ...isFirstLastOrTipVisible,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            marker,\n          })\n        }\n        tipClassName={getTipClassName({marker})}\n        InnerComponent={InnerComponent}\n        TipComponent={TipComponent}\n        visibleTipData={\n          visibleTipsData\n            ? visibleTipsData[marker.uuid] != null\n              ? visibleTipsData[marker.uuid]\n              : false\n            : null\n        }\n        updateTipVisibility={updateTipVisibility}\n        updateTipFocusFunction={updateTipFocusFunction}\n        markersHandlers={markersHandlers}\n        textAreaId={textAreaId}\n        tipsZIndex={tipsZIndex}\n      />\n    );\n  });\n\nconst BackLabelLines = ({labelLines, getClassName}) => {\n  const last = labelLines.length - 1;\n  return labelLines.map((labelLine, i) => {\n    const isFirstLine = i === 0;\n    const isLastLine = i === last;\n    return (\n      <LabelLine\n        // eslint-disable-next-line react/no-array-index-key\n        key={i}\n        labelLine={labelLine}\n        className={getClassName({isFirstLine, isLastLine})}\n      />\n    );\n  });\n};\n\nconst BackMarkers = ({\n  markers,\n  labels,\n  inEditMarker,\n  visibleTipsData,\n  getClassName,\n}) =>\n  markers.map((marker, i) => {\n    const labelLines = labels[i];\n    if (!labelLines) {\n      return null;\n    }\n    return (\n      <BackLabelLines\n        key={marker.uuid}\n        labelLines={labelLines}\n        getClassName={isFirstLast =>\n          getClassName({\n            ...isFirstLast,\n            isInEdit: marker.uuid === inEditMarker?.uuid,\n            isTipVisible: Boolean(visibleTipsData[marker.uuid]),\n            marker,\n          })\n        }\n      />\n    );\n  });\n\nconst defaultClassNameGetters = {\n  back: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-back-label textarea-back-${marker.type}-label${\n      isFirstLine ? ' textarea-back-label-first-line' : ''\n    }${isLastLine ? ' textarea-back-label-last-line' : ''}${\n      isInEdit ? ' textarea-back-label-inedit' : ''\n    }${isTipVisible ? ' textarea-back-label-tip-shown' : ''}`,\n  front: ({isFirstLine, isLastLine, isInEdit, isTipVisible, marker}) =>\n    `textarea-front-label textarea-front-${marker.type}-label${\n      isFirstLine ? ' textarea-front-label-first-line' : ''\n    }${isLastLine ? ' textarea-front-label-last-line' : ''}${\n      isInEdit ? ' textarea-front-label-inedit' : ''\n    }${isTipVisible ? ' textarea-front-label-tip-shown' : ''}`,\n  tip: ({marker}) =>\n    `textarea-tip-container textarea-tip-${marker.type}-container`,\n};\n\nconst withMarkableTextArea = ({\n  defaultBackgroundColor = 'white',\n  tipsZIndex = 99999999,\n  classNameGetters = defaultClassNameGetters,\n} = {}) => {\n  classNameGetters = {...defaultClassNameGetters, ...classNameGetters};\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          backgroundColor = defaultBackgroundColor,\n          InnerComponent,\n          TipComponent,\n          visibleTipsData,\n          updateTipVisibility,\n          updateTipFocusFunction,\n          onResize: onResizeFromParent,\n          onScroll: onScrollFromParent,\n          onMarkersChange: onMarkersChangeFromParent,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          imperativeRef: imperativeRefFromParent,\n          id,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({markers: []});\n        const imperativeRef = useRef();\n\n        const innerRef = useRef();\n\n        const [labels, setLabels] = useState([]);\n        const [markers, setMarkers] = useState(mutableRef.current.markers);\n        const [inEditMarker, setInEditMarker] = useState(null);\n\n        const onResize = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onResizeFromParent && onResizeFromParent(e);\n        };\n        const onScroll = e => {\n          const textarea = innerRef.current;\n          setLabels(markers2Labels(textarea, markers));\n          onScrollFromParent && onScrollFromParent(e);\n        };\n        const onMarkersChange = e => {\n          const markers = e.markers;\n          setMarkers(markers);\n          onMarkersChangeFromParent && onMarkersChangeFromParent(e);\n        };\n        const onInEditMarkerChange = e => {\n          const inEditMarker = e.markers[e.inEditMarkerIndex];\n          setInEditMarker(inEditMarker);\n          onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n        };\n        useEffect(() => {\n          const textarea = innerRef.current;\n          mutableRef.current.markers = markers;\n          setLabels(markers2Labels(textarea, markers));\n        }, [markers]);\n\n        return (\n          <div\n            id={id}\n            className=\"textarea-container\"\n            style={{backgroundColor, width: restProps.style?.width}}>\n            <div className=\"textarea-back\">\n              <BackMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                visibleTipsData={visibleTipsData}\n                getClassName={classNameGetters.back}\n              />\n            </div>\n            <TextArea\n              ref={mergeRefs(ref, innerRef)}\n              {...restProps}\n              id={id}\n              imperativeRef={mergeRefs(imperativeRef, imperativeRefFromParent)}\n              onScroll={onScroll}\n              onResize={onResize}\n              onMarkersChange={onMarkersChange}\n              onInEditMarkerChange={onInEditMarkerChange}\n            />\n            <div className=\"textarea-front\">\n              <FrontMarkers\n                markers={mutableRef.current.markers}\n                inEditMarker={inEditMarker}\n                labels={labels}\n                getClassName={classNameGetters.front}\n                getTipClassName={classNameGetters.tip}\n                InnerComponent={InnerComponent}\n                TipComponent={TipComponent}\n                visibleTipsData={visibleTipsData}\n                updateTipVisibility={updateTipVisibility}\n                updateTipFocusFunction={updateTipFocusFunction}\n                markersHandlers={imperativeRef.current}\n                textAreaId={id}\n                tipsZIndex={tipsZIndex}\n              />\n            </div>\n          </div>\n        );\n      }\n    );\n};\n\nexport default withMarkableTextArea;\n","import React, {useEffect, useRef, forwardRef} from 'react';\n\nconst withResize = (TextArea = 'textarea') =>\n  forwardRef(({onResize, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onResize = onResize;\n\n    const iframeRef = useRef();\n\n    useEffect(() => {\n      const iframeElem = iframeRef.current;\n      const iframeWindow = iframeElem.contentWindow;\n      const onResizeListener = e => {\n        if (mutableRef.current.onResize) {\n          mutableRef.current.onResize(e);\n        }\n      };\n      iframeWindow.onresize = onResizeListener;\n      return () => {\n        iframeWindow.onresize = null;\n      };\n    }, []);\n    return (\n      <div\n        className=\"textarea-with-resize-container\"\n        style={{width: restProps.style?.width}}>\n        <iframe ref={iframeRef} title=\"resize-frame\" />\n        <TextArea ref={ref} {...restProps} />\n      </div>\n    );\n  });\n\nexport default withResize;\n","import React, {useEffect, useRef, forwardRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withSelectionChange = (TextArea = 'textarea') =>\n  forwardRef(({onSelectionChange, ...restProps}, ref) => {\n    const mutableRef = useRef({});\n    mutableRef.current.onSelectionChange = onSelectionChange;\n\n    const innerRef = useRef();\n\n    useEffect(() => {\n      const textarea = innerRef.current;\n      const onSelectionChangeListener = e => {\n        const textarea = innerRef.current;\n        if (\n          textarea === document.activeElement &&\n          mutableRef.current.onSelectionChange\n        ) {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      document.addEventListener('selectionchange', onSelectionChangeListener);\n      const onKeyUpListener = e => {\n        // for some reason delete and backspace do not fire selectionChange\n        const textarea = innerRef.current;\n        if (e.key === 'Delete' || e.key === 'Backspace') {\n          mutableRef.current.onSelectionChange({target: textarea});\n        }\n      };\n      textarea.addEventListener('keyup', onKeyUpListener);\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onSelectionChangeListener\n        );\n        textarea.removeEventListener('keyup', onKeyUpListener);\n      };\n    }, []);\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...restProps} />;\n  });\n\nexport default withSelectionChange;\n","import React, {\n  useEffect,\n  useState,\n  forwardRef,\n  useCallback,\n  useRef,\n} from 'react';\nimport useImperativeForwarder from '../hooks/useImperativeForwarder';\n\nexport const TOTAL_HIDE = 1;\nexport const SKIP_HIDE = false;\nexport const DEFAULT_HIDE = true;\n\nexport const VISIBLE = true;\nexport const NOT_VISIBLE = false;\nexport const TOGGLE_VISIBLITY = 'toggle';\n\nconst withHideTipOnEscape =\n  TipComponent =>\n  ({onHide, ...restProps}) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    useEffect(() => {\n      const listener = e => {\n        if (e.key === 'Escape') {\n          mutableRef.current.onHide();\n        }\n      };\n      document.addEventListener('keyup', listener);\n      return () => document.removeEventListener('keyup', listener);\n    }, []);\n    return <TipComponent onHide={onHide} {...restProps} />;\n  };\n\nconst wrapHideAction =\n  (baseHideAction = () => DEFAULT_HIDE) =>\n  ({markerUuid, visiblityStack, requestedHideType}) => {\n    const hideOrNewVisiblityStack = baseHideAction({\n      markerUuid,\n      visiblityStack,\n    });\n    if (Array.isArray(hideOrNewVisiblityStack)) {\n      return hideOrNewVisiblityStack;\n    }\n    if (hideOrNewVisiblityStack === SKIP_HIDE) {\n      return visiblityStack;\n    }\n    if (hideOrNewVisiblityStack === TOTAL_HIDE || !requestedHideType) {\n      return [];\n    }\n    return visiblityStack.filter(({type}) => type !== requestedHideType);\n  };\n\nconst withTips = ({TipComponent, hideOnEscape = true} = {}) => {\n  if (hideOnEscape) {\n    TipComponent = withHideTipOnEscape(TipComponent);\n  }\n  return (TextArea = 'textarea') =>\n    forwardRef(\n      (\n        {\n          imperativeRef,\n          onInEditMarkerChange: onInEditMarkerChangeFromParent,\n          ...restProps\n        },\n        ref\n      ) => {\n        const mutableRef = useRef({});\n        const [{data: visibleTipsData}, setVisibleTipsSettings] = useState({\n          data: {},\n          dataStack: {},\n        });\n\n        const updateTipFocusFunction = useCallback(({marker, focus}) => {\n          const markerUuid = marker?.uuid || marker;\n          setVisibleTipsSettings(visibleTipsSettings => {\n            const {data: tipsData, dataStack: tipsDataStack} =\n              visibleTipsSettings;\n\n            if (!tipsData[markerUuid]) {\n              return visibleTipsSettings;\n            }\n\n            return {\n              data: {\n                ...tipsData,\n                [markerUuid]: {\n                  ...tipsData[markerUuid],\n                  focus,\n                },\n              },\n              dataStack: tipsDataStack,\n            };\n          });\n        }, []);\n        const updateTipVisibility = useCallback(\n          ({marker, type, visibile, labelLineIndex, hideAction}) => {\n            hideAction = wrapHideAction(hideAction);\n            const markerUuid = marker?.uuid || marker;\n            if (!visibile && !markerUuid) {\n              setVisibleTipsSettings(visibleTipsSettings => {\n                const {data: tipsData, dataStack: tipsDataStack} =\n                  visibleTipsSettings;\n                const newTipsData = {...tipsData};\n                const newTipsDataStack = {...tipsDataStack};\n                // eslint-disable-next-line guard-for-in\n                for (const markerUuid in newTipsDataStack) {\n                  const newCurrMarkerDataStack = hideAction({\n                    markerUuid,\n                    visiblityStack: tipsDataStack[markerUuid],\n                    requestedHideType: type,\n                  });\n                  if (newCurrMarkerDataStack.length) {\n                    newTipsDataStack[markerUuid] = newCurrMarkerDataStack;\n\n                    const focus = newTipsData[markerUuid].focus;\n                    const lastTipData =\n                      newTipsDataStack[markerUuid][\n                        newTipsDataStack[markerUuid].length - 1\n                      ];\n                    newTipsData[markerUuid] = {\n                      type: lastTipData.type,\n                      labelLineIndex: lastTipData.labelLineIndex,\n                      focus,\n                    };\n                  } else {\n                    delete newTipsDataStack[markerUuid];\n                    delete newTipsData[markerUuid];\n                  }\n                }\n                return {\n                  data: newTipsData,\n                  dataStack: newTipsDataStack,\n                };\n              });\n              return;\n            }\n            setVisibleTipsSettings(visibleTipsSettings => {\n              const {data: tipsData, dataStack: tipsDataStack} =\n                visibleTipsSettings;\n\n              visibile =\n                visibile === TOGGLE_VISIBLITY\n                  ? !tipsDataStack[markerUuid]?.find(data => data.type === type)\n                  : Boolean(visibile);\n\n              if (!visibile) {\n                const oldDataStack = tipsDataStack[markerUuid];\n                if (!oldDataStack) {\n                  return visibleTipsSettings;\n                }\n                const newCurrMarkerDataStack = hideAction({\n                  markerUuid,\n                  visiblityStack: oldDataStack,\n                  requestedHideType: type,\n                });\n\n                if (newCurrMarkerDataStack.length) {\n                  const lastTipData =\n                    newCurrMarkerDataStack[newCurrMarkerDataStack.length - 1];\n                  return {\n                    data: {\n                      ...tipsData,\n                      [markerUuid]: {\n                        type: lastTipData.type,\n                        labelLineIndex: lastTipData.labelLineIndex,\n                        focus: tipsData[markerUuid].focus,\n                      },\n                    },\n                    dataStack: {\n                      ...tipsDataStack,\n                      [markerUuid]: newCurrMarkerDataStack,\n                    },\n                  };\n                }\n\n                const newTipsData = {...tipsData};\n                delete newTipsData[markerUuid];\n\n                const newDataStack = {...tipsDataStack};\n                delete newDataStack[markerUuid];\n\n                return {\n                  data: newTipsData,\n                  dataStack: newDataStack,\n                };\n              }\n              type = type || 'default-inner';\n              return {\n                data: {\n                  ...tipsData,\n                  [markerUuid]: {\n                    type,\n                    labelLineIndex: labelLineIndex ?? true,\n                    focus: tipsData[markerUuid]?.focus,\n                  },\n                },\n                dataStack: {\n                  ...tipsDataStack,\n                  [markerUuid]: [\n                    ...(tipsDataStack[markerUuid] || []).filter(\n                      data => data.type !== type\n                    ),\n                    {type, labelLineIndex: labelLineIndex ?? true},\n                  ],\n                },\n              };\n            });\n          },\n          []\n        );\n\n        const [childImperativeRef] = useImperativeForwarder(\n          imperativeRef,\n          () => ({\n            updateTipVisibility,\n          }),\n          [updateTipVisibility]\n        );\n\n        return (\n          <TextArea\n            ref={ref}\n            {...restProps}\n            imperativeRef={childImperativeRef}\n            TipComponent={TipComponent}\n            visibleTipsData={visibleTipsData}\n            updateTipVisibility={updateTipVisibility}\n            updateTipFocusFunction={updateTipFocusFunction}\n            onInEditMarkerChange={e => {\n              const {markers, inEditMarkerIndex} = e;\n              const inEditMarker = markers[inEditMarkerIndex];\n              const oldInEditMarker = mutableRef.current.inEditMarker;\n              mutableRef.current.inEditMarker = inEditMarker;\n              if (\n                oldInEditMarker &&\n                oldInEditMarker.uuid !== inEditMarker?.uuid\n              ) {\n                updateTipVisibility({\n                  marker: oldInEditMarker,\n                  visibile: false,\n                  type: 'inEdit',\n                });\n              }\n              if (inEditMarker && inEditMarker !== oldInEditMarker) {\n                // whether a different marker or same marker but updated\n                updateTipVisibility({\n                  marker: inEditMarker,\n                  visibile: true,\n                  type: 'inEdit',\n                });\n              }\n              onInEditMarkerChangeFromParent &&\n                onInEditMarkerChangeFromParent(e);\n            }}\n          />\n        );\n      }\n    );\n};\n\nexport default withTips;\n","import {useEffect, useState} from 'react';\n\nconst useDebounceValue = (value, duration) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      setDebouncedValue(value);\n    }, duration);\n    return () => clearTimeout(t);\n  }, [value, duration]);\n\n  return debouncedValue;\n};\n\nexport default useDebounceValue;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withFocusTipOnDown = TextArea =>\n  forwardRef(\n    (\n      {\n        visibleTipsData,\n        updateTipVisibility,\n        onInEditMarkerChange: onInEditMarkerChangeFromParent,\n        ...restProps\n      },\n      ref\n    ) => {\n      const innerRef = useRef();\n      const mutableRef = useRef({});\n      mutableRef.current.visibleTipsData = visibleTipsData;\n      mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n      useEffect(() => {\n        const textarea = innerRef.current;\n        const listener = e => {\n          const inEditMarker = mutableRef.current.inEditMarker;\n          if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && inEditMarker) {\n            mutableRef.current.updateTipVisibility({\n              marker: inEditMarker,\n              visibile: true,\n              type: 'keyboard',\n            });\n            const markerUuid = inEditMarker.uuid;\n            setTimeout(() => {\n              const tipData = mutableRef.current.visibleTipsData[markerUuid];\n              if (tipData?.focus) {\n                tipData.focus({\n                  delta: e.key === 'ArrowDown' ? 1 : -1,\n                });\n              }\n            });\n            e.preventDefault();\n            e.stopPropagation();\n          } else {\n            mutableRef.current.updateTipVisibility({\n              visibile: false,\n              type: 'keyboard',\n            });\n          }\n        };\n        textarea.addEventListener('keydown', listener);\n        return () => textarea.removeEventListener('keydow', listener);\n      }, []);\n\n      const onInEditMarkerChange = e => {\n        const inEditMarker = e.markers[e.inEditMarkerIndex];\n        const prevInEditMarker = mutableRef.current.inEditMarker;\n        if (prevInEditMarker && prevInEditMarker.uuid !== inEditMarker?.uuid) {\n          mutableRef.current.updateTipVisibility({\n            visibile: false,\n            type: 'keyboard',\n          });\n        }\n        mutableRef.current.inEditMarker = inEditMarker;\n        onInEditMarkerChangeFromParent && onInEditMarkerChangeFromParent(e);\n      };\n\n      return (\n        <TextArea\n          ref={mergeRefs(ref, innerRef)}\n          onInEditMarkerChange={onInEditMarkerChange}\n          visibleTipsData={visibleTipsData}\n          updateTipVisibility={updateTipVisibility}\n          {...restProps}\n        />\n      );\n    }\n  );\n\nexport default withFocusTipOnDown;\n","import React, {forwardRef, useEffect, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\nimport {\n  DEFAULT_HIDE,\n  SKIP_HIDE,\n  TOGGLE_VISIBLITY,\n  TOTAL_HIDE,\n} from './withTips';\n\nconst withBlurTipsOnOutsideClickOrFocusOnInsideClick = TextArea =>\n  forwardRef(({id, updateTipVisibility, ...restProps}, ref) => {\n    const innerRef = useRef();\n    const mutableRef = useRef({});\n    mutableRef.current.updateTipVisibility = updateTipVisibility;\n\n    useEffect(() => {\n      const mutable = mutableRef.current;\n      const clickListener = e => {\n        let elem = e.target;\n        let onTextArea = false;\n        let onTip = false;\n        let onMarker = false;\n        while (elem) {\n          onTextArea = elem.id === id;\n          onTip = elem.dataset?.tipForTextarea === id;\n          onMarker = elem.dataset?.tipAnchorForTextarea === id;\n          if (onTextArea || onTip || onMarker) {\n            break;\n          }\n          elem = elem.parentNode;\n        }\n        if (!onTextArea && !onTip && !onMarker) {\n          mutable.updateTipVisibility({\n            visibile: false,\n          });\n          e.preventDefault();\n        } else {\n          const anchorMarkerUuid = onMarker && elem.dataset.tipAnchorForMarker;\n          mutable.updateTipVisibility({\n            visibile: false,\n            type: 'clickOnTip',\n            hideAction: ({markerUuid, visiblityStack}) => {\n              if (markerUuid !== anchorMarkerUuid) {\n                return DEFAULT_HIDE;\n              }\n              return SKIP_HIDE;\n            },\n          });\n          if (onMarker) {\n            mutable.updateTipVisibility({\n              marker: anchorMarkerUuid,\n              visibile: TOGGLE_VISIBLITY,\n              type: 'clickOnTip',\n              hideAction: () => TOTAL_HIDE,\n            });\n          } else if (onTip) {\n            mutable.updateTipVisibility({\n              marker: elem.dataset.tipForMarker,\n              visibile: true,\n              type: 'clickOnTip',\n            });\n          }\n        }\n      };\n      document.addEventListener('click', clickListener);\n      return () => document.removeEventListener('click', clickListener);\n    }, [id]);\n\n    return (\n      <TextArea\n        id={id}\n        ref={mergeRefs(ref, innerRef)}\n        updateTipVisibility={updateTipVisibility}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBlurTipsOnOutsideClickOrFocusOnInsideClick;\n","import React, {forwardRef, useRef, useEffect} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBlockUndoRedoAndDragDropText = TextArea =>\n  forwardRef((props, ref) => {\n    const innerRef = useRef();\n\n    useEffect(() => {\n      /** @type {HTMLTextAreaElement} */\n      const textarea = innerRef.current;\n      const prevent = e => {\n        e.preventDefault();\n        return false;\n      };\n      const preventUndoRedo = e => {\n        if ((e.keyCode === 90 || e.keyCode === 89) && e.ctrlKey) {\n          // ctrl-z/ctrl-y\n          e.preventDefault();\n          return false;\n        }\n        return true;\n      };\n      textarea.addEventListener('dragstart', prevent);\n      textarea.addEventListener('dragenter', prevent);\n      textarea.addEventListener('dragover', prevent);\n      textarea.addEventListener('dragend', prevent);\n      textarea.addEventListener('keydown', preventUndoRedo);\n      return () => {\n        textarea.removeEventListener('dragstart', prevent);\n        textarea.removeEventListener('dragenter', prevent);\n        textarea.removeEventListener('dragover', prevent);\n        textarea.removeEventListener('dragend', prevent);\n        textarea.removeEventListener('keydown', preventUndoRedo);\n      };\n    }, []);\n\n    return <TextArea ref={mergeRefs(ref, innerRef)} {...props} />;\n  });\n\nexport default withBlockUndoRedoAndDragDropText;\n","import React, {useImperativeHandle, useRef} from 'react';\nimport mergeRefs from '../helpers/mergeRefs';\n\nconst withBaseTextArea = (TextArea = 'textarea') =>\n  React.forwardRef(({markers, imperativeRef, id, ...restProps}, ref) => {\n    const innerRef = useRef();\n    useImperativeHandle(\n      imperativeRef,\n      () => ({\n        focus: selection => {\n          const textarea = innerRef.current;\n          textarea.focus();\n          if (selection) {\n            if (typeof selection === 'number') {\n              textarea.selectionStart = selection;\n              textarea.selectionEnd = selection;\n            } else {\n              textarea.selectionStart = selection.selectionStart;\n              textarea.selectionEnd = selection.selectionEnd;\n            }\n          }\n        },\n      }),\n      []\n    );\n    return (\n      <TextArea\n        ref={mergeRefs(ref, innerRef)}\n        id={`${id}-textarea`}\n        {...restProps}\n      />\n    );\n  });\n\nexport default withBaseTextArea;\n","import React, {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport AbortController from 'abort-controller';\n\nimport withMarkerParser from './withMarkerParser';\nimport withMarkableTextArea from './withMarkableTextArea';\nimport withResize from './withResize';\nimport withSelectionChange from './withSelectionChange';\nimport withMarkerSelection from './withMarkerSelection';\nimport withTips from './withTips';\n\nimport useDebounceValue from '../hooks/useDebounceValue';\nimport withFocusTipOnDown from './withFocusTipOnDown';\nimport withBlurTipsOnOutsideClickOrFocusOnInsideClick from './withBlurTipsOnOutsideClickOrFocusOnInsideClick';\nimport withBlockUndoRedoAndDragDropText from './withBlockUndoRedoAndDragDropText';\nimport withBaseTextArea from './withBaseTextArea';\n\nconst getDetailComponent = ({\n  Component,\n  NotFoundComponent,\n  loader,\n  preProcessMarkerData,\n  getCacheKey,\n  LoaderComponent,\n  ErrorComponent,\n  getCache,\n}) => {\n  const cache = getCache();\n\n  NotFoundComponent = NotFoundComponent || Component;\n\n  return ({marker, updateMarker}) => {\n    const mutableRef = useRef({});\n\n    const [{loading, error}, setResult] = useState({});\n\n    const {data, markerData} = marker;\n    const loadData = preProcessMarkerData(markerData);\n    const cacheKey = getCacheKey(loadData);\n\n    mutableRef.current.loadData = loadData;\n    mutableRef.current.updateMarker = updateMarker;\n    mutableRef.current.cacheKey = cacheKey;\n\n    useEffect(() => {\n      if (data || data === null) {\n        return undefined;\n      }\n      const cachedData = cache.getItem(cacheKey);\n      if (cachedData || cachedData === null) {\n        mutableRef.current.updateMarker({\n          data: cachedData,\n        });\n        setResult({});\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResult({loading: true});\n      loader(mutableRef.current.loadData, abortCtrl.signal)\n        .then(result => {\n          result = result ?? null;\n          cache.setItem(cacheKey, result);\n          if (cacheKey === mutableRef.current.cacheKey) {\n            mutableRef.current.updateMarker({\n              data: result,\n            });\n            setResult({});\n          }\n        })\n        .catch(error => {\n          if (error.aborted) {\n            return;\n          }\n          if (cacheKey === mutableRef.current.cacheKey) {\n            setResult({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [cacheKey, data]);\n\n    if (loading) {\n      return <LoaderComponent loadData={loadData} />;\n    }\n\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n\n    if (data === null) {\n      return (\n        <NotFoundComponent\n          data={null}\n          marker={marker}\n          updateMarker={updateMarker}\n        />\n      );\n    }\n\n    if (data) {\n      return (\n        <Component data={data} marker={marker} updateMarker={updateMarker} />\n      );\n    }\n\n    return null;\n  };\n};\n\nconst modulo = (num, mod) => {\n  if (num < 0) {\n    return mod - 1 - ((-num - 1) % mod);\n  }\n  return num % mod;\n};\n\nconst getSearchResultPickerComponent = ({\n  ItemComponent,\n  NoItemsComponent = () => 'No matching entries found',\n  ContainerComponent = ({ResultListComponent, ...props}) => (\n    <ResultListComponent {...props} />\n  ),\n  onSelect,\n}) => {\n  const ResultListComponent = ({\n    results,\n    marker,\n    updateMarker,\n    onHide,\n    focusParent,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const [focusedIndex, setFocusedIndex] = useState(null);\n    useImperativeHandle(\n      focusImperativeRef,\n      () => ({\n        focus: ({start, end, delta, index}) => {\n          if (start) {\n            setFocusedIndex(0);\n          } else if (end) {\n            setFocusedIndex(-1);\n          } else if (delta != null) {\n            setFocusedIndex(focusedIndex =>\n              focusedIndex == null\n                ? delta > 0\n                  ? delta - 1\n                  : delta\n                : focusedIndex + delta\n            );\n          } else {\n            setFocusedIndex(index);\n          }\n        },\n      }),\n      []\n    );\n\n    const select = data => {\n      const update = onSelect({\n        selectedItem: data,\n        marker,\n      });\n      updateMarker({\n        data,\n        ...update,\n        isLocked: update.isLocked ?? true,\n        cursor: update.cursor ?? 'end',\n      });\n      setTimeout(() => onHide());\n    };\n\n    const focused =\n      focusedIndex == null ? null : modulo(focusedIndex, results.length);\n    const focusedRef = useRef();\n\n    useEffect(() => {\n      if (focused != null && focusedRef.current) {\n        focusedRef.current.focus();\n        const t = setTimeout(() => {\n          if (\n            document.activeElement !== focusedRef.current &&\n            document.activeElement.getAttribute('tabIndex') === '-1'\n          ) {\n            document.activeElement.removeAttribute('tabIndex');\n            focusedRef.current.focus();\n          }\n        });\n        return () => clearTimeout(t);\n      }\n      return undefined;\n    }, [focused]);\n\n    const onKeyDown = e => {\n      if (e.key === 'ArrowDown') {\n        const next = focused + 1;\n        if (next < results.length) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowUp') {\n        const next = focused - 1;\n        if (next >= 0) {\n          setFocusedIndex(next);\n        } else {\n          setFocusedIndex(null);\n          focusParent();\n        }\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowLeft') {\n        setFocusedIndex(null);\n        onHide({start: true});\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'ArrowRight') {\n        setFocusedIndex(null);\n        focusParent();\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (e.key === 'Enter') {\n        if (results[focused]) {\n          select(results[focused]);\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      }\n    };\n\n    if (!results.length) {\n      return <NoItemsComponent marker={marker} />;\n    }\n\n    return (\n      <ul\n        role=\"menu\"\n        id={menuListId}\n        aria-labelledby={menuButtonId}\n        className=\"search-results-list\"\n        onKeyDown={onKeyDown}>\n        {results.map((item, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <li key={i} role=\"none\">\n            <a\n              ref={elem => {\n                if (focused === i) {\n                  focusedRef.current = elem;\n                }\n              }}\n              role=\"menuitem\"\n              tabIndex=\"-1\"\n              className={`search-results-list-item${\n                focused === i ? ' search-results-list-item--focused' : ''\n              }`}\n              onClick={() => select(item)}>\n              <ItemComponent item={item} marker={marker} />\n            </a>\n          </li>\n        ))}\n      </ul>\n    );\n  };\n  return props => (\n    <ContainerComponent ResultListComponent={ResultListComponent} {...props} />\n  );\n};\n\nconst getSingleTip = ({\n  tipOptions: {\n    search: {\n      ResultsComponent: SearchResultsComponent,\n      ResultItemComponent: SearchResultsItemComponent,\n      resultItemComponentOnSelect,\n      NoResultItemComponent,\n      loader: searchFunction,\n      preProcessMarkerData: preProcessMarkerDataForSearch = markerData =>\n        markerData,\n      getCacheKey: getSearchCacheKey = searchData => JSON.stringify(searchData),\n      LoaderComponent: SearchLoaderComponent,\n      ErrorComponent: SearchErrorComponent,\n      debounceDuration,\n    },\n    details: {\n      Component: DetailComponent,\n      loader: loadSingleFunction,\n      NotFoundComponent: DetailNotFoundComponent,\n      preProcessMarkerData: preProcessMarkerDataForSingleLoad = markerData =>\n        markerData,\n      getCacheKey: getDetailsCacheKey = searchData =>\n        JSON.stringify(searchData),\n      LoaderComponent: DetailLoaderComponent,\n      ErrorComponent: DetailErrorComponent,\n    },\n  },\n  LoaderComponent: CommonLoaderComponent,\n  ErrorComponent: CommonErrorComponent,\n  getCache,\n  defaultDebounceDuration,\n}) => {\n  debounceDuration = debounceDuration || defaultDebounceDuration;\n\n  DetailComponent = getDetailComponent({\n    Component: DetailComponent,\n    NotFoundComponent: DetailNotFoundComponent,\n    loader: loadSingleFunction,\n    getCacheKey: getDetailsCacheKey,\n    preProcessMarkerData: preProcessMarkerDataForSingleLoad,\n    LoaderComponent: DetailLoaderComponent || CommonLoaderComponent,\n    ErrorComponent: DetailErrorComponent || CommonErrorComponent,\n    getCache,\n  });\n\n  SearchResultsComponent = SearchResultsItemComponent\n    ? getSearchResultPickerComponent({\n        ItemComponent: SearchResultsItemComponent,\n        NoItemsComponent: NoResultItemComponent,\n        ContainerComponent: SearchResultsComponent,\n        onSelect: resultItemComponentOnSelect,\n      })\n    : SearchResultsComponent;\n\n  const cache = getCache();\n\n  const LoaderComponent = SearchLoaderComponent || CommonLoaderComponent;\n  const ErrorComponent = SearchErrorComponent || CommonErrorComponent;\n\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    const {markerData} = marker;\n    const searchData = preProcessMarkerDataForSearch(markerData) ?? null;\n\n    const [{loading, error, results, resultsCacheKey}, setResults] = useState(\n      {}\n    );\n\n    mutableRef.current.isLocked = marker.isLocked;\n    mutableRef.current.onHide = onHide;\n    mutableRef.current.searchData = searchData;\n\n    const cacheKey = searchData != null ? getSearchCacheKey(searchData) : null;\n    const debouncedCacheKey = useDebounceValue(cacheKey, debounceDuration);\n    useEffect(() => {\n      if (mutableRef.current.isLocked) {\n        setResults({});\n        return undefined;\n      }\n      mutableRef.current.cacheKey = debouncedCacheKey;\n      if (debouncedCacheKey === null) {\n        mutableRef.current.onHide();\n        return undefined;\n      }\n\n      const cachedResults = cache.getItem(debouncedCacheKey);\n      if (cachedResults) {\n        setResults({\n          results: cachedResults,\n          resultsCacheKey: debouncedCacheKey,\n        });\n        return undefined;\n      }\n      const abortCtrl = new AbortController();\n      setResults({loading: true});\n      searchFunction(mutableRef.current.searchData, abortCtrl.signal)\n        .then(results => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          cache.setItem(debouncedCacheKey, results);\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResults({results, resultsCacheKey: debouncedCacheKey});\n          }\n        })\n        .catch(error => {\n          if (mutableRef.current.isLocked) {\n            return;\n          }\n          if (error.aborted) {\n            return;\n          }\n          if (mutableRef.current.cacheKey === debouncedCacheKey) {\n            setResults({error});\n          }\n        });\n      return () => abortCtrl.abort();\n    }, [debouncedCacheKey]);\n\n    if (marker.isLocked) {\n      return (\n        <DetailComponent\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n          updateMarker={update => {\n            markersHandlers.updateMarker(marker, update);\n          }}\n        />\n      );\n    }\n\n    if (loading) {\n      return <LoaderComponent loadData={searchData} />;\n    }\n    if (error) {\n      return <ErrorComponent error={error} />;\n    }\n    if (!results || resultsCacheKey !== cacheKey) {\n      return null;\n    }\n    return (\n      <SearchResultsComponent\n        results={results}\n        marker={marker}\n        focusParent={focusParent}\n        onHide={onHide}\n        focusImperativeRef={focusImperativeRef}\n        menuListId={menuListId}\n        menuButtonId={menuButtonId}\n        updateMarker={update => {\n          markersHandlers.updateMarker(marker, update);\n        }}\n      />\n    );\n  };\n};\n\nconst getTip = ({\n  tipsOptionsByType,\n  LoaderComponent = () => 'Loading...',\n  ErrorComponent = ({error}) => error?.message || 'Oops',\n  defaultDebounceDuration,\n  getCache,\n}) => {\n  const ComponentsByType = {};\n  // eslint-disable-next-line guard-for-in\n  for (const type in tipsOptionsByType) {\n    ComponentsByType[type] = getSingleTip({\n      tipOptions: tipsOptionsByType[type],\n      LoaderComponent,\n      ErrorComponent,\n      defaultDebounceDuration,\n      getCache,\n    });\n  }\n  return ({\n    marker,\n    focusParent,\n    onHide,\n    markersHandlers,\n    focusImperativeRef,\n    menuListId,\n    menuButtonId,\n  }) => {\n    const mutableRef = useRef({});\n\n    mutableRef.current.onHide = onHide;\n\n    const Component = ComponentsByType[marker.type];\n    useEffect(() => {\n      if (!Component) {\n        mutableRef.current.onHide();\n      }\n    }, [Component]);\n\n    if (Component) {\n      return (\n        <Component\n          marker={marker}\n          focusParent={focusParent}\n          onHide={onHide}\n          markersHandlers={markersHandlers}\n          focusImperativeRef={focusImperativeRef}\n          menuListId={menuListId}\n          menuButtonId={menuButtonId}\n        />\n      );\n    }\n    return null;\n  };\n};\n\nconst defaultGetCache = () => {\n  const cache = {};\n  return {\n    getItem: cacheKey => cache[cacheKey],\n    setItem: (cacheKey, value) => {\n      cache[cacheKey] = value;\n    },\n  };\n};\n\nconst wrapGetCache = getCache => () => {\n  const cache = getCache();\n  return {\n    getItem: cacheKey => {\n      try {\n        return cache.getItem(cacheKey);\n      } catch (err) {\n        console.error('error getting cache item', err);\n        return undefined;\n      }\n    },\n    setItem: (cacheKey, value) => {\n      try {\n        cache[cacheKey] = value;\n      } catch (err) {\n        console.error('error setting cache item', err);\n      }\n    },\n  };\n};\n\nconst withId =\n  getId =>\n  (TextArea = 'textarea') =>\n    forwardRef(({id, ...restProps}, ref) => {\n      const textAreaId = useRef(id || getId()).current;\n      return <TextArea ref={ref} id={textAreaId} {...restProps} />;\n    });\n\nconst withStyle =\n  ({defaultLineHeight = '135%', defaultWidth}) =>\n  (TextArea = 'textarea') =>\n  ({width, lineHeight, ...restProps}) =>\n    (\n      <TextArea\n        {...restProps}\n        style={{\n          ...restProps.style,\n          width: width ?? restProps.style?.width ?? defaultWidth,\n          lineHeight:\n            lineHeight ?? restProps.style?.lineHeight ?? defaultLineHeight,\n        }}\n      />\n    );\n\nconst withSmartTextArea = ({\n  anchors: baseAnchors,\n  version,\n  LoaderComponent,\n  ErrorComponent,\n  hideTipOnEscape = true,\n  defaultDebounceDuration = 300,\n  getId = () => `${Math.round(Math.random() * 999999)}-${Date.now()}`,\n  classNameGetters,\n  getCache,\n  backgroundColor,\n  defaultLineHeight,\n  defaultWidth,\n  TextArea,\n  tipsZIndex,\n}) => {\n  getCache = getCache ? wrapGetCache(getCache) : defaultGetCache;\n\n  const tipsOptionsByType = {};\n  const anchors = [];\n  baseAnchors.forEach(anchor => {\n    tipsOptionsByType[anchor.type] = {\n      search: anchor.searchOptions,\n      details: anchor.detailsOptions,\n    };\n    anchors.push({\n      anchorChar: anchor.anchorChar,\n      type: anchor.type,\n      parts: anchor.parts,\n    });\n  });\n  return withId(getId)(\n    withStyle({\n      defaultLineHeight,\n      defaultWidth,\n    })(\n      withTips({\n        hideOnEscape: hideTipOnEscape,\n        TipComponent: getTip({\n          tipsOptionsByType,\n          LoaderComponent,\n          ErrorComponent,\n          defaultDebounceDuration,\n          getCache,\n        }),\n      })(\n        withBlurTipsOnOutsideClickOrFocusOnInsideClick(\n          withFocusTipOnDown(\n            withMarkableTextArea({\n              classNameGetters,\n              tipsZIndex,\n              defaultBackgroundColor: backgroundColor,\n            })(\n              withResize(\n                withMarkerParser({\n                  markerParserOptions: {\n                    version,\n                    anchors,\n                  },\n                })(\n                  withMarkerSelection(\n                    withSelectionChange(\n                      withBlockUndoRedoAndDragDropText(\n                        withBaseTextArea(TextArea)\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n};\n\nexport default withSmartTextArea;\n","import React, {useEffect, useRef, useState} from 'react';\nimport {withSmartTextArea} from '../../lib';\nimport './SmartTextArea.css';\n\nconst ErrorComponent = ({error}) => error.message;\nconst LoaderComponent = () => (\n  <h5>\n    <b>Loading...</b>\n  </h5>\n);\n\nconst PersonDetails = ({data: person}) => (\n  <div className=\"person-details-container\">\n    <img src={person.imageUrl} alt=\"person\" />\n  </div>\n);\nconst PersonSearchResultItem = ({item: person}) => (\n  <div className=\"person-item\">\n    <img src={person.imageUrl} alt=\"person\" />\n    &nbsp;\n    {person.name}\n  </div>\n);\n\nexport const people = [\n  {\n    id: 'mo',\n    name: 'Mohammad Amin',\n    imageUrl: './img/img (2).jpg',\n  },\n  {\n    id: 'lara',\n    name: 'Lara Croft',\n    imageUrl: './img/img (1).png',\n  },\n  {\n    id: 'john',\n    name: 'John Doe',\n    imageUrl: './img/img (1).jpg',\n  },\n  {\n    id: 'jane',\n    name: 'Jane Doe',\n    imageUrl: './img/img (2).png',\n  },\n  {\n    id: 'bilz',\n    name: 'Bilal Harb',\n    imageUrl: './img/img (3).jpg',\n  },\n  {\n    id: 'paul',\n    name: 'Paul Pogba',\n    imageUrl: './img/img (3).png',\n  },\n  {\n    id: 'nitin',\n    name: 'Nitin Picktach',\n    imageUrl: './img/img (4).png',\n  },\n];\nconst personSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        people.filter(person =>\n          person.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst personDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(people.find(person => person.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst ThingDetails = ({data: thing}) => (\n  <div>\n    <h5>{thing.name}</h5>\n    <p>{thing.details}</p>\n  </div>\n);\nconst ThingSearchResultItem = ({item: thing}) => (\n  <div className=\"thing-item\">{thing.name}</div>\n);\n\nexport const things = [\n  {\n    id: 'spoon',\n    name: 'Spoon',\n    details: 'To eat soup',\n  },\n  {\n    id: 'fork',\n    name: 'Fork',\n    details: 'To eat fries',\n  },\n  {\n    id: 'spork',\n    name: 'Spork',\n    details: 'Multi purpose',\n  },\n  {\n    id: 'knife',\n    name: 'Knife',\n    details: 'To cut food',\n  },\n  {\n    id: 'plate',\n    name: 'Plate',\n    details: 'Food container',\n  },\n  {\n    id: 'pencil',\n    name: 'Pencil',\n    imageUrl: '/img/img (3).jpg',\n    details: 'To write down notes',\n  },\n  {\n    id: 'Pen',\n    name: 'Pen',\n    details: 'To write in exams',\n  },\n];\nconst thingSearch = (name, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(\n        things.filter(thing =>\n          thing.name\n            ?.trim()\n            .toLocaleLowerCase()\n            .includes(name?.trim().toLowerCase())\n        )\n      );\n    }, 1000 + 2000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst thingDetails = (id, signal) =>\n  new Promise((resolve, reject) => {\n    const t = setTimeout(() => {\n      resolve(things.find(thing => thing.id === id));\n    }, 500 + 1000 * Math.random());\n    signal.addEventListener('abort', () => {\n      const error = new Error('aborted');\n      error.aborted = true;\n      clearTimeout(t);\n      reject(error);\n    });\n  });\n\nconst NotFoundPersonComponent = ({updateMarker}) => {\n  const [countDown, setCountDown] = useState(4);\n  const updateMarkerRef = useRef();\n  updateMarkerRef.current = updateMarker;\n  useEffect(() => {\n    const t = setInterval(() => {\n      setCountDown(countDown => countDown - 1);\n    }, 1000);\n    return () => clearInterval(t);\n  }, []);\n  const done = countDown === 0;\n  useEffect(() => {\n    if (done) {\n      updateMarkerRef.current(null);\n    }\n  }, [done]);\n  return <b>Person not found! will delete in {countDown}</b>;\n};\n\nconst SmartTextArea = withSmartTextArea({\n  version: 0,\n  anchors: [\n    {\n      anchorChar: '@',\n      type: 'person',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultItemComponent: PersonSearchResultItem,\n        NoResultItemComponent: () => 'No matching people found',\n        resultItemComponentOnSelect: ({selectedItem: person}) => ({\n          textValue: person.name,\n          markerData: {\n            id: person.id,\n          },\n        }),\n        loader: ({name}, signal) => personSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: PersonDetails,\n        NotFoundComponent: NotFoundPersonComponent,\n        loader: ({id}, signal) => personDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n    {\n      anchorChar: '#',\n      type: 'thing',\n      parts: [\n        {\n          key: 'name',\n        },\n      ],\n      searchOptions: {\n        ResultsComponent: ({ResultListComponent, ...props}) => (\n          <p>\n            <h5>Found the following things:</h5>\n            <ResultListComponent {...props} />\n          </p>\n        ),\n        ResultItemComponent: ThingSearchResultItem,\n        resultItemComponentOnSelect: ({selectedItem: thing}) => ({\n          textValue: thing.name,\n          markerData: {\n            id: thing.id,\n          },\n        }),\n        loader: ({name}, signal) => thingSearch(name, signal),\n        getCacheKey: ({name}) => name?.trim().toLowerCase() || null,\n        debounceDuration: 350,\n      },\n      detailsOptions: {\n        Component: ThingDetails,\n        loader: ({id}, signal) => thingDetails(id, signal),\n        getCacheKey: ({id}) => id,\n      },\n    },\n  ],\n  ErrorComponent,\n  LoaderComponent,\n  hideTipOnEscape: true,\n});\n\nexport default SmartTextArea;\n","import React, {useState} from 'react';\nimport classes from './App.module.css';\nimport SmartTextArea, {people, things} from './SmartTextArea';\n\nconst availablePpl = people.map(person => person.name).join(', ');\nconst availableThings = things.map(thing => thing.name).join(', ');\nconst App = () => {\n  const [markers, setMarkers] = useState([]);\n  const [inEditMarker, setInEditMarker] = useState([]);\n  return (\n    <div className={classes.container}>\n      <ul>\n        <li>\n          use @ to trigger person marker start. Available people to search:\n          <ul>\n            <li>{availablePpl}</li>\n          </ul>\n          people marker color is the default gray color\n        </li>\n        <li>\n          use # to trigger things marker start. Available things to search:\n          <ul>\n            <li>{availableThings}</li>\n          </ul>\n          things marker color is a custom orange color\n        </li>\n      </ul>\n      <SmartTextArea\n        className=\"smart-text-area\"\n        initValue={\n          'Mohammad Amin is the author of this component\\nJohn Doe is a generic male name\\nJane Doe is a generic female name\\nasdfg is a name not in our database\\n\\nFork, Knife and Spoon are kitchen utensils we eat with'\n        }\n        initMarkers={[\n          {start: 0, end: 13, type: 'person', markerData: {id: 'mo'}},\n          {start: 46, end: 54, type: 'person', markerData: {id: 'john'}},\n          {start: 78, end: 86, type: 'person', markerData: {id: 'jane'}},\n          {start: 112, end: 117, type: 'person', markerData: {id: 'asdfg'}},\n          {start: 149, end: 153, type: 'thing', markerData: {id: 'fork'}},\n          {start: 155, end: 160, type: 'thing', markerData: {id: 'knife'}},\n          {start: 165, end: 170, type: 'thing', markerData: {id: 'spoon'}},\n        ]}\n        onMarkersChange={e => {\n          setMarkers(e.markers);\n        }}\n        onInEditMarkerChange={e => {\n          setInEditMarker(e.markers[e.inEditMarkerIndex]);\n        }}\n      />\n      <p>\n        <h5>Markers:</h5>\n        <pre>\n          {markers.map(marker => (\n            <div\n              className={\n                marker.uuid === inEditMarker?.uuid ? classes.inEditMarker : ''\n              }>\n              {JSON.stringify(marker, null, 3)}\n            </div>\n          ))}\n        </pre>\n      </p>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './environment/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}